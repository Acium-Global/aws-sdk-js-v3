"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.serializeAws_restJson1DeleteProxySessionCommand =
  exports.serializeAws_restJson1DeletePhoneNumberCommand =
  exports.serializeAws_restJson1DeleteMeetingCommand =
  exports.serializeAws_restJson1DeleteEventsConfigurationCommand =
  exports.serializeAws_restJson1DeleteChannelModeratorCommand =
  exports.serializeAws_restJson1DeleteChannelMessageCommand =
  exports.serializeAws_restJson1DeleteChannelMembershipCommand =
  exports.serializeAws_restJson1DeleteChannelBanCommand =
  exports.serializeAws_restJson1DeleteChannelCommand =
  exports.serializeAws_restJson1DeleteAttendeeCommand =
  exports.serializeAws_restJson1DeleteAppInstanceUserCommand =
  exports.serializeAws_restJson1DeleteAppInstanceStreamingConfigurationsCommand =
  exports.serializeAws_restJson1DeleteAppInstanceAdminCommand =
  exports.serializeAws_restJson1DeleteAppInstanceCommand =
  exports.serializeAws_restJson1DeleteAccountCommand =
  exports.serializeAws_restJson1CreateVoiceConnectorGroupCommand =
  exports.serializeAws_restJson1CreateVoiceConnectorCommand =
  exports.serializeAws_restJson1CreateUserCommand =
  exports.serializeAws_restJson1CreateSipRuleCommand =
  exports.serializeAws_restJson1CreateSipMediaApplicationCallCommand =
  exports.serializeAws_restJson1CreateSipMediaApplicationCommand =
  exports.serializeAws_restJson1CreateRoomMembershipCommand =
  exports.serializeAws_restJson1CreateRoomCommand =
  exports.serializeAws_restJson1CreateProxySessionCommand =
  exports.serializeAws_restJson1CreatePhoneNumberOrderCommand =
  exports.serializeAws_restJson1CreateMeetingWithAttendeesCommand =
  exports.serializeAws_restJson1CreateMeetingDialOutCommand =
  exports.serializeAws_restJson1CreateMeetingCommand =
  exports.serializeAws_restJson1CreateChannelModeratorCommand =
  exports.serializeAws_restJson1CreateChannelMembershipCommand =
  exports.serializeAws_restJson1CreateChannelBanCommand =
  exports.serializeAws_restJson1CreateChannelCommand =
  exports.serializeAws_restJson1CreateBotCommand =
  exports.serializeAws_restJson1CreateAttendeeCommand =
  exports.serializeAws_restJson1CreateAppInstanceUserCommand =
  exports.serializeAws_restJson1CreateAppInstanceAdminCommand =
  exports.serializeAws_restJson1CreateAppInstanceCommand =
  exports.serializeAws_restJson1CreateAccountCommand =
  exports.serializeAws_restJson1BatchUpdateUserCommand =
  exports.serializeAws_restJson1BatchUpdatePhoneNumberCommand =
  exports.serializeAws_restJson1BatchUnsuspendUserCommand =
  exports.serializeAws_restJson1BatchSuspendUserCommand =
  exports.serializeAws_restJson1BatchDeletePhoneNumberCommand =
  exports.serializeAws_restJson1BatchCreateRoomMembershipCommand =
  exports.serializeAws_restJson1BatchCreateChannelMembershipCommand =
  exports.serializeAws_restJson1BatchCreateAttendeeCommand =
  exports.serializeAws_restJson1AssociateSigninDelegateGroupsWithAccountCommand =
  exports.serializeAws_restJson1AssociatePhoneNumberWithUserCommand =
  exports.serializeAws_restJson1AssociatePhoneNumbersWithVoiceConnectorGroupCommand =
  exports.serializeAws_restJson1AssociatePhoneNumbersWithVoiceConnectorCommand =
    void 0;
exports.serializeAws_restJson1GetVoiceConnectorGroupCommand =
  exports.serializeAws_restJson1GetVoiceConnectorEmergencyCallingConfigurationCommand =
  exports.serializeAws_restJson1GetVoiceConnectorCommand =
  exports.serializeAws_restJson1GetUserSettingsCommand =
  exports.serializeAws_restJson1GetUserCommand =
  exports.serializeAws_restJson1GetSipRuleCommand =
  exports.serializeAws_restJson1GetSipMediaApplicationLoggingConfigurationCommand =
  exports.serializeAws_restJson1GetSipMediaApplicationCommand =
  exports.serializeAws_restJson1GetRoomCommand =
  exports.serializeAws_restJson1GetRetentionSettingsCommand =
  exports.serializeAws_restJson1GetProxySessionCommand =
  exports.serializeAws_restJson1GetPhoneNumberSettingsCommand =
  exports.serializeAws_restJson1GetPhoneNumberOrderCommand =
  exports.serializeAws_restJson1GetPhoneNumberCommand =
  exports.serializeAws_restJson1GetMessagingSessionEndpointCommand =
  exports.serializeAws_restJson1GetMeetingCommand =
  exports.serializeAws_restJson1GetGlobalSettingsCommand =
  exports.serializeAws_restJson1GetEventsConfigurationCommand =
  exports.serializeAws_restJson1GetChannelMessageCommand =
  exports.serializeAws_restJson1GetBotCommand =
  exports.serializeAws_restJson1GetAttendeeCommand =
  exports.serializeAws_restJson1GetAppInstanceStreamingConfigurationsCommand =
  exports.serializeAws_restJson1GetAppInstanceRetentionSettingsCommand =
  exports.serializeAws_restJson1GetAccountSettingsCommand =
  exports.serializeAws_restJson1GetAccountCommand =
  exports.serializeAws_restJson1DisassociateSigninDelegateGroupsFromAccountCommand =
  exports.serializeAws_restJson1DisassociatePhoneNumbersFromVoiceConnectorGroupCommand =
  exports.serializeAws_restJson1DisassociatePhoneNumbersFromVoiceConnectorCommand =
  exports.serializeAws_restJson1DisassociatePhoneNumberFromUserCommand =
  exports.serializeAws_restJson1DescribeChannelModeratorCommand =
  exports.serializeAws_restJson1DescribeChannelModeratedByAppInstanceUserCommand =
  exports.serializeAws_restJson1DescribeChannelMembershipForAppInstanceUserCommand =
  exports.serializeAws_restJson1DescribeChannelMembershipCommand =
  exports.serializeAws_restJson1DescribeChannelBanCommand =
  exports.serializeAws_restJson1DescribeChannelCommand =
  exports.serializeAws_restJson1DescribeAppInstanceUserCommand =
  exports.serializeAws_restJson1DescribeAppInstanceAdminCommand =
  exports.serializeAws_restJson1DescribeAppInstanceCommand =
  exports.serializeAws_restJson1DeleteVoiceConnectorTerminationCredentialsCommand =
  exports.serializeAws_restJson1DeleteVoiceConnectorTerminationCommand =
  exports.serializeAws_restJson1DeleteVoiceConnectorStreamingConfigurationCommand =
  exports.serializeAws_restJson1DeleteVoiceConnectorProxyCommand =
  exports.serializeAws_restJson1DeleteVoiceConnectorOriginationCommand =
  exports.serializeAws_restJson1DeleteVoiceConnectorGroupCommand =
  exports.serializeAws_restJson1DeleteVoiceConnectorEmergencyCallingConfigurationCommand =
  exports.serializeAws_restJson1DeleteVoiceConnectorCommand =
  exports.serializeAws_restJson1DeleteSipRuleCommand =
  exports.serializeAws_restJson1DeleteSipMediaApplicationCommand =
  exports.serializeAws_restJson1DeleteRoomMembershipCommand =
  exports.serializeAws_restJson1DeleteRoomCommand =
    void 0;
exports.serializeAws_restJson1RedactChannelMessageCommand =
  exports.serializeAws_restJson1PutVoiceConnectorTerminationCredentialsCommand =
  exports.serializeAws_restJson1PutVoiceConnectorTerminationCommand =
  exports.serializeAws_restJson1PutVoiceConnectorStreamingConfigurationCommand =
  exports.serializeAws_restJson1PutVoiceConnectorProxyCommand =
  exports.serializeAws_restJson1PutVoiceConnectorOriginationCommand =
  exports.serializeAws_restJson1PutVoiceConnectorLoggingConfigurationCommand =
  exports.serializeAws_restJson1PutVoiceConnectorEmergencyCallingConfigurationCommand =
  exports.serializeAws_restJson1PutSipMediaApplicationLoggingConfigurationCommand =
  exports.serializeAws_restJson1PutRetentionSettingsCommand =
  exports.serializeAws_restJson1PutEventsConfigurationCommand =
  exports.serializeAws_restJson1PutAppInstanceStreamingConfigurationsCommand =
  exports.serializeAws_restJson1PutAppInstanceRetentionSettingsCommand =
  exports.serializeAws_restJson1LogoutUserCommand =
  exports.serializeAws_restJson1ListVoiceConnectorTerminationCredentialsCommand =
  exports.serializeAws_restJson1ListVoiceConnectorsCommand =
  exports.serializeAws_restJson1ListVoiceConnectorGroupsCommand =
  exports.serializeAws_restJson1ListUsersCommand =
  exports.serializeAws_restJson1ListTagsForResourceCommand =
  exports.serializeAws_restJson1ListSupportedPhoneNumberCountriesCommand =
  exports.serializeAws_restJson1ListSipRulesCommand =
  exports.serializeAws_restJson1ListSipMediaApplicationsCommand =
  exports.serializeAws_restJson1ListRoomsCommand =
  exports.serializeAws_restJson1ListRoomMembershipsCommand =
  exports.serializeAws_restJson1ListProxySessionsCommand =
  exports.serializeAws_restJson1ListPhoneNumbersCommand =
  exports.serializeAws_restJson1ListPhoneNumberOrdersCommand =
  exports.serializeAws_restJson1ListMeetingTagsCommand =
  exports.serializeAws_restJson1ListMeetingsCommand =
  exports.serializeAws_restJson1ListChannelsModeratedByAppInstanceUserCommand =
  exports.serializeAws_restJson1ListChannelsCommand =
  exports.serializeAws_restJson1ListChannelModeratorsCommand =
  exports.serializeAws_restJson1ListChannelMessagesCommand =
  exports.serializeAws_restJson1ListChannelMembershipsForAppInstanceUserCommand =
  exports.serializeAws_restJson1ListChannelMembershipsCommand =
  exports.serializeAws_restJson1ListChannelBansCommand =
  exports.serializeAws_restJson1ListBotsCommand =
  exports.serializeAws_restJson1ListAttendeeTagsCommand =
  exports.serializeAws_restJson1ListAttendeesCommand =
  exports.serializeAws_restJson1ListAppInstanceUsersCommand =
  exports.serializeAws_restJson1ListAppInstancesCommand =
  exports.serializeAws_restJson1ListAppInstanceAdminsCommand =
  exports.serializeAws_restJson1ListAccountsCommand =
  exports.serializeAws_restJson1InviteUsersCommand =
  exports.serializeAws_restJson1GetVoiceConnectorTerminationHealthCommand =
  exports.serializeAws_restJson1GetVoiceConnectorTerminationCommand =
  exports.serializeAws_restJson1GetVoiceConnectorStreamingConfigurationCommand =
  exports.serializeAws_restJson1GetVoiceConnectorProxyCommand =
  exports.serializeAws_restJson1GetVoiceConnectorOriginationCommand =
  exports.serializeAws_restJson1GetVoiceConnectorLoggingConfigurationCommand =
    void 0;
exports.deserializeAws_restJson1CreateAttendeeCommand =
  exports.deserializeAws_restJson1CreateAppInstanceUserCommand =
  exports.deserializeAws_restJson1CreateAppInstanceAdminCommand =
  exports.deserializeAws_restJson1CreateAppInstanceCommand =
  exports.deserializeAws_restJson1CreateAccountCommand =
  exports.deserializeAws_restJson1BatchUpdateUserCommand =
  exports.deserializeAws_restJson1BatchUpdatePhoneNumberCommand =
  exports.deserializeAws_restJson1BatchUnsuspendUserCommand =
  exports.deserializeAws_restJson1BatchSuspendUserCommand =
  exports.deserializeAws_restJson1BatchDeletePhoneNumberCommand =
  exports.deserializeAws_restJson1BatchCreateRoomMembershipCommand =
  exports.deserializeAws_restJson1BatchCreateChannelMembershipCommand =
  exports.deserializeAws_restJson1BatchCreateAttendeeCommand =
  exports.deserializeAws_restJson1AssociateSigninDelegateGroupsWithAccountCommand =
  exports.deserializeAws_restJson1AssociatePhoneNumberWithUserCommand =
  exports.deserializeAws_restJson1AssociatePhoneNumbersWithVoiceConnectorGroupCommand =
  exports.deserializeAws_restJson1AssociatePhoneNumbersWithVoiceConnectorCommand =
  exports.serializeAws_restJson1UpdateVoiceConnectorGroupCommand =
  exports.serializeAws_restJson1UpdateVoiceConnectorCommand =
  exports.serializeAws_restJson1UpdateUserSettingsCommand =
  exports.serializeAws_restJson1UpdateUserCommand =
  exports.serializeAws_restJson1UpdateSipRuleCommand =
  exports.serializeAws_restJson1UpdateSipMediaApplicationCommand =
  exports.serializeAws_restJson1UpdateRoomMembershipCommand =
  exports.serializeAws_restJson1UpdateRoomCommand =
  exports.serializeAws_restJson1UpdateProxySessionCommand =
  exports.serializeAws_restJson1UpdatePhoneNumberSettingsCommand =
  exports.serializeAws_restJson1UpdatePhoneNumberCommand =
  exports.serializeAws_restJson1UpdateGlobalSettingsCommand =
  exports.serializeAws_restJson1UpdateChannelReadMarkerCommand =
  exports.serializeAws_restJson1UpdateChannelMessageCommand =
  exports.serializeAws_restJson1UpdateChannelCommand =
  exports.serializeAws_restJson1UpdateBotCommand =
  exports.serializeAws_restJson1UpdateAppInstanceUserCommand =
  exports.serializeAws_restJson1UpdateAppInstanceCommand =
  exports.serializeAws_restJson1UpdateAccountSettingsCommand =
  exports.serializeAws_restJson1UpdateAccountCommand =
  exports.serializeAws_restJson1UntagResourceCommand =
  exports.serializeAws_restJson1UntagMeetingCommand =
  exports.serializeAws_restJson1UntagAttendeeCommand =
  exports.serializeAws_restJson1TagResourceCommand =
  exports.serializeAws_restJson1TagMeetingCommand =
  exports.serializeAws_restJson1TagAttendeeCommand =
  exports.serializeAws_restJson1SendChannelMessageCommand =
  exports.serializeAws_restJson1SearchAvailablePhoneNumbersCommand =
  exports.serializeAws_restJson1RestorePhoneNumberCommand =
  exports.serializeAws_restJson1ResetPersonalPINCommand =
  exports.serializeAws_restJson1RegenerateSecurityTokenCommand =
  exports.serializeAws_restJson1RedactRoomMessageCommand =
  exports.serializeAws_restJson1RedactConversationMessageCommand =
    void 0;
exports.deserializeAws_restJson1DescribeChannelBanCommand =
  exports.deserializeAws_restJson1DescribeChannelCommand =
  exports.deserializeAws_restJson1DescribeAppInstanceUserCommand =
  exports.deserializeAws_restJson1DescribeAppInstanceAdminCommand =
  exports.deserializeAws_restJson1DescribeAppInstanceCommand =
  exports.deserializeAws_restJson1DeleteVoiceConnectorTerminationCredentialsCommand =
  exports.deserializeAws_restJson1DeleteVoiceConnectorTerminationCommand =
  exports.deserializeAws_restJson1DeleteVoiceConnectorStreamingConfigurationCommand =
  exports.deserializeAws_restJson1DeleteVoiceConnectorProxyCommand =
  exports.deserializeAws_restJson1DeleteVoiceConnectorOriginationCommand =
  exports.deserializeAws_restJson1DeleteVoiceConnectorGroupCommand =
  exports.deserializeAws_restJson1DeleteVoiceConnectorEmergencyCallingConfigurationCommand =
  exports.deserializeAws_restJson1DeleteVoiceConnectorCommand =
  exports.deserializeAws_restJson1DeleteSipRuleCommand =
  exports.deserializeAws_restJson1DeleteSipMediaApplicationCommand =
  exports.deserializeAws_restJson1DeleteRoomMembershipCommand =
  exports.deserializeAws_restJson1DeleteRoomCommand =
  exports.deserializeAws_restJson1DeleteProxySessionCommand =
  exports.deserializeAws_restJson1DeletePhoneNumberCommand =
  exports.deserializeAws_restJson1DeleteMeetingCommand =
  exports.deserializeAws_restJson1DeleteEventsConfigurationCommand =
  exports.deserializeAws_restJson1DeleteChannelModeratorCommand =
  exports.deserializeAws_restJson1DeleteChannelMessageCommand =
  exports.deserializeAws_restJson1DeleteChannelMembershipCommand =
  exports.deserializeAws_restJson1DeleteChannelBanCommand =
  exports.deserializeAws_restJson1DeleteChannelCommand =
  exports.deserializeAws_restJson1DeleteAttendeeCommand =
  exports.deserializeAws_restJson1DeleteAppInstanceUserCommand =
  exports.deserializeAws_restJson1DeleteAppInstanceStreamingConfigurationsCommand =
  exports.deserializeAws_restJson1DeleteAppInstanceAdminCommand =
  exports.deserializeAws_restJson1DeleteAppInstanceCommand =
  exports.deserializeAws_restJson1DeleteAccountCommand =
  exports.deserializeAws_restJson1CreateVoiceConnectorGroupCommand =
  exports.deserializeAws_restJson1CreateVoiceConnectorCommand =
  exports.deserializeAws_restJson1CreateUserCommand =
  exports.deserializeAws_restJson1CreateSipRuleCommand =
  exports.deserializeAws_restJson1CreateSipMediaApplicationCallCommand =
  exports.deserializeAws_restJson1CreateSipMediaApplicationCommand =
  exports.deserializeAws_restJson1CreateRoomMembershipCommand =
  exports.deserializeAws_restJson1CreateRoomCommand =
  exports.deserializeAws_restJson1CreateProxySessionCommand =
  exports.deserializeAws_restJson1CreatePhoneNumberOrderCommand =
  exports.deserializeAws_restJson1CreateMeetingWithAttendeesCommand =
  exports.deserializeAws_restJson1CreateMeetingDialOutCommand =
  exports.deserializeAws_restJson1CreateMeetingCommand =
  exports.deserializeAws_restJson1CreateChannelModeratorCommand =
  exports.deserializeAws_restJson1CreateChannelMembershipCommand =
  exports.deserializeAws_restJson1CreateChannelBanCommand =
  exports.deserializeAws_restJson1CreateChannelCommand =
  exports.deserializeAws_restJson1CreateBotCommand =
    void 0;
exports.deserializeAws_restJson1ListChannelMembershipsForAppInstanceUserCommand =
  exports.deserializeAws_restJson1ListChannelMembershipsCommand =
  exports.deserializeAws_restJson1ListChannelBansCommand =
  exports.deserializeAws_restJson1ListBotsCommand =
  exports.deserializeAws_restJson1ListAttendeeTagsCommand =
  exports.deserializeAws_restJson1ListAttendeesCommand =
  exports.deserializeAws_restJson1ListAppInstanceUsersCommand =
  exports.deserializeAws_restJson1ListAppInstancesCommand =
  exports.deserializeAws_restJson1ListAppInstanceAdminsCommand =
  exports.deserializeAws_restJson1ListAccountsCommand =
  exports.deserializeAws_restJson1InviteUsersCommand =
  exports.deserializeAws_restJson1GetVoiceConnectorTerminationHealthCommand =
  exports.deserializeAws_restJson1GetVoiceConnectorTerminationCommand =
  exports.deserializeAws_restJson1GetVoiceConnectorStreamingConfigurationCommand =
  exports.deserializeAws_restJson1GetVoiceConnectorProxyCommand =
  exports.deserializeAws_restJson1GetVoiceConnectorOriginationCommand =
  exports.deserializeAws_restJson1GetVoiceConnectorLoggingConfigurationCommand =
  exports.deserializeAws_restJson1GetVoiceConnectorGroupCommand =
  exports.deserializeAws_restJson1GetVoiceConnectorEmergencyCallingConfigurationCommand =
  exports.deserializeAws_restJson1GetVoiceConnectorCommand =
  exports.deserializeAws_restJson1GetUserSettingsCommand =
  exports.deserializeAws_restJson1GetUserCommand =
  exports.deserializeAws_restJson1GetSipRuleCommand =
  exports.deserializeAws_restJson1GetSipMediaApplicationLoggingConfigurationCommand =
  exports.deserializeAws_restJson1GetSipMediaApplicationCommand =
  exports.deserializeAws_restJson1GetRoomCommand =
  exports.deserializeAws_restJson1GetRetentionSettingsCommand =
  exports.deserializeAws_restJson1GetProxySessionCommand =
  exports.deserializeAws_restJson1GetPhoneNumberSettingsCommand =
  exports.deserializeAws_restJson1GetPhoneNumberOrderCommand =
  exports.deserializeAws_restJson1GetPhoneNumberCommand =
  exports.deserializeAws_restJson1GetMessagingSessionEndpointCommand =
  exports.deserializeAws_restJson1GetMeetingCommand =
  exports.deserializeAws_restJson1GetGlobalSettingsCommand =
  exports.deserializeAws_restJson1GetEventsConfigurationCommand =
  exports.deserializeAws_restJson1GetChannelMessageCommand =
  exports.deserializeAws_restJson1GetBotCommand =
  exports.deserializeAws_restJson1GetAttendeeCommand =
  exports.deserializeAws_restJson1GetAppInstanceStreamingConfigurationsCommand =
  exports.deserializeAws_restJson1GetAppInstanceRetentionSettingsCommand =
  exports.deserializeAws_restJson1GetAccountSettingsCommand =
  exports.deserializeAws_restJson1GetAccountCommand =
  exports.deserializeAws_restJson1DisassociateSigninDelegateGroupsFromAccountCommand =
  exports.deserializeAws_restJson1DisassociatePhoneNumbersFromVoiceConnectorGroupCommand =
  exports.deserializeAws_restJson1DisassociatePhoneNumbersFromVoiceConnectorCommand =
  exports.deserializeAws_restJson1DisassociatePhoneNumberFromUserCommand =
  exports.deserializeAws_restJson1DescribeChannelModeratorCommand =
  exports.deserializeAws_restJson1DescribeChannelModeratedByAppInstanceUserCommand =
  exports.deserializeAws_restJson1DescribeChannelMembershipForAppInstanceUserCommand =
  exports.deserializeAws_restJson1DescribeChannelMembershipCommand =
    void 0;
exports.deserializeAws_restJson1UpdateAppInstanceUserCommand =
  exports.deserializeAws_restJson1UpdateAppInstanceCommand =
  exports.deserializeAws_restJson1UpdateAccountSettingsCommand =
  exports.deserializeAws_restJson1UpdateAccountCommand =
  exports.deserializeAws_restJson1UntagResourceCommand =
  exports.deserializeAws_restJson1UntagMeetingCommand =
  exports.deserializeAws_restJson1UntagAttendeeCommand =
  exports.deserializeAws_restJson1TagResourceCommand =
  exports.deserializeAws_restJson1TagMeetingCommand =
  exports.deserializeAws_restJson1TagAttendeeCommand =
  exports.deserializeAws_restJson1SendChannelMessageCommand =
  exports.deserializeAws_restJson1SearchAvailablePhoneNumbersCommand =
  exports.deserializeAws_restJson1RestorePhoneNumberCommand =
  exports.deserializeAws_restJson1ResetPersonalPINCommand =
  exports.deserializeAws_restJson1RegenerateSecurityTokenCommand =
  exports.deserializeAws_restJson1RedactRoomMessageCommand =
  exports.deserializeAws_restJson1RedactConversationMessageCommand =
  exports.deserializeAws_restJson1RedactChannelMessageCommand =
  exports.deserializeAws_restJson1PutVoiceConnectorTerminationCredentialsCommand =
  exports.deserializeAws_restJson1PutVoiceConnectorTerminationCommand =
  exports.deserializeAws_restJson1PutVoiceConnectorStreamingConfigurationCommand =
  exports.deserializeAws_restJson1PutVoiceConnectorProxyCommand =
  exports.deserializeAws_restJson1PutVoiceConnectorOriginationCommand =
  exports.deserializeAws_restJson1PutVoiceConnectorLoggingConfigurationCommand =
  exports.deserializeAws_restJson1PutVoiceConnectorEmergencyCallingConfigurationCommand =
  exports.deserializeAws_restJson1PutSipMediaApplicationLoggingConfigurationCommand =
  exports.deserializeAws_restJson1PutRetentionSettingsCommand =
  exports.deserializeAws_restJson1PutEventsConfigurationCommand =
  exports.deserializeAws_restJson1PutAppInstanceStreamingConfigurationsCommand =
  exports.deserializeAws_restJson1PutAppInstanceRetentionSettingsCommand =
  exports.deserializeAws_restJson1LogoutUserCommand =
  exports.deserializeAws_restJson1ListVoiceConnectorTerminationCredentialsCommand =
  exports.deserializeAws_restJson1ListVoiceConnectorsCommand =
  exports.deserializeAws_restJson1ListVoiceConnectorGroupsCommand =
  exports.deserializeAws_restJson1ListUsersCommand =
  exports.deserializeAws_restJson1ListTagsForResourceCommand =
  exports.deserializeAws_restJson1ListSupportedPhoneNumberCountriesCommand =
  exports.deserializeAws_restJson1ListSipRulesCommand =
  exports.deserializeAws_restJson1ListSipMediaApplicationsCommand =
  exports.deserializeAws_restJson1ListRoomsCommand =
  exports.deserializeAws_restJson1ListRoomMembershipsCommand =
  exports.deserializeAws_restJson1ListProxySessionsCommand =
  exports.deserializeAws_restJson1ListPhoneNumbersCommand =
  exports.deserializeAws_restJson1ListPhoneNumberOrdersCommand =
  exports.deserializeAws_restJson1ListMeetingTagsCommand =
  exports.deserializeAws_restJson1ListMeetingsCommand =
  exports.deserializeAws_restJson1ListChannelsModeratedByAppInstanceUserCommand =
  exports.deserializeAws_restJson1ListChannelsCommand =
  exports.deserializeAws_restJson1ListChannelModeratorsCommand =
  exports.deserializeAws_restJson1ListChannelMessagesCommand =
    void 0;
exports.deserializeAws_restJson1UpdateVoiceConnectorGroupCommand =
  exports.deserializeAws_restJson1UpdateVoiceConnectorCommand =
  exports.deserializeAws_restJson1UpdateUserSettingsCommand =
  exports.deserializeAws_restJson1UpdateUserCommand =
  exports.deserializeAws_restJson1UpdateSipRuleCommand =
  exports.deserializeAws_restJson1UpdateSipMediaApplicationCommand =
  exports.deserializeAws_restJson1UpdateRoomMembershipCommand =
  exports.deserializeAws_restJson1UpdateRoomCommand =
  exports.deserializeAws_restJson1UpdateProxySessionCommand =
  exports.deserializeAws_restJson1UpdatePhoneNumberSettingsCommand =
  exports.deserializeAws_restJson1UpdatePhoneNumberCommand =
  exports.deserializeAws_restJson1UpdateGlobalSettingsCommand =
  exports.deserializeAws_restJson1UpdateChannelReadMarkerCommand =
  exports.deserializeAws_restJson1UpdateChannelMessageCommand =
  exports.deserializeAws_restJson1UpdateChannelCommand =
  exports.deserializeAws_restJson1UpdateBotCommand =
    void 0;
const protocol_http_1 = require("@aws-sdk/protocol-http");
const smithy_client_1 = require("@aws-sdk/smithy-client");
const uuid_1 = require("uuid");
const serializeAws_restJson1AssociatePhoneNumbersWithVoiceConnectorCommand = async (input, context) => {
  const headers = {
    "content-type": "application/json",
  };
  let resolvedPath = "/voice-connectors/{VoiceConnectorId}";
  if (input.VoiceConnectorId !== undefined) {
    const labelValue = input.VoiceConnectorId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: VoiceConnectorId.");
    }
    resolvedPath = resolvedPath.replace("{VoiceConnectorId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: VoiceConnectorId.");
  }
  const query = {
    operation: "associate-phone-numbers",
  };
  let body;
  body = JSON.stringify({
    ...(input.E164PhoneNumbers !== undefined &&
      input.E164PhoneNumbers !== null && {
        E164PhoneNumbers: serializeAws_restJson1E164PhoneNumberList(input.E164PhoneNumbers, context),
      }),
    ...(input.ForceAssociate !== undefined &&
      input.ForceAssociate !== null && { ForceAssociate: input.ForceAssociate }),
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};
exports.serializeAws_restJson1AssociatePhoneNumbersWithVoiceConnectorCommand =
  serializeAws_restJson1AssociatePhoneNumbersWithVoiceConnectorCommand;
const serializeAws_restJson1AssociatePhoneNumbersWithVoiceConnectorGroupCommand = async (input, context) => {
  const headers = {
    "content-type": "application/json",
  };
  let resolvedPath = "/voice-connector-groups/{VoiceConnectorGroupId}";
  if (input.VoiceConnectorGroupId !== undefined) {
    const labelValue = input.VoiceConnectorGroupId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: VoiceConnectorGroupId.");
    }
    resolvedPath = resolvedPath.replace(
      "{VoiceConnectorGroupId}",
      smithy_client_1.extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: VoiceConnectorGroupId.");
  }
  const query = {
    operation: "associate-phone-numbers",
  };
  let body;
  body = JSON.stringify({
    ...(input.E164PhoneNumbers !== undefined &&
      input.E164PhoneNumbers !== null && {
        E164PhoneNumbers: serializeAws_restJson1E164PhoneNumberList(input.E164PhoneNumbers, context),
      }),
    ...(input.ForceAssociate !== undefined &&
      input.ForceAssociate !== null && { ForceAssociate: input.ForceAssociate }),
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};
exports.serializeAws_restJson1AssociatePhoneNumbersWithVoiceConnectorGroupCommand =
  serializeAws_restJson1AssociatePhoneNumbersWithVoiceConnectorGroupCommand;
const serializeAws_restJson1AssociatePhoneNumberWithUserCommand = async (input, context) => {
  const headers = {
    "content-type": "application/json",
  };
  let resolvedPath = "/accounts/{AccountId}/users/{UserId}";
  if (input.AccountId !== undefined) {
    const labelValue = input.AccountId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AccountId.");
    }
    resolvedPath = resolvedPath.replace("{AccountId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: AccountId.");
  }
  if (input.UserId !== undefined) {
    const labelValue = input.UserId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: UserId.");
    }
    resolvedPath = resolvedPath.replace("{UserId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: UserId.");
  }
  const query = {
    operation: "associate-phone-number",
  };
  let body;
  body = JSON.stringify({
    ...(input.E164PhoneNumber !== undefined &&
      input.E164PhoneNumber !== null && { E164PhoneNumber: input.E164PhoneNumber }),
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};
exports.serializeAws_restJson1AssociatePhoneNumberWithUserCommand =
  serializeAws_restJson1AssociatePhoneNumberWithUserCommand;
const serializeAws_restJson1AssociateSigninDelegateGroupsWithAccountCommand = async (input, context) => {
  const headers = {
    "content-type": "application/json",
  };
  let resolvedPath = "/accounts/{AccountId}";
  if (input.AccountId !== undefined) {
    const labelValue = input.AccountId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AccountId.");
    }
    resolvedPath = resolvedPath.replace("{AccountId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: AccountId.");
  }
  const query = {
    operation: "associate-signin-delegate-groups",
  };
  let body;
  body = JSON.stringify({
    ...(input.SigninDelegateGroups !== undefined &&
      input.SigninDelegateGroups !== null && {
        SigninDelegateGroups: serializeAws_restJson1SigninDelegateGroupList(input.SigninDelegateGroups, context),
      }),
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};
exports.serializeAws_restJson1AssociateSigninDelegateGroupsWithAccountCommand =
  serializeAws_restJson1AssociateSigninDelegateGroupsWithAccountCommand;
const serializeAws_restJson1BatchCreateAttendeeCommand = async (input, context) => {
  const headers = {
    "content-type": "application/json",
  };
  let resolvedPath = "/meetings/{MeetingId}/attendees";
  if (input.MeetingId !== undefined) {
    const labelValue = input.MeetingId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: MeetingId.");
    }
    resolvedPath = resolvedPath.replace("{MeetingId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: MeetingId.");
  }
  const query = {
    operation: "batch-create",
  };
  let body;
  body = JSON.stringify({
    ...(input.Attendees !== undefined &&
      input.Attendees !== null && {
        Attendees: serializeAws_restJson1CreateAttendeeRequestItemList(input.Attendees, context),
      }),
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};
exports.serializeAws_restJson1BatchCreateAttendeeCommand = serializeAws_restJson1BatchCreateAttendeeCommand;
const serializeAws_restJson1BatchCreateChannelMembershipCommand = async (input, context) => {
  const headers = {
    "content-type": "application/json",
    ...(isSerializableHeaderValue(input.ChimeBearer) && { "x-amz-chime-bearer": input.ChimeBearer }),
  };
  let resolvedPath = "/channels/{ChannelArn}/memberships";
  if (input.ChannelArn !== undefined) {
    const labelValue = input.ChannelArn;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: ChannelArn.");
    }
    resolvedPath = resolvedPath.replace("{ChannelArn}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: ChannelArn.");
  }
  const query = {
    operation: "batch-create",
  };
  let body;
  body = JSON.stringify({
    ...(input.MemberArns !== undefined &&
      input.MemberArns !== null && { MemberArns: serializeAws_restJson1MemberArns(input.MemberArns, context) }),
    ...(input.Type !== undefined && input.Type !== null && { Type: input.Type }),
  });
  let { hostname: resolvedHostname } = await context.endpoint();
  if (context.disableHostPrefix !== true) {
    resolvedHostname = "messaging-" + resolvedHostname;
    if (!protocol_http_1.isValidHostname(resolvedHostname)) {
      throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
    }
  }
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname: resolvedHostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};
exports.serializeAws_restJson1BatchCreateChannelMembershipCommand =
  serializeAws_restJson1BatchCreateChannelMembershipCommand;
const serializeAws_restJson1BatchCreateRoomMembershipCommand = async (input, context) => {
  const headers = {
    "content-type": "application/json",
  };
  let resolvedPath = "/accounts/{AccountId}/rooms/{RoomId}/memberships";
  if (input.AccountId !== undefined) {
    const labelValue = input.AccountId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AccountId.");
    }
    resolvedPath = resolvedPath.replace("{AccountId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: AccountId.");
  }
  if (input.RoomId !== undefined) {
    const labelValue = input.RoomId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: RoomId.");
    }
    resolvedPath = resolvedPath.replace("{RoomId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: RoomId.");
  }
  const query = {
    operation: "batch-create",
  };
  let body;
  body = JSON.stringify({
    ...(input.MembershipItemList !== undefined &&
      input.MembershipItemList !== null && {
        MembershipItemList: serializeAws_restJson1MembershipItemList(input.MembershipItemList, context),
      }),
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};
exports.serializeAws_restJson1BatchCreateRoomMembershipCommand = serializeAws_restJson1BatchCreateRoomMembershipCommand;
const serializeAws_restJson1BatchDeletePhoneNumberCommand = async (input, context) => {
  const headers = {
    "content-type": "application/json",
  };
  let resolvedPath = "/phone-numbers";
  const query = {
    operation: "batch-delete",
  };
  let body;
  body = JSON.stringify({
    ...(input.PhoneNumberIds !== undefined &&
      input.PhoneNumberIds !== null && {
        PhoneNumberIds: serializeAws_restJson1NonEmptyStringList(input.PhoneNumberIds, context),
      }),
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};
exports.serializeAws_restJson1BatchDeletePhoneNumberCommand = serializeAws_restJson1BatchDeletePhoneNumberCommand;
const serializeAws_restJson1BatchSuspendUserCommand = async (input, context) => {
  const headers = {
    "content-type": "application/json",
  };
  let resolvedPath = "/accounts/{AccountId}/users";
  if (input.AccountId !== undefined) {
    const labelValue = input.AccountId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AccountId.");
    }
    resolvedPath = resolvedPath.replace("{AccountId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: AccountId.");
  }
  const query = {
    operation: "suspend",
  };
  let body;
  body = JSON.stringify({
    ...(input.UserIdList !== undefined &&
      input.UserIdList !== null && { UserIdList: serializeAws_restJson1UserIdList(input.UserIdList, context) }),
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};
exports.serializeAws_restJson1BatchSuspendUserCommand = serializeAws_restJson1BatchSuspendUserCommand;
const serializeAws_restJson1BatchUnsuspendUserCommand = async (input, context) => {
  const headers = {
    "content-type": "application/json",
  };
  let resolvedPath = "/accounts/{AccountId}/users";
  if (input.AccountId !== undefined) {
    const labelValue = input.AccountId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AccountId.");
    }
    resolvedPath = resolvedPath.replace("{AccountId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: AccountId.");
  }
  const query = {
    operation: "unsuspend",
  };
  let body;
  body = JSON.stringify({
    ...(input.UserIdList !== undefined &&
      input.UserIdList !== null && { UserIdList: serializeAws_restJson1UserIdList(input.UserIdList, context) }),
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};
exports.serializeAws_restJson1BatchUnsuspendUserCommand = serializeAws_restJson1BatchUnsuspendUserCommand;
const serializeAws_restJson1BatchUpdatePhoneNumberCommand = async (input, context) => {
  const headers = {
    "content-type": "application/json",
  };
  let resolvedPath = "/phone-numbers";
  const query = {
    operation: "batch-update",
  };
  let body;
  body = JSON.stringify({
    ...(input.UpdatePhoneNumberRequestItems !== undefined &&
      input.UpdatePhoneNumberRequestItems !== null && {
        UpdatePhoneNumberRequestItems: serializeAws_restJson1UpdatePhoneNumberRequestItemList(
          input.UpdatePhoneNumberRequestItems,
          context
        ),
      }),
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};
exports.serializeAws_restJson1BatchUpdatePhoneNumberCommand = serializeAws_restJson1BatchUpdatePhoneNumberCommand;
const serializeAws_restJson1BatchUpdateUserCommand = async (input, context) => {
  const headers = {
    "content-type": "application/json",
  };
  let resolvedPath = "/accounts/{AccountId}/users";
  if (input.AccountId !== undefined) {
    const labelValue = input.AccountId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AccountId.");
    }
    resolvedPath = resolvedPath.replace("{AccountId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: AccountId.");
  }
  let body;
  body = JSON.stringify({
    ...(input.UpdateUserRequestItems !== undefined &&
      input.UpdateUserRequestItems !== null && {
        UpdateUserRequestItems: serializeAws_restJson1UpdateUserRequestItemList(input.UpdateUserRequestItems, context),
      }),
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1BatchUpdateUserCommand = serializeAws_restJson1BatchUpdateUserCommand;
const serializeAws_restJson1CreateAccountCommand = async (input, context) => {
  const headers = {
    "content-type": "application/json",
  };
  let resolvedPath = "/accounts";
  let body;
  body = JSON.stringify({
    ...(input.Name !== undefined && input.Name !== null && { Name: input.Name }),
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1CreateAccountCommand = serializeAws_restJson1CreateAccountCommand;
const serializeAws_restJson1CreateAppInstanceCommand = async (input, context) => {
  var _a;
  const headers = {
    "content-type": "application/json",
  };
  let resolvedPath = "/app-instances";
  let body;
  body = JSON.stringify({
    ClientRequestToken: (_a = input.ClientRequestToken) !== null && _a !== void 0 ? _a : uuid_1.v4(),
    ...(input.Metadata !== undefined && input.Metadata !== null && { Metadata: input.Metadata }),
    ...(input.Name !== undefined && input.Name !== null && { Name: input.Name }),
    ...(input.Tags !== undefined &&
      input.Tags !== null && { Tags: serializeAws_restJson1TagList(input.Tags, context) }),
  });
  let { hostname: resolvedHostname } = await context.endpoint();
  if (context.disableHostPrefix !== true) {
    resolvedHostname = "identity-" + resolvedHostname;
    if (!protocol_http_1.isValidHostname(resolvedHostname)) {
      throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
    }
  }
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname: resolvedHostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1CreateAppInstanceCommand = serializeAws_restJson1CreateAppInstanceCommand;
const serializeAws_restJson1CreateAppInstanceAdminCommand = async (input, context) => {
  const headers = {
    "content-type": "application/json",
  };
  let resolvedPath = "/app-instances/{AppInstanceArn}/admins";
  if (input.AppInstanceArn !== undefined) {
    const labelValue = input.AppInstanceArn;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AppInstanceArn.");
    }
    resolvedPath = resolvedPath.replace("{AppInstanceArn}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: AppInstanceArn.");
  }
  let body;
  body = JSON.stringify({
    ...(input.AppInstanceAdminArn !== undefined &&
      input.AppInstanceAdminArn !== null && { AppInstanceAdminArn: input.AppInstanceAdminArn }),
  });
  let { hostname: resolvedHostname } = await context.endpoint();
  if (context.disableHostPrefix !== true) {
    resolvedHostname = "identity-" + resolvedHostname;
    if (!protocol_http_1.isValidHostname(resolvedHostname)) {
      throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
    }
  }
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname: resolvedHostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1CreateAppInstanceAdminCommand = serializeAws_restJson1CreateAppInstanceAdminCommand;
const serializeAws_restJson1CreateAppInstanceUserCommand = async (input, context) => {
  var _a;
  const headers = {
    "content-type": "application/json",
  };
  let resolvedPath = "/app-instance-users";
  let body;
  body = JSON.stringify({
    ...(input.AppInstanceArn !== undefined &&
      input.AppInstanceArn !== null && { AppInstanceArn: input.AppInstanceArn }),
    ...(input.AppInstanceUserId !== undefined &&
      input.AppInstanceUserId !== null && { AppInstanceUserId: input.AppInstanceUserId }),
    ClientRequestToken: (_a = input.ClientRequestToken) !== null && _a !== void 0 ? _a : uuid_1.v4(),
    ...(input.Metadata !== undefined && input.Metadata !== null && { Metadata: input.Metadata }),
    ...(input.Name !== undefined && input.Name !== null && { Name: input.Name }),
    ...(input.Tags !== undefined &&
      input.Tags !== null && { Tags: serializeAws_restJson1TagList(input.Tags, context) }),
  });
  let { hostname: resolvedHostname } = await context.endpoint();
  if (context.disableHostPrefix !== true) {
    resolvedHostname = "identity-" + resolvedHostname;
    if (!protocol_http_1.isValidHostname(resolvedHostname)) {
      throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
    }
  }
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname: resolvedHostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1CreateAppInstanceUserCommand = serializeAws_restJson1CreateAppInstanceUserCommand;
const serializeAws_restJson1CreateAttendeeCommand = async (input, context) => {
  const headers = {
    "content-type": "application/json",
  };
  let resolvedPath = "/meetings/{MeetingId}/attendees";
  if (input.MeetingId !== undefined) {
    const labelValue = input.MeetingId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: MeetingId.");
    }
    resolvedPath = resolvedPath.replace("{MeetingId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: MeetingId.");
  }
  let body;
  body = JSON.stringify({
    ...(input.ExternalUserId !== undefined &&
      input.ExternalUserId !== null && { ExternalUserId: input.ExternalUserId }),
    ...(input.Tags !== undefined &&
      input.Tags !== null && { Tags: serializeAws_restJson1AttendeeTagList(input.Tags, context) }),
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1CreateAttendeeCommand = serializeAws_restJson1CreateAttendeeCommand;
const serializeAws_restJson1CreateBotCommand = async (input, context) => {
  const headers = {
    "content-type": "application/json",
  };
  let resolvedPath = "/accounts/{AccountId}/bots";
  if (input.AccountId !== undefined) {
    const labelValue = input.AccountId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AccountId.");
    }
    resolvedPath = resolvedPath.replace("{AccountId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: AccountId.");
  }
  let body;
  body = JSON.stringify({
    ...(input.DisplayName !== undefined && input.DisplayName !== null && { DisplayName: input.DisplayName }),
    ...(input.Domain !== undefined && input.Domain !== null && { Domain: input.Domain }),
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1CreateBotCommand = serializeAws_restJson1CreateBotCommand;
const serializeAws_restJson1CreateChannelCommand = async (input, context) => {
  var _a;
  const headers = {
    "content-type": "application/json",
    ...(isSerializableHeaderValue(input.ChimeBearer) && { "x-amz-chime-bearer": input.ChimeBearer }),
  };
  let resolvedPath = "/channels";
  let body;
  body = JSON.stringify({
    ...(input.AppInstanceArn !== undefined &&
      input.AppInstanceArn !== null && { AppInstanceArn: input.AppInstanceArn }),
    ClientRequestToken: (_a = input.ClientRequestToken) !== null && _a !== void 0 ? _a : uuid_1.v4(),
    ...(input.Metadata !== undefined && input.Metadata !== null && { Metadata: input.Metadata }),
    ...(input.Mode !== undefined && input.Mode !== null && { Mode: input.Mode }),
    ...(input.Name !== undefined && input.Name !== null && { Name: input.Name }),
    ...(input.Privacy !== undefined && input.Privacy !== null && { Privacy: input.Privacy }),
    ...(input.Tags !== undefined &&
      input.Tags !== null && { Tags: serializeAws_restJson1TagList(input.Tags, context) }),
  });
  let { hostname: resolvedHostname } = await context.endpoint();
  if (context.disableHostPrefix !== true) {
    resolvedHostname = "messaging-" + resolvedHostname;
    if (!protocol_http_1.isValidHostname(resolvedHostname)) {
      throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
    }
  }
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname: resolvedHostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1CreateChannelCommand = serializeAws_restJson1CreateChannelCommand;
const serializeAws_restJson1CreateChannelBanCommand = async (input, context) => {
  const headers = {
    "content-type": "application/json",
    ...(isSerializableHeaderValue(input.ChimeBearer) && { "x-amz-chime-bearer": input.ChimeBearer }),
  };
  let resolvedPath = "/channels/{ChannelArn}/bans";
  if (input.ChannelArn !== undefined) {
    const labelValue = input.ChannelArn;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: ChannelArn.");
    }
    resolvedPath = resolvedPath.replace("{ChannelArn}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: ChannelArn.");
  }
  let body;
  body = JSON.stringify({
    ...(input.MemberArn !== undefined && input.MemberArn !== null && { MemberArn: input.MemberArn }),
  });
  let { hostname: resolvedHostname } = await context.endpoint();
  if (context.disableHostPrefix !== true) {
    resolvedHostname = "messaging-" + resolvedHostname;
    if (!protocol_http_1.isValidHostname(resolvedHostname)) {
      throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
    }
  }
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname: resolvedHostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1CreateChannelBanCommand = serializeAws_restJson1CreateChannelBanCommand;
const serializeAws_restJson1CreateChannelMembershipCommand = async (input, context) => {
  const headers = {
    "content-type": "application/json",
    ...(isSerializableHeaderValue(input.ChimeBearer) && { "x-amz-chime-bearer": input.ChimeBearer }),
  };
  let resolvedPath = "/channels/{ChannelArn}/memberships";
  if (input.ChannelArn !== undefined) {
    const labelValue = input.ChannelArn;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: ChannelArn.");
    }
    resolvedPath = resolvedPath.replace("{ChannelArn}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: ChannelArn.");
  }
  let body;
  body = JSON.stringify({
    ...(input.MemberArn !== undefined && input.MemberArn !== null && { MemberArn: input.MemberArn }),
    ...(input.Type !== undefined && input.Type !== null && { Type: input.Type }),
  });
  let { hostname: resolvedHostname } = await context.endpoint();
  if (context.disableHostPrefix !== true) {
    resolvedHostname = "messaging-" + resolvedHostname;
    if (!protocol_http_1.isValidHostname(resolvedHostname)) {
      throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
    }
  }
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname: resolvedHostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1CreateChannelMembershipCommand = serializeAws_restJson1CreateChannelMembershipCommand;
const serializeAws_restJson1CreateChannelModeratorCommand = async (input, context) => {
  const headers = {
    "content-type": "application/json",
    ...(isSerializableHeaderValue(input.ChimeBearer) && { "x-amz-chime-bearer": input.ChimeBearer }),
  };
  let resolvedPath = "/channels/{ChannelArn}/moderators";
  if (input.ChannelArn !== undefined) {
    const labelValue = input.ChannelArn;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: ChannelArn.");
    }
    resolvedPath = resolvedPath.replace("{ChannelArn}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: ChannelArn.");
  }
  let body;
  body = JSON.stringify({
    ...(input.ChannelModeratorArn !== undefined &&
      input.ChannelModeratorArn !== null && { ChannelModeratorArn: input.ChannelModeratorArn }),
  });
  let { hostname: resolvedHostname } = await context.endpoint();
  if (context.disableHostPrefix !== true) {
    resolvedHostname = "messaging-" + resolvedHostname;
    if (!protocol_http_1.isValidHostname(resolvedHostname)) {
      throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
    }
  }
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname: resolvedHostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1CreateChannelModeratorCommand = serializeAws_restJson1CreateChannelModeratorCommand;
const serializeAws_restJson1CreateMeetingCommand = async (input, context) => {
  var _a;
  const headers = {
    "content-type": "application/json",
  };
  let resolvedPath = "/meetings";
  let body;
  body = JSON.stringify({
    ClientRequestToken: (_a = input.ClientRequestToken) !== null && _a !== void 0 ? _a : uuid_1.v4(),
    ...(input.ExternalMeetingId !== undefined &&
      input.ExternalMeetingId !== null && { ExternalMeetingId: input.ExternalMeetingId }),
    ...(input.MediaRegion !== undefined && input.MediaRegion !== null && { MediaRegion: input.MediaRegion }),
    ...(input.MeetingHostId !== undefined && input.MeetingHostId !== null && { MeetingHostId: input.MeetingHostId }),
    ...(input.NotificationsConfiguration !== undefined &&
      input.NotificationsConfiguration !== null && {
        NotificationsConfiguration: serializeAws_restJson1MeetingNotificationConfiguration(
          input.NotificationsConfiguration,
          context
        ),
      }),
    ...(input.Tags !== undefined &&
      input.Tags !== null && { Tags: serializeAws_restJson1MeetingTagList(input.Tags, context) }),
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1CreateMeetingCommand = serializeAws_restJson1CreateMeetingCommand;
const serializeAws_restJson1CreateMeetingDialOutCommand = async (input, context) => {
  const headers = {
    "content-type": "application/json",
  };
  let resolvedPath = "/meetings/{MeetingId}/dial-outs";
  if (input.MeetingId !== undefined) {
    const labelValue = input.MeetingId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: MeetingId.");
    }
    resolvedPath = resolvedPath.replace("{MeetingId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: MeetingId.");
  }
  let body;
  body = JSON.stringify({
    ...(input.FromPhoneNumber !== undefined &&
      input.FromPhoneNumber !== null && { FromPhoneNumber: input.FromPhoneNumber }),
    ...(input.JoinToken !== undefined && input.JoinToken !== null && { JoinToken: input.JoinToken }),
    ...(input.ToPhoneNumber !== undefined && input.ToPhoneNumber !== null && { ToPhoneNumber: input.ToPhoneNumber }),
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1CreateMeetingDialOutCommand = serializeAws_restJson1CreateMeetingDialOutCommand;
const serializeAws_restJson1CreateMeetingWithAttendeesCommand = async (input, context) => {
  var _a;
  const headers = {
    "content-type": "application/json",
  };
  let resolvedPath = "/meetings";
  const query = {
    operation: "create-attendees",
  };
  let body;
  body = JSON.stringify({
    ...(input.Attendees !== undefined &&
      input.Attendees !== null && {
        Attendees: serializeAws_restJson1CreateMeetingWithAttendeesRequestItemList(input.Attendees, context),
      }),
    ClientRequestToken: (_a = input.ClientRequestToken) !== null && _a !== void 0 ? _a : uuid_1.v4(),
    ...(input.ExternalMeetingId !== undefined &&
      input.ExternalMeetingId !== null && { ExternalMeetingId: input.ExternalMeetingId }),
    ...(input.MediaRegion !== undefined && input.MediaRegion !== null && { MediaRegion: input.MediaRegion }),
    ...(input.MeetingHostId !== undefined && input.MeetingHostId !== null && { MeetingHostId: input.MeetingHostId }),
    ...(input.NotificationsConfiguration !== undefined &&
      input.NotificationsConfiguration !== null && {
        NotificationsConfiguration: serializeAws_restJson1MeetingNotificationConfiguration(
          input.NotificationsConfiguration,
          context
        ),
      }),
    ...(input.Tags !== undefined &&
      input.Tags !== null && { Tags: serializeAws_restJson1MeetingTagList(input.Tags, context) }),
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};
exports.serializeAws_restJson1CreateMeetingWithAttendeesCommand =
  serializeAws_restJson1CreateMeetingWithAttendeesCommand;
const serializeAws_restJson1CreatePhoneNumberOrderCommand = async (input, context) => {
  const headers = {
    "content-type": "application/json",
  };
  let resolvedPath = "/phone-number-orders";
  let body;
  body = JSON.stringify({
    ...(input.E164PhoneNumbers !== undefined &&
      input.E164PhoneNumbers !== null && {
        E164PhoneNumbers: serializeAws_restJson1E164PhoneNumberList(input.E164PhoneNumbers, context),
      }),
    ...(input.ProductType !== undefined && input.ProductType !== null && { ProductType: input.ProductType }),
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1CreatePhoneNumberOrderCommand = serializeAws_restJson1CreatePhoneNumberOrderCommand;
const serializeAws_restJson1CreateProxySessionCommand = async (input, context) => {
  const headers = {
    "content-type": "application/json",
  };
  let resolvedPath = "/voice-connectors/{VoiceConnectorId}/proxy-sessions";
  if (input.VoiceConnectorId !== undefined) {
    const labelValue = input.VoiceConnectorId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: VoiceConnectorId.");
    }
    resolvedPath = resolvedPath.replace("{VoiceConnectorId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: VoiceConnectorId.");
  }
  let body;
  body = JSON.stringify({
    ...(input.Capabilities !== undefined &&
      input.Capabilities !== null && {
        Capabilities: serializeAws_restJson1CapabilityList(input.Capabilities, context),
      }),
    ...(input.ExpiryMinutes !== undefined && input.ExpiryMinutes !== null && { ExpiryMinutes: input.ExpiryMinutes }),
    ...(input.GeoMatchLevel !== undefined && input.GeoMatchLevel !== null && { GeoMatchLevel: input.GeoMatchLevel }),
    ...(input.GeoMatchParams !== undefined &&
      input.GeoMatchParams !== null && {
        GeoMatchParams: serializeAws_restJson1GeoMatchParams(input.GeoMatchParams, context),
      }),
    ...(input.Name !== undefined && input.Name !== null && { Name: input.Name }),
    ...(input.NumberSelectionBehavior !== undefined &&
      input.NumberSelectionBehavior !== null && { NumberSelectionBehavior: input.NumberSelectionBehavior }),
    ...(input.ParticipantPhoneNumbers !== undefined &&
      input.ParticipantPhoneNumbers !== null && {
        ParticipantPhoneNumbers: serializeAws_restJson1ParticipantPhoneNumberList(
          input.ParticipantPhoneNumbers,
          context
        ),
      }),
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1CreateProxySessionCommand = serializeAws_restJson1CreateProxySessionCommand;
const serializeAws_restJson1CreateRoomCommand = async (input, context) => {
  var _a;
  const headers = {
    "content-type": "application/json",
  };
  let resolvedPath = "/accounts/{AccountId}/rooms";
  if (input.AccountId !== undefined) {
    const labelValue = input.AccountId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AccountId.");
    }
    resolvedPath = resolvedPath.replace("{AccountId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: AccountId.");
  }
  let body;
  body = JSON.stringify({
    ClientRequestToken: (_a = input.ClientRequestToken) !== null && _a !== void 0 ? _a : uuid_1.v4(),
    ...(input.Name !== undefined && input.Name !== null && { Name: input.Name }),
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1CreateRoomCommand = serializeAws_restJson1CreateRoomCommand;
const serializeAws_restJson1CreateRoomMembershipCommand = async (input, context) => {
  const headers = {
    "content-type": "application/json",
  };
  let resolvedPath = "/accounts/{AccountId}/rooms/{RoomId}/memberships";
  if (input.AccountId !== undefined) {
    const labelValue = input.AccountId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AccountId.");
    }
    resolvedPath = resolvedPath.replace("{AccountId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: AccountId.");
  }
  if (input.RoomId !== undefined) {
    const labelValue = input.RoomId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: RoomId.");
    }
    resolvedPath = resolvedPath.replace("{RoomId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: RoomId.");
  }
  let body;
  body = JSON.stringify({
    ...(input.MemberId !== undefined && input.MemberId !== null && { MemberId: input.MemberId }),
    ...(input.Role !== undefined && input.Role !== null && { Role: input.Role }),
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1CreateRoomMembershipCommand = serializeAws_restJson1CreateRoomMembershipCommand;
const serializeAws_restJson1CreateSipMediaApplicationCommand = async (input, context) => {
  const headers = {
    "content-type": "application/json",
  };
  let resolvedPath = "/sip-media-applications";
  let body;
  body = JSON.stringify({
    ...(input.AwsRegion !== undefined && input.AwsRegion !== null && { AwsRegion: input.AwsRegion }),
    ...(input.Endpoints !== undefined &&
      input.Endpoints !== null && {
        Endpoints: serializeAws_restJson1SipMediaApplicationEndpointList(input.Endpoints, context),
      }),
    ...(input.Name !== undefined && input.Name !== null && { Name: input.Name }),
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1CreateSipMediaApplicationCommand = serializeAws_restJson1CreateSipMediaApplicationCommand;
const serializeAws_restJson1CreateSipMediaApplicationCallCommand = async (input, context) => {
  const headers = {
    "content-type": "application/json",
  };
  let resolvedPath = "/sip-media-applications/{SipMediaApplicationId}/calls";
  if (input.SipMediaApplicationId !== undefined) {
    const labelValue = input.SipMediaApplicationId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: SipMediaApplicationId.");
    }
    resolvedPath = resolvedPath.replace(
      "{SipMediaApplicationId}",
      smithy_client_1.extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: SipMediaApplicationId.");
  }
  let body;
  body = JSON.stringify({
    ...(input.FromPhoneNumber !== undefined &&
      input.FromPhoneNumber !== null && { FromPhoneNumber: input.FromPhoneNumber }),
    ...(input.ToPhoneNumber !== undefined && input.ToPhoneNumber !== null && { ToPhoneNumber: input.ToPhoneNumber }),
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1CreateSipMediaApplicationCallCommand =
  serializeAws_restJson1CreateSipMediaApplicationCallCommand;
const serializeAws_restJson1CreateSipRuleCommand = async (input, context) => {
  const headers = {
    "content-type": "application/json",
  };
  let resolvedPath = "/sip-rules";
  let body;
  body = JSON.stringify({
    ...(input.Disabled !== undefined && input.Disabled !== null && { Disabled: input.Disabled }),
    ...(input.Name !== undefined && input.Name !== null && { Name: input.Name }),
    ...(input.TargetApplications !== undefined &&
      input.TargetApplications !== null && {
        TargetApplications: serializeAws_restJson1SipRuleTargetApplicationList(input.TargetApplications, context),
      }),
    ...(input.TriggerType !== undefined && input.TriggerType !== null && { TriggerType: input.TriggerType }),
    ...(input.TriggerValue !== undefined && input.TriggerValue !== null && { TriggerValue: input.TriggerValue }),
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1CreateSipRuleCommand = serializeAws_restJson1CreateSipRuleCommand;
const serializeAws_restJson1CreateUserCommand = async (input, context) => {
  const headers = {
    "content-type": "application/json",
  };
  let resolvedPath = "/accounts/{AccountId}/users";
  if (input.AccountId !== undefined) {
    const labelValue = input.AccountId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AccountId.");
    }
    resolvedPath = resolvedPath.replace("{AccountId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: AccountId.");
  }
  const query = {
    operation: "create",
  };
  let body;
  body = JSON.stringify({
    ...(input.Email !== undefined && input.Email !== null && { Email: input.Email }),
    ...(input.UserType !== undefined && input.UserType !== null && { UserType: input.UserType }),
    ...(input.Username !== undefined && input.Username !== null && { Username: input.Username }),
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};
exports.serializeAws_restJson1CreateUserCommand = serializeAws_restJson1CreateUserCommand;
const serializeAws_restJson1CreateVoiceConnectorCommand = async (input, context) => {
  const headers = {
    "content-type": "application/json",
  };
  let resolvedPath = "/voice-connectors";
  let body;
  body = JSON.stringify({
    ...(input.AwsRegion !== undefined && input.AwsRegion !== null && { AwsRegion: input.AwsRegion }),
    ...(input.Name !== undefined && input.Name !== null && { Name: input.Name }),
    ...(input.RequireEncryption !== undefined &&
      input.RequireEncryption !== null && { RequireEncryption: input.RequireEncryption }),
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1CreateVoiceConnectorCommand = serializeAws_restJson1CreateVoiceConnectorCommand;
const serializeAws_restJson1CreateVoiceConnectorGroupCommand = async (input, context) => {
  const headers = {
    "content-type": "application/json",
  };
  let resolvedPath = "/voice-connector-groups";
  let body;
  body = JSON.stringify({
    ...(input.Name !== undefined && input.Name !== null && { Name: input.Name }),
    ...(input.VoiceConnectorItems !== undefined &&
      input.VoiceConnectorItems !== null && {
        VoiceConnectorItems: serializeAws_restJson1VoiceConnectorItemList(input.VoiceConnectorItems, context),
      }),
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1CreateVoiceConnectorGroupCommand = serializeAws_restJson1CreateVoiceConnectorGroupCommand;
const serializeAws_restJson1DeleteAccountCommand = async (input, context) => {
  const headers = {};
  let resolvedPath = "/accounts/{AccountId}";
  if (input.AccountId !== undefined) {
    const labelValue = input.AccountId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AccountId.");
    }
    resolvedPath = resolvedPath.replace("{AccountId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: AccountId.");
  }
  let body;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1DeleteAccountCommand = serializeAws_restJson1DeleteAccountCommand;
const serializeAws_restJson1DeleteAppInstanceCommand = async (input, context) => {
  const headers = {};
  let resolvedPath = "/app-instances/{AppInstanceArn}";
  if (input.AppInstanceArn !== undefined) {
    const labelValue = input.AppInstanceArn;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AppInstanceArn.");
    }
    resolvedPath = resolvedPath.replace("{AppInstanceArn}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: AppInstanceArn.");
  }
  let body;
  let { hostname: resolvedHostname } = await context.endpoint();
  if (context.disableHostPrefix !== true) {
    resolvedHostname = "identity-" + resolvedHostname;
    if (!protocol_http_1.isValidHostname(resolvedHostname)) {
      throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
    }
  }
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname: resolvedHostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1DeleteAppInstanceCommand = serializeAws_restJson1DeleteAppInstanceCommand;
const serializeAws_restJson1DeleteAppInstanceAdminCommand = async (input, context) => {
  const headers = {};
  let resolvedPath = "/app-instances/{AppInstanceArn}/admins/{AppInstanceAdminArn}";
  if (input.AppInstanceAdminArn !== undefined) {
    const labelValue = input.AppInstanceAdminArn;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AppInstanceAdminArn.");
    }
    resolvedPath = resolvedPath.replace(
      "{AppInstanceAdminArn}",
      smithy_client_1.extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AppInstanceAdminArn.");
  }
  if (input.AppInstanceArn !== undefined) {
    const labelValue = input.AppInstanceArn;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AppInstanceArn.");
    }
    resolvedPath = resolvedPath.replace("{AppInstanceArn}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: AppInstanceArn.");
  }
  let body;
  let { hostname: resolvedHostname } = await context.endpoint();
  if (context.disableHostPrefix !== true) {
    resolvedHostname = "identity-" + resolvedHostname;
    if (!protocol_http_1.isValidHostname(resolvedHostname)) {
      throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
    }
  }
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname: resolvedHostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1DeleteAppInstanceAdminCommand = serializeAws_restJson1DeleteAppInstanceAdminCommand;
const serializeAws_restJson1DeleteAppInstanceStreamingConfigurationsCommand = async (input, context) => {
  const headers = {};
  let resolvedPath = "/app-instances/{AppInstanceArn}/streaming-configurations";
  if (input.AppInstanceArn !== undefined) {
    const labelValue = input.AppInstanceArn;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AppInstanceArn.");
    }
    resolvedPath = resolvedPath.replace("{AppInstanceArn}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: AppInstanceArn.");
  }
  let body;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1DeleteAppInstanceStreamingConfigurationsCommand =
  serializeAws_restJson1DeleteAppInstanceStreamingConfigurationsCommand;
const serializeAws_restJson1DeleteAppInstanceUserCommand = async (input, context) => {
  const headers = {};
  let resolvedPath = "/app-instance-users/{AppInstanceUserArn}";
  if (input.AppInstanceUserArn !== undefined) {
    const labelValue = input.AppInstanceUserArn;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AppInstanceUserArn.");
    }
    resolvedPath = resolvedPath.replace("{AppInstanceUserArn}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: AppInstanceUserArn.");
  }
  let body;
  let { hostname: resolvedHostname } = await context.endpoint();
  if (context.disableHostPrefix !== true) {
    resolvedHostname = "identity-" + resolvedHostname;
    if (!protocol_http_1.isValidHostname(resolvedHostname)) {
      throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
    }
  }
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname: resolvedHostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1DeleteAppInstanceUserCommand = serializeAws_restJson1DeleteAppInstanceUserCommand;
const serializeAws_restJson1DeleteAttendeeCommand = async (input, context) => {
  const headers = {};
  let resolvedPath = "/meetings/{MeetingId}/attendees/{AttendeeId}";
  if (input.MeetingId !== undefined) {
    const labelValue = input.MeetingId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: MeetingId.");
    }
    resolvedPath = resolvedPath.replace("{MeetingId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: MeetingId.");
  }
  if (input.AttendeeId !== undefined) {
    const labelValue = input.AttendeeId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AttendeeId.");
    }
    resolvedPath = resolvedPath.replace("{AttendeeId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: AttendeeId.");
  }
  let body;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1DeleteAttendeeCommand = serializeAws_restJson1DeleteAttendeeCommand;
const serializeAws_restJson1DeleteChannelCommand = async (input, context) => {
  const headers = {
    ...(isSerializableHeaderValue(input.ChimeBearer) && { "x-amz-chime-bearer": input.ChimeBearer }),
  };
  let resolvedPath = "/channels/{ChannelArn}";
  if (input.ChannelArn !== undefined) {
    const labelValue = input.ChannelArn;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: ChannelArn.");
    }
    resolvedPath = resolvedPath.replace("{ChannelArn}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: ChannelArn.");
  }
  let body;
  let { hostname: resolvedHostname } = await context.endpoint();
  if (context.disableHostPrefix !== true) {
    resolvedHostname = "messaging-" + resolvedHostname;
    if (!protocol_http_1.isValidHostname(resolvedHostname)) {
      throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
    }
  }
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname: resolvedHostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1DeleteChannelCommand = serializeAws_restJson1DeleteChannelCommand;
const serializeAws_restJson1DeleteChannelBanCommand = async (input, context) => {
  const headers = {
    ...(isSerializableHeaderValue(input.ChimeBearer) && { "x-amz-chime-bearer": input.ChimeBearer }),
  };
  let resolvedPath = "/channels/{ChannelArn}/bans/{MemberArn}";
  if (input.ChannelArn !== undefined) {
    const labelValue = input.ChannelArn;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: ChannelArn.");
    }
    resolvedPath = resolvedPath.replace("{ChannelArn}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: ChannelArn.");
  }
  if (input.MemberArn !== undefined) {
    const labelValue = input.MemberArn;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: MemberArn.");
    }
    resolvedPath = resolvedPath.replace("{MemberArn}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: MemberArn.");
  }
  let body;
  let { hostname: resolvedHostname } = await context.endpoint();
  if (context.disableHostPrefix !== true) {
    resolvedHostname = "messaging-" + resolvedHostname;
    if (!protocol_http_1.isValidHostname(resolvedHostname)) {
      throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
    }
  }
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname: resolvedHostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1DeleteChannelBanCommand = serializeAws_restJson1DeleteChannelBanCommand;
const serializeAws_restJson1DeleteChannelMembershipCommand = async (input, context) => {
  const headers = {
    ...(isSerializableHeaderValue(input.ChimeBearer) && { "x-amz-chime-bearer": input.ChimeBearer }),
  };
  let resolvedPath = "/channels/{ChannelArn}/memberships/{MemberArn}";
  if (input.ChannelArn !== undefined) {
    const labelValue = input.ChannelArn;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: ChannelArn.");
    }
    resolvedPath = resolvedPath.replace("{ChannelArn}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: ChannelArn.");
  }
  if (input.MemberArn !== undefined) {
    const labelValue = input.MemberArn;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: MemberArn.");
    }
    resolvedPath = resolvedPath.replace("{MemberArn}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: MemberArn.");
  }
  let body;
  let { hostname: resolvedHostname } = await context.endpoint();
  if (context.disableHostPrefix !== true) {
    resolvedHostname = "messaging-" + resolvedHostname;
    if (!protocol_http_1.isValidHostname(resolvedHostname)) {
      throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
    }
  }
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname: resolvedHostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1DeleteChannelMembershipCommand = serializeAws_restJson1DeleteChannelMembershipCommand;
const serializeAws_restJson1DeleteChannelMessageCommand = async (input, context) => {
  const headers = {
    ...(isSerializableHeaderValue(input.ChimeBearer) && { "x-amz-chime-bearer": input.ChimeBearer }),
  };
  let resolvedPath = "/channels/{ChannelArn}/messages/{MessageId}";
  if (input.ChannelArn !== undefined) {
    const labelValue = input.ChannelArn;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: ChannelArn.");
    }
    resolvedPath = resolvedPath.replace("{ChannelArn}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: ChannelArn.");
  }
  if (input.MessageId !== undefined) {
    const labelValue = input.MessageId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: MessageId.");
    }
    resolvedPath = resolvedPath.replace("{MessageId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: MessageId.");
  }
  let body;
  let { hostname: resolvedHostname } = await context.endpoint();
  if (context.disableHostPrefix !== true) {
    resolvedHostname = "messaging-" + resolvedHostname;
    if (!protocol_http_1.isValidHostname(resolvedHostname)) {
      throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
    }
  }
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname: resolvedHostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1DeleteChannelMessageCommand = serializeAws_restJson1DeleteChannelMessageCommand;
const serializeAws_restJson1DeleteChannelModeratorCommand = async (input, context) => {
  const headers = {
    ...(isSerializableHeaderValue(input.ChimeBearer) && { "x-amz-chime-bearer": input.ChimeBearer }),
  };
  let resolvedPath = "/channels/{ChannelArn}/moderators/{ChannelModeratorArn}";
  if (input.ChannelArn !== undefined) {
    const labelValue = input.ChannelArn;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: ChannelArn.");
    }
    resolvedPath = resolvedPath.replace("{ChannelArn}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: ChannelArn.");
  }
  if (input.ChannelModeratorArn !== undefined) {
    const labelValue = input.ChannelModeratorArn;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: ChannelModeratorArn.");
    }
    resolvedPath = resolvedPath.replace(
      "{ChannelModeratorArn}",
      smithy_client_1.extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ChannelModeratorArn.");
  }
  let body;
  let { hostname: resolvedHostname } = await context.endpoint();
  if (context.disableHostPrefix !== true) {
    resolvedHostname = "messaging-" + resolvedHostname;
    if (!protocol_http_1.isValidHostname(resolvedHostname)) {
      throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
    }
  }
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname: resolvedHostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1DeleteChannelModeratorCommand = serializeAws_restJson1DeleteChannelModeratorCommand;
const serializeAws_restJson1DeleteEventsConfigurationCommand = async (input, context) => {
  const headers = {};
  let resolvedPath = "/accounts/{AccountId}/bots/{BotId}/events-configuration";
  if (input.AccountId !== undefined) {
    const labelValue = input.AccountId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AccountId.");
    }
    resolvedPath = resolvedPath.replace("{AccountId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: AccountId.");
  }
  if (input.BotId !== undefined) {
    const labelValue = input.BotId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: BotId.");
    }
    resolvedPath = resolvedPath.replace("{BotId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: BotId.");
  }
  let body;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1DeleteEventsConfigurationCommand = serializeAws_restJson1DeleteEventsConfigurationCommand;
const serializeAws_restJson1DeleteMeetingCommand = async (input, context) => {
  const headers = {};
  let resolvedPath = "/meetings/{MeetingId}";
  if (input.MeetingId !== undefined) {
    const labelValue = input.MeetingId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: MeetingId.");
    }
    resolvedPath = resolvedPath.replace("{MeetingId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: MeetingId.");
  }
  let body;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1DeleteMeetingCommand = serializeAws_restJson1DeleteMeetingCommand;
const serializeAws_restJson1DeletePhoneNumberCommand = async (input, context) => {
  const headers = {};
  let resolvedPath = "/phone-numbers/{PhoneNumberId}";
  if (input.PhoneNumberId !== undefined) {
    const labelValue = input.PhoneNumberId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: PhoneNumberId.");
    }
    resolvedPath = resolvedPath.replace("{PhoneNumberId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: PhoneNumberId.");
  }
  let body;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1DeletePhoneNumberCommand = serializeAws_restJson1DeletePhoneNumberCommand;
const serializeAws_restJson1DeleteProxySessionCommand = async (input, context) => {
  const headers = {};
  let resolvedPath = "/voice-connectors/{VoiceConnectorId}/proxy-sessions/{ProxySessionId}";
  if (input.VoiceConnectorId !== undefined) {
    const labelValue = input.VoiceConnectorId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: VoiceConnectorId.");
    }
    resolvedPath = resolvedPath.replace("{VoiceConnectorId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: VoiceConnectorId.");
  }
  if (input.ProxySessionId !== undefined) {
    const labelValue = input.ProxySessionId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: ProxySessionId.");
    }
    resolvedPath = resolvedPath.replace("{ProxySessionId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: ProxySessionId.");
  }
  let body;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1DeleteProxySessionCommand = serializeAws_restJson1DeleteProxySessionCommand;
const serializeAws_restJson1DeleteRoomCommand = async (input, context) => {
  const headers = {};
  let resolvedPath = "/accounts/{AccountId}/rooms/{RoomId}";
  if (input.AccountId !== undefined) {
    const labelValue = input.AccountId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AccountId.");
    }
    resolvedPath = resolvedPath.replace("{AccountId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: AccountId.");
  }
  if (input.RoomId !== undefined) {
    const labelValue = input.RoomId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: RoomId.");
    }
    resolvedPath = resolvedPath.replace("{RoomId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: RoomId.");
  }
  let body;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1DeleteRoomCommand = serializeAws_restJson1DeleteRoomCommand;
const serializeAws_restJson1DeleteRoomMembershipCommand = async (input, context) => {
  const headers = {};
  let resolvedPath = "/accounts/{AccountId}/rooms/{RoomId}/memberships/{MemberId}";
  if (input.AccountId !== undefined) {
    const labelValue = input.AccountId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AccountId.");
    }
    resolvedPath = resolvedPath.replace("{AccountId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: AccountId.");
  }
  if (input.RoomId !== undefined) {
    const labelValue = input.RoomId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: RoomId.");
    }
    resolvedPath = resolvedPath.replace("{RoomId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: RoomId.");
  }
  if (input.MemberId !== undefined) {
    const labelValue = input.MemberId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: MemberId.");
    }
    resolvedPath = resolvedPath.replace("{MemberId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: MemberId.");
  }
  let body;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1DeleteRoomMembershipCommand = serializeAws_restJson1DeleteRoomMembershipCommand;
const serializeAws_restJson1DeleteSipMediaApplicationCommand = async (input, context) => {
  const headers = {};
  let resolvedPath = "/sip-media-applications/{SipMediaApplicationId}";
  if (input.SipMediaApplicationId !== undefined) {
    const labelValue = input.SipMediaApplicationId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: SipMediaApplicationId.");
    }
    resolvedPath = resolvedPath.replace(
      "{SipMediaApplicationId}",
      smithy_client_1.extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: SipMediaApplicationId.");
  }
  let body;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1DeleteSipMediaApplicationCommand = serializeAws_restJson1DeleteSipMediaApplicationCommand;
const serializeAws_restJson1DeleteSipRuleCommand = async (input, context) => {
  const headers = {};
  let resolvedPath = "/sip-rules/{SipRuleId}";
  if (input.SipRuleId !== undefined) {
    const labelValue = input.SipRuleId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: SipRuleId.");
    }
    resolvedPath = resolvedPath.replace("{SipRuleId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: SipRuleId.");
  }
  let body;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1DeleteSipRuleCommand = serializeAws_restJson1DeleteSipRuleCommand;
const serializeAws_restJson1DeleteVoiceConnectorCommand = async (input, context) => {
  const headers = {};
  let resolvedPath = "/voice-connectors/{VoiceConnectorId}";
  if (input.VoiceConnectorId !== undefined) {
    const labelValue = input.VoiceConnectorId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: VoiceConnectorId.");
    }
    resolvedPath = resolvedPath.replace("{VoiceConnectorId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: VoiceConnectorId.");
  }
  let body;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1DeleteVoiceConnectorCommand = serializeAws_restJson1DeleteVoiceConnectorCommand;
const serializeAws_restJson1DeleteVoiceConnectorEmergencyCallingConfigurationCommand = async (input, context) => {
  const headers = {};
  let resolvedPath = "/voice-connectors/{VoiceConnectorId}/emergency-calling-configuration";
  if (input.VoiceConnectorId !== undefined) {
    const labelValue = input.VoiceConnectorId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: VoiceConnectorId.");
    }
    resolvedPath = resolvedPath.replace("{VoiceConnectorId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: VoiceConnectorId.");
  }
  let body;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1DeleteVoiceConnectorEmergencyCallingConfigurationCommand =
  serializeAws_restJson1DeleteVoiceConnectorEmergencyCallingConfigurationCommand;
const serializeAws_restJson1DeleteVoiceConnectorGroupCommand = async (input, context) => {
  const headers = {};
  let resolvedPath = "/voice-connector-groups/{VoiceConnectorGroupId}";
  if (input.VoiceConnectorGroupId !== undefined) {
    const labelValue = input.VoiceConnectorGroupId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: VoiceConnectorGroupId.");
    }
    resolvedPath = resolvedPath.replace(
      "{VoiceConnectorGroupId}",
      smithy_client_1.extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: VoiceConnectorGroupId.");
  }
  let body;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1DeleteVoiceConnectorGroupCommand = serializeAws_restJson1DeleteVoiceConnectorGroupCommand;
const serializeAws_restJson1DeleteVoiceConnectorOriginationCommand = async (input, context) => {
  const headers = {};
  let resolvedPath = "/voice-connectors/{VoiceConnectorId}/origination";
  if (input.VoiceConnectorId !== undefined) {
    const labelValue = input.VoiceConnectorId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: VoiceConnectorId.");
    }
    resolvedPath = resolvedPath.replace("{VoiceConnectorId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: VoiceConnectorId.");
  }
  let body;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1DeleteVoiceConnectorOriginationCommand =
  serializeAws_restJson1DeleteVoiceConnectorOriginationCommand;
const serializeAws_restJson1DeleteVoiceConnectorProxyCommand = async (input, context) => {
  const headers = {};
  let resolvedPath = "/voice-connectors/{VoiceConnectorId}/programmable-numbers/proxy";
  if (input.VoiceConnectorId !== undefined) {
    const labelValue = input.VoiceConnectorId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: VoiceConnectorId.");
    }
    resolvedPath = resolvedPath.replace("{VoiceConnectorId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: VoiceConnectorId.");
  }
  let body;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1DeleteVoiceConnectorProxyCommand = serializeAws_restJson1DeleteVoiceConnectorProxyCommand;
const serializeAws_restJson1DeleteVoiceConnectorStreamingConfigurationCommand = async (input, context) => {
  const headers = {};
  let resolvedPath = "/voice-connectors/{VoiceConnectorId}/streaming-configuration";
  if (input.VoiceConnectorId !== undefined) {
    const labelValue = input.VoiceConnectorId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: VoiceConnectorId.");
    }
    resolvedPath = resolvedPath.replace("{VoiceConnectorId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: VoiceConnectorId.");
  }
  let body;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1DeleteVoiceConnectorStreamingConfigurationCommand =
  serializeAws_restJson1DeleteVoiceConnectorStreamingConfigurationCommand;
const serializeAws_restJson1DeleteVoiceConnectorTerminationCommand = async (input, context) => {
  const headers = {};
  let resolvedPath = "/voice-connectors/{VoiceConnectorId}/termination";
  if (input.VoiceConnectorId !== undefined) {
    const labelValue = input.VoiceConnectorId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: VoiceConnectorId.");
    }
    resolvedPath = resolvedPath.replace("{VoiceConnectorId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: VoiceConnectorId.");
  }
  let body;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1DeleteVoiceConnectorTerminationCommand =
  serializeAws_restJson1DeleteVoiceConnectorTerminationCommand;
const serializeAws_restJson1DeleteVoiceConnectorTerminationCredentialsCommand = async (input, context) => {
  const headers = {
    "content-type": "application/json",
  };
  let resolvedPath = "/voice-connectors/{VoiceConnectorId}/termination/credentials";
  if (input.VoiceConnectorId !== undefined) {
    const labelValue = input.VoiceConnectorId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: VoiceConnectorId.");
    }
    resolvedPath = resolvedPath.replace("{VoiceConnectorId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: VoiceConnectorId.");
  }
  const query = {
    operation: "delete",
  };
  let body;
  body = JSON.stringify({
    ...(input.Usernames !== undefined &&
      input.Usernames !== null && { Usernames: serializeAws_restJson1SensitiveStringList(input.Usernames, context) }),
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};
exports.serializeAws_restJson1DeleteVoiceConnectorTerminationCredentialsCommand =
  serializeAws_restJson1DeleteVoiceConnectorTerminationCredentialsCommand;
const serializeAws_restJson1DescribeAppInstanceCommand = async (input, context) => {
  const headers = {};
  let resolvedPath = "/app-instances/{AppInstanceArn}";
  if (input.AppInstanceArn !== undefined) {
    const labelValue = input.AppInstanceArn;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AppInstanceArn.");
    }
    resolvedPath = resolvedPath.replace("{AppInstanceArn}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: AppInstanceArn.");
  }
  let body;
  let { hostname: resolvedHostname } = await context.endpoint();
  if (context.disableHostPrefix !== true) {
    resolvedHostname = "identity-" + resolvedHostname;
    if (!protocol_http_1.isValidHostname(resolvedHostname)) {
      throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
    }
  }
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname: resolvedHostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1DescribeAppInstanceCommand = serializeAws_restJson1DescribeAppInstanceCommand;
const serializeAws_restJson1DescribeAppInstanceAdminCommand = async (input, context) => {
  const headers = {};
  let resolvedPath = "/app-instances/{AppInstanceArn}/admins/{AppInstanceAdminArn}";
  if (input.AppInstanceAdminArn !== undefined) {
    const labelValue = input.AppInstanceAdminArn;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AppInstanceAdminArn.");
    }
    resolvedPath = resolvedPath.replace(
      "{AppInstanceAdminArn}",
      smithy_client_1.extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AppInstanceAdminArn.");
  }
  if (input.AppInstanceArn !== undefined) {
    const labelValue = input.AppInstanceArn;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AppInstanceArn.");
    }
    resolvedPath = resolvedPath.replace("{AppInstanceArn}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: AppInstanceArn.");
  }
  let body;
  let { hostname: resolvedHostname } = await context.endpoint();
  if (context.disableHostPrefix !== true) {
    resolvedHostname = "identity-" + resolvedHostname;
    if (!protocol_http_1.isValidHostname(resolvedHostname)) {
      throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
    }
  }
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname: resolvedHostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1DescribeAppInstanceAdminCommand = serializeAws_restJson1DescribeAppInstanceAdminCommand;
const serializeAws_restJson1DescribeAppInstanceUserCommand = async (input, context) => {
  const headers = {};
  let resolvedPath = "/app-instance-users/{AppInstanceUserArn}";
  if (input.AppInstanceUserArn !== undefined) {
    const labelValue = input.AppInstanceUserArn;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AppInstanceUserArn.");
    }
    resolvedPath = resolvedPath.replace("{AppInstanceUserArn}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: AppInstanceUserArn.");
  }
  let body;
  let { hostname: resolvedHostname } = await context.endpoint();
  if (context.disableHostPrefix !== true) {
    resolvedHostname = "identity-" + resolvedHostname;
    if (!protocol_http_1.isValidHostname(resolvedHostname)) {
      throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
    }
  }
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname: resolvedHostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1DescribeAppInstanceUserCommand = serializeAws_restJson1DescribeAppInstanceUserCommand;
const serializeAws_restJson1DescribeChannelCommand = async (input, context) => {
  const headers = {
    ...(isSerializableHeaderValue(input.ChimeBearer) && { "x-amz-chime-bearer": input.ChimeBearer }),
  };
  let resolvedPath = "/channels/{ChannelArn}";
  if (input.ChannelArn !== undefined) {
    const labelValue = input.ChannelArn;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: ChannelArn.");
    }
    resolvedPath = resolvedPath.replace("{ChannelArn}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: ChannelArn.");
  }
  let body;
  let { hostname: resolvedHostname } = await context.endpoint();
  if (context.disableHostPrefix !== true) {
    resolvedHostname = "messaging-" + resolvedHostname;
    if (!protocol_http_1.isValidHostname(resolvedHostname)) {
      throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
    }
  }
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname: resolvedHostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1DescribeChannelCommand = serializeAws_restJson1DescribeChannelCommand;
const serializeAws_restJson1DescribeChannelBanCommand = async (input, context) => {
  const headers = {
    ...(isSerializableHeaderValue(input.ChimeBearer) && { "x-amz-chime-bearer": input.ChimeBearer }),
  };
  let resolvedPath = "/channels/{ChannelArn}/bans/{MemberArn}";
  if (input.ChannelArn !== undefined) {
    const labelValue = input.ChannelArn;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: ChannelArn.");
    }
    resolvedPath = resolvedPath.replace("{ChannelArn}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: ChannelArn.");
  }
  if (input.MemberArn !== undefined) {
    const labelValue = input.MemberArn;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: MemberArn.");
    }
    resolvedPath = resolvedPath.replace("{MemberArn}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: MemberArn.");
  }
  let body;
  let { hostname: resolvedHostname } = await context.endpoint();
  if (context.disableHostPrefix !== true) {
    resolvedHostname = "messaging-" + resolvedHostname;
    if (!protocol_http_1.isValidHostname(resolvedHostname)) {
      throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
    }
  }
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname: resolvedHostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1DescribeChannelBanCommand = serializeAws_restJson1DescribeChannelBanCommand;
const serializeAws_restJson1DescribeChannelMembershipCommand = async (input, context) => {
  const headers = {
    ...(isSerializableHeaderValue(input.ChimeBearer) && { "x-amz-chime-bearer": input.ChimeBearer }),
  };
  let resolvedPath = "/channels/{ChannelArn}/memberships/{MemberArn}";
  if (input.ChannelArn !== undefined) {
    const labelValue = input.ChannelArn;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: ChannelArn.");
    }
    resolvedPath = resolvedPath.replace("{ChannelArn}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: ChannelArn.");
  }
  if (input.MemberArn !== undefined) {
    const labelValue = input.MemberArn;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: MemberArn.");
    }
    resolvedPath = resolvedPath.replace("{MemberArn}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: MemberArn.");
  }
  let body;
  let { hostname: resolvedHostname } = await context.endpoint();
  if (context.disableHostPrefix !== true) {
    resolvedHostname = "messaging-" + resolvedHostname;
    if (!protocol_http_1.isValidHostname(resolvedHostname)) {
      throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
    }
  }
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname: resolvedHostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1DescribeChannelMembershipCommand = serializeAws_restJson1DescribeChannelMembershipCommand;
const serializeAws_restJson1DescribeChannelMembershipForAppInstanceUserCommand = async (input, context) => {
  const headers = {
    ...(isSerializableHeaderValue(input.ChimeBearer) && { "x-amz-chime-bearer": input.ChimeBearer }),
  };
  let resolvedPath = "/channels/{ChannelArn}";
  if (input.ChannelArn !== undefined) {
    const labelValue = input.ChannelArn;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: ChannelArn.");
    }
    resolvedPath = resolvedPath.replace("{ChannelArn}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: ChannelArn.");
  }
  const query = {
    scope: "app-instance-user-membership",
    ...(input.AppInstanceUserArn !== undefined && { "app-instance-user-arn": input.AppInstanceUserArn }),
  };
  let body;
  let { hostname: resolvedHostname } = await context.endpoint();
  if (context.disableHostPrefix !== true) {
    resolvedHostname = "messaging-" + resolvedHostname;
    if (!protocol_http_1.isValidHostname(resolvedHostname)) {
      throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
    }
  }
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname: resolvedHostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};
exports.serializeAws_restJson1DescribeChannelMembershipForAppInstanceUserCommand =
  serializeAws_restJson1DescribeChannelMembershipForAppInstanceUserCommand;
const serializeAws_restJson1DescribeChannelModeratedByAppInstanceUserCommand = async (input, context) => {
  const headers = {
    ...(isSerializableHeaderValue(input.ChimeBearer) && { "x-amz-chime-bearer": input.ChimeBearer }),
  };
  let resolvedPath = "/channels/{ChannelArn}";
  if (input.ChannelArn !== undefined) {
    const labelValue = input.ChannelArn;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: ChannelArn.");
    }
    resolvedPath = resolvedPath.replace("{ChannelArn}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: ChannelArn.");
  }
  const query = {
    scope: "app-instance-user-moderated-channel",
    ...(input.AppInstanceUserArn !== undefined && { "app-instance-user-arn": input.AppInstanceUserArn }),
  };
  let body;
  let { hostname: resolvedHostname } = await context.endpoint();
  if (context.disableHostPrefix !== true) {
    resolvedHostname = "messaging-" + resolvedHostname;
    if (!protocol_http_1.isValidHostname(resolvedHostname)) {
      throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
    }
  }
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname: resolvedHostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};
exports.serializeAws_restJson1DescribeChannelModeratedByAppInstanceUserCommand =
  serializeAws_restJson1DescribeChannelModeratedByAppInstanceUserCommand;
const serializeAws_restJson1DescribeChannelModeratorCommand = async (input, context) => {
  const headers = {
    ...(isSerializableHeaderValue(input.ChimeBearer) && { "x-amz-chime-bearer": input.ChimeBearer }),
  };
  let resolvedPath = "/channels/{ChannelArn}/moderators/{ChannelModeratorArn}";
  if (input.ChannelArn !== undefined) {
    const labelValue = input.ChannelArn;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: ChannelArn.");
    }
    resolvedPath = resolvedPath.replace("{ChannelArn}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: ChannelArn.");
  }
  if (input.ChannelModeratorArn !== undefined) {
    const labelValue = input.ChannelModeratorArn;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: ChannelModeratorArn.");
    }
    resolvedPath = resolvedPath.replace(
      "{ChannelModeratorArn}",
      smithy_client_1.extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ChannelModeratorArn.");
  }
  let body;
  let { hostname: resolvedHostname } = await context.endpoint();
  if (context.disableHostPrefix !== true) {
    resolvedHostname = "messaging-" + resolvedHostname;
    if (!protocol_http_1.isValidHostname(resolvedHostname)) {
      throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
    }
  }
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname: resolvedHostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1DescribeChannelModeratorCommand = serializeAws_restJson1DescribeChannelModeratorCommand;
const serializeAws_restJson1DisassociatePhoneNumberFromUserCommand = async (input, context) => {
  const headers = {};
  let resolvedPath = "/accounts/{AccountId}/users/{UserId}";
  if (input.AccountId !== undefined) {
    const labelValue = input.AccountId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AccountId.");
    }
    resolvedPath = resolvedPath.replace("{AccountId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: AccountId.");
  }
  if (input.UserId !== undefined) {
    const labelValue = input.UserId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: UserId.");
    }
    resolvedPath = resolvedPath.replace("{UserId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: UserId.");
  }
  const query = {
    operation: "disassociate-phone-number",
  };
  let body;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};
exports.serializeAws_restJson1DisassociatePhoneNumberFromUserCommand =
  serializeAws_restJson1DisassociatePhoneNumberFromUserCommand;
const serializeAws_restJson1DisassociatePhoneNumbersFromVoiceConnectorCommand = async (input, context) => {
  const headers = {
    "content-type": "application/json",
  };
  let resolvedPath = "/voice-connectors/{VoiceConnectorId}";
  if (input.VoiceConnectorId !== undefined) {
    const labelValue = input.VoiceConnectorId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: VoiceConnectorId.");
    }
    resolvedPath = resolvedPath.replace("{VoiceConnectorId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: VoiceConnectorId.");
  }
  const query = {
    operation: "disassociate-phone-numbers",
  };
  let body;
  body = JSON.stringify({
    ...(input.E164PhoneNumbers !== undefined &&
      input.E164PhoneNumbers !== null && {
        E164PhoneNumbers: serializeAws_restJson1E164PhoneNumberList(input.E164PhoneNumbers, context),
      }),
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};
exports.serializeAws_restJson1DisassociatePhoneNumbersFromVoiceConnectorCommand =
  serializeAws_restJson1DisassociatePhoneNumbersFromVoiceConnectorCommand;
const serializeAws_restJson1DisassociatePhoneNumbersFromVoiceConnectorGroupCommand = async (input, context) => {
  const headers = {
    "content-type": "application/json",
  };
  let resolvedPath = "/voice-connector-groups/{VoiceConnectorGroupId}";
  if (input.VoiceConnectorGroupId !== undefined) {
    const labelValue = input.VoiceConnectorGroupId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: VoiceConnectorGroupId.");
    }
    resolvedPath = resolvedPath.replace(
      "{VoiceConnectorGroupId}",
      smithy_client_1.extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: VoiceConnectorGroupId.");
  }
  const query = {
    operation: "disassociate-phone-numbers",
  };
  let body;
  body = JSON.stringify({
    ...(input.E164PhoneNumbers !== undefined &&
      input.E164PhoneNumbers !== null && {
        E164PhoneNumbers: serializeAws_restJson1E164PhoneNumberList(input.E164PhoneNumbers, context),
      }),
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};
exports.serializeAws_restJson1DisassociatePhoneNumbersFromVoiceConnectorGroupCommand =
  serializeAws_restJson1DisassociatePhoneNumbersFromVoiceConnectorGroupCommand;
const serializeAws_restJson1DisassociateSigninDelegateGroupsFromAccountCommand = async (input, context) => {
  const headers = {
    "content-type": "application/json",
  };
  let resolvedPath = "/accounts/{AccountId}";
  if (input.AccountId !== undefined) {
    const labelValue = input.AccountId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AccountId.");
    }
    resolvedPath = resolvedPath.replace("{AccountId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: AccountId.");
  }
  const query = {
    operation: "disassociate-signin-delegate-groups",
  };
  let body;
  body = JSON.stringify({
    ...(input.GroupNames !== undefined &&
      input.GroupNames !== null && { GroupNames: serializeAws_restJson1NonEmptyStringList(input.GroupNames, context) }),
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};
exports.serializeAws_restJson1DisassociateSigninDelegateGroupsFromAccountCommand =
  serializeAws_restJson1DisassociateSigninDelegateGroupsFromAccountCommand;
const serializeAws_restJson1GetAccountCommand = async (input, context) => {
  const headers = {};
  let resolvedPath = "/accounts/{AccountId}";
  if (input.AccountId !== undefined) {
    const labelValue = input.AccountId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AccountId.");
    }
    resolvedPath = resolvedPath.replace("{AccountId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: AccountId.");
  }
  let body;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1GetAccountCommand = serializeAws_restJson1GetAccountCommand;
const serializeAws_restJson1GetAccountSettingsCommand = async (input, context) => {
  const headers = {};
  let resolvedPath = "/accounts/{AccountId}/settings";
  if (input.AccountId !== undefined) {
    const labelValue = input.AccountId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AccountId.");
    }
    resolvedPath = resolvedPath.replace("{AccountId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: AccountId.");
  }
  let body;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1GetAccountSettingsCommand = serializeAws_restJson1GetAccountSettingsCommand;
const serializeAws_restJson1GetAppInstanceRetentionSettingsCommand = async (input, context) => {
  const headers = {};
  let resolvedPath = "/app-instances/{AppInstanceArn}/retention-settings";
  if (input.AppInstanceArn !== undefined) {
    const labelValue = input.AppInstanceArn;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AppInstanceArn.");
    }
    resolvedPath = resolvedPath.replace("{AppInstanceArn}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: AppInstanceArn.");
  }
  let body;
  let { hostname: resolvedHostname } = await context.endpoint();
  if (context.disableHostPrefix !== true) {
    resolvedHostname = "identity-" + resolvedHostname;
    if (!protocol_http_1.isValidHostname(resolvedHostname)) {
      throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
    }
  }
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname: resolvedHostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1GetAppInstanceRetentionSettingsCommand =
  serializeAws_restJson1GetAppInstanceRetentionSettingsCommand;
const serializeAws_restJson1GetAppInstanceStreamingConfigurationsCommand = async (input, context) => {
  const headers = {};
  let resolvedPath = "/app-instances/{AppInstanceArn}/streaming-configurations";
  if (input.AppInstanceArn !== undefined) {
    const labelValue = input.AppInstanceArn;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AppInstanceArn.");
    }
    resolvedPath = resolvedPath.replace("{AppInstanceArn}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: AppInstanceArn.");
  }
  let body;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1GetAppInstanceStreamingConfigurationsCommand =
  serializeAws_restJson1GetAppInstanceStreamingConfigurationsCommand;
const serializeAws_restJson1GetAttendeeCommand = async (input, context) => {
  const headers = {};
  let resolvedPath = "/meetings/{MeetingId}/attendees/{AttendeeId}";
  if (input.MeetingId !== undefined) {
    const labelValue = input.MeetingId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: MeetingId.");
    }
    resolvedPath = resolvedPath.replace("{MeetingId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: MeetingId.");
  }
  if (input.AttendeeId !== undefined) {
    const labelValue = input.AttendeeId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AttendeeId.");
    }
    resolvedPath = resolvedPath.replace("{AttendeeId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: AttendeeId.");
  }
  let body;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1GetAttendeeCommand = serializeAws_restJson1GetAttendeeCommand;
const serializeAws_restJson1GetBotCommand = async (input, context) => {
  const headers = {};
  let resolvedPath = "/accounts/{AccountId}/bots/{BotId}";
  if (input.AccountId !== undefined) {
    const labelValue = input.AccountId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AccountId.");
    }
    resolvedPath = resolvedPath.replace("{AccountId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: AccountId.");
  }
  if (input.BotId !== undefined) {
    const labelValue = input.BotId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: BotId.");
    }
    resolvedPath = resolvedPath.replace("{BotId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: BotId.");
  }
  let body;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1GetBotCommand = serializeAws_restJson1GetBotCommand;
const serializeAws_restJson1GetChannelMessageCommand = async (input, context) => {
  const headers = {
    ...(isSerializableHeaderValue(input.ChimeBearer) && { "x-amz-chime-bearer": input.ChimeBearer }),
  };
  let resolvedPath = "/channels/{ChannelArn}/messages/{MessageId}";
  if (input.ChannelArn !== undefined) {
    const labelValue = input.ChannelArn;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: ChannelArn.");
    }
    resolvedPath = resolvedPath.replace("{ChannelArn}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: ChannelArn.");
  }
  if (input.MessageId !== undefined) {
    const labelValue = input.MessageId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: MessageId.");
    }
    resolvedPath = resolvedPath.replace("{MessageId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: MessageId.");
  }
  let body;
  let { hostname: resolvedHostname } = await context.endpoint();
  if (context.disableHostPrefix !== true) {
    resolvedHostname = "messaging-" + resolvedHostname;
    if (!protocol_http_1.isValidHostname(resolvedHostname)) {
      throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
    }
  }
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname: resolvedHostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1GetChannelMessageCommand = serializeAws_restJson1GetChannelMessageCommand;
const serializeAws_restJson1GetEventsConfigurationCommand = async (input, context) => {
  const headers = {};
  let resolvedPath = "/accounts/{AccountId}/bots/{BotId}/events-configuration";
  if (input.AccountId !== undefined) {
    const labelValue = input.AccountId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AccountId.");
    }
    resolvedPath = resolvedPath.replace("{AccountId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: AccountId.");
  }
  if (input.BotId !== undefined) {
    const labelValue = input.BotId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: BotId.");
    }
    resolvedPath = resolvedPath.replace("{BotId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: BotId.");
  }
  let body;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1GetEventsConfigurationCommand = serializeAws_restJson1GetEventsConfigurationCommand;
const serializeAws_restJson1GetGlobalSettingsCommand = async (input, context) => {
  const headers = {
    "content-type": "application/json",
  };
  let resolvedPath = "/settings";
  let body;
  body = "";
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1GetGlobalSettingsCommand = serializeAws_restJson1GetGlobalSettingsCommand;
const serializeAws_restJson1GetMeetingCommand = async (input, context) => {
  const headers = {};
  let resolvedPath = "/meetings/{MeetingId}";
  if (input.MeetingId !== undefined) {
    const labelValue = input.MeetingId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: MeetingId.");
    }
    resolvedPath = resolvedPath.replace("{MeetingId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: MeetingId.");
  }
  let body;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1GetMeetingCommand = serializeAws_restJson1GetMeetingCommand;
const serializeAws_restJson1GetMessagingSessionEndpointCommand = async (input, context) => {
  const headers = {
    "content-type": "application/json",
  };
  let resolvedPath = "/endpoints/messaging-session";
  let body;
  body = "";
  let { hostname: resolvedHostname } = await context.endpoint();
  if (context.disableHostPrefix !== true) {
    resolvedHostname = "messaging-" + resolvedHostname;
    if (!protocol_http_1.isValidHostname(resolvedHostname)) {
      throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
    }
  }
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname: resolvedHostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1GetMessagingSessionEndpointCommand =
  serializeAws_restJson1GetMessagingSessionEndpointCommand;
const serializeAws_restJson1GetPhoneNumberCommand = async (input, context) => {
  const headers = {};
  let resolvedPath = "/phone-numbers/{PhoneNumberId}";
  if (input.PhoneNumberId !== undefined) {
    const labelValue = input.PhoneNumberId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: PhoneNumberId.");
    }
    resolvedPath = resolvedPath.replace("{PhoneNumberId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: PhoneNumberId.");
  }
  let body;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1GetPhoneNumberCommand = serializeAws_restJson1GetPhoneNumberCommand;
const serializeAws_restJson1GetPhoneNumberOrderCommand = async (input, context) => {
  const headers = {};
  let resolvedPath = "/phone-number-orders/{PhoneNumberOrderId}";
  if (input.PhoneNumberOrderId !== undefined) {
    const labelValue = input.PhoneNumberOrderId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: PhoneNumberOrderId.");
    }
    resolvedPath = resolvedPath.replace("{PhoneNumberOrderId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: PhoneNumberOrderId.");
  }
  let body;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1GetPhoneNumberOrderCommand = serializeAws_restJson1GetPhoneNumberOrderCommand;
const serializeAws_restJson1GetPhoneNumberSettingsCommand = async (input, context) => {
  const headers = {
    "content-type": "application/json",
  };
  let resolvedPath = "/settings/phone-number";
  let body;
  body = "";
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1GetPhoneNumberSettingsCommand = serializeAws_restJson1GetPhoneNumberSettingsCommand;
const serializeAws_restJson1GetProxySessionCommand = async (input, context) => {
  const headers = {};
  let resolvedPath = "/voice-connectors/{VoiceConnectorId}/proxy-sessions/{ProxySessionId}";
  if (input.VoiceConnectorId !== undefined) {
    const labelValue = input.VoiceConnectorId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: VoiceConnectorId.");
    }
    resolvedPath = resolvedPath.replace("{VoiceConnectorId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: VoiceConnectorId.");
  }
  if (input.ProxySessionId !== undefined) {
    const labelValue = input.ProxySessionId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: ProxySessionId.");
    }
    resolvedPath = resolvedPath.replace("{ProxySessionId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: ProxySessionId.");
  }
  let body;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1GetProxySessionCommand = serializeAws_restJson1GetProxySessionCommand;
const serializeAws_restJson1GetRetentionSettingsCommand = async (input, context) => {
  const headers = {};
  let resolvedPath = "/accounts/{AccountId}/retention-settings";
  if (input.AccountId !== undefined) {
    const labelValue = input.AccountId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AccountId.");
    }
    resolvedPath = resolvedPath.replace("{AccountId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: AccountId.");
  }
  let body;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1GetRetentionSettingsCommand = serializeAws_restJson1GetRetentionSettingsCommand;
const serializeAws_restJson1GetRoomCommand = async (input, context) => {
  const headers = {};
  let resolvedPath = "/accounts/{AccountId}/rooms/{RoomId}";
  if (input.AccountId !== undefined) {
    const labelValue = input.AccountId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AccountId.");
    }
    resolvedPath = resolvedPath.replace("{AccountId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: AccountId.");
  }
  if (input.RoomId !== undefined) {
    const labelValue = input.RoomId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: RoomId.");
    }
    resolvedPath = resolvedPath.replace("{RoomId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: RoomId.");
  }
  let body;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1GetRoomCommand = serializeAws_restJson1GetRoomCommand;
const serializeAws_restJson1GetSipMediaApplicationCommand = async (input, context) => {
  const headers = {};
  let resolvedPath = "/sip-media-applications/{SipMediaApplicationId}";
  if (input.SipMediaApplicationId !== undefined) {
    const labelValue = input.SipMediaApplicationId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: SipMediaApplicationId.");
    }
    resolvedPath = resolvedPath.replace(
      "{SipMediaApplicationId}",
      smithy_client_1.extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: SipMediaApplicationId.");
  }
  let body;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1GetSipMediaApplicationCommand = serializeAws_restJson1GetSipMediaApplicationCommand;
const serializeAws_restJson1GetSipMediaApplicationLoggingConfigurationCommand = async (input, context) => {
  const headers = {};
  let resolvedPath = "/sip-media-applications/{SipMediaApplicationId}/logging-configuration";
  if (input.SipMediaApplicationId !== undefined) {
    const labelValue = input.SipMediaApplicationId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: SipMediaApplicationId.");
    }
    resolvedPath = resolvedPath.replace(
      "{SipMediaApplicationId}",
      smithy_client_1.extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: SipMediaApplicationId.");
  }
  let body;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1GetSipMediaApplicationLoggingConfigurationCommand =
  serializeAws_restJson1GetSipMediaApplicationLoggingConfigurationCommand;
const serializeAws_restJson1GetSipRuleCommand = async (input, context) => {
  const headers = {};
  let resolvedPath = "/sip-rules/{SipRuleId}";
  if (input.SipRuleId !== undefined) {
    const labelValue = input.SipRuleId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: SipRuleId.");
    }
    resolvedPath = resolvedPath.replace("{SipRuleId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: SipRuleId.");
  }
  let body;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1GetSipRuleCommand = serializeAws_restJson1GetSipRuleCommand;
const serializeAws_restJson1GetUserCommand = async (input, context) => {
  const headers = {};
  let resolvedPath = "/accounts/{AccountId}/users/{UserId}";
  if (input.AccountId !== undefined) {
    const labelValue = input.AccountId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AccountId.");
    }
    resolvedPath = resolvedPath.replace("{AccountId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: AccountId.");
  }
  if (input.UserId !== undefined) {
    const labelValue = input.UserId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: UserId.");
    }
    resolvedPath = resolvedPath.replace("{UserId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: UserId.");
  }
  let body;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1GetUserCommand = serializeAws_restJson1GetUserCommand;
const serializeAws_restJson1GetUserSettingsCommand = async (input, context) => {
  const headers = {};
  let resolvedPath = "/accounts/{AccountId}/users/{UserId}/settings";
  if (input.AccountId !== undefined) {
    const labelValue = input.AccountId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AccountId.");
    }
    resolvedPath = resolvedPath.replace("{AccountId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: AccountId.");
  }
  if (input.UserId !== undefined) {
    const labelValue = input.UserId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: UserId.");
    }
    resolvedPath = resolvedPath.replace("{UserId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: UserId.");
  }
  let body;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1GetUserSettingsCommand = serializeAws_restJson1GetUserSettingsCommand;
const serializeAws_restJson1GetVoiceConnectorCommand = async (input, context) => {
  const headers = {};
  let resolvedPath = "/voice-connectors/{VoiceConnectorId}";
  if (input.VoiceConnectorId !== undefined) {
    const labelValue = input.VoiceConnectorId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: VoiceConnectorId.");
    }
    resolvedPath = resolvedPath.replace("{VoiceConnectorId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: VoiceConnectorId.");
  }
  let body;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1GetVoiceConnectorCommand = serializeAws_restJson1GetVoiceConnectorCommand;
const serializeAws_restJson1GetVoiceConnectorEmergencyCallingConfigurationCommand = async (input, context) => {
  const headers = {};
  let resolvedPath = "/voice-connectors/{VoiceConnectorId}/emergency-calling-configuration";
  if (input.VoiceConnectorId !== undefined) {
    const labelValue = input.VoiceConnectorId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: VoiceConnectorId.");
    }
    resolvedPath = resolvedPath.replace("{VoiceConnectorId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: VoiceConnectorId.");
  }
  let body;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1GetVoiceConnectorEmergencyCallingConfigurationCommand =
  serializeAws_restJson1GetVoiceConnectorEmergencyCallingConfigurationCommand;
const serializeAws_restJson1GetVoiceConnectorGroupCommand = async (input, context) => {
  const headers = {};
  let resolvedPath = "/voice-connector-groups/{VoiceConnectorGroupId}";
  if (input.VoiceConnectorGroupId !== undefined) {
    const labelValue = input.VoiceConnectorGroupId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: VoiceConnectorGroupId.");
    }
    resolvedPath = resolvedPath.replace(
      "{VoiceConnectorGroupId}",
      smithy_client_1.extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: VoiceConnectorGroupId.");
  }
  let body;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1GetVoiceConnectorGroupCommand = serializeAws_restJson1GetVoiceConnectorGroupCommand;
const serializeAws_restJson1GetVoiceConnectorLoggingConfigurationCommand = async (input, context) => {
  const headers = {};
  let resolvedPath = "/voice-connectors/{VoiceConnectorId}/logging-configuration";
  if (input.VoiceConnectorId !== undefined) {
    const labelValue = input.VoiceConnectorId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: VoiceConnectorId.");
    }
    resolvedPath = resolvedPath.replace("{VoiceConnectorId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: VoiceConnectorId.");
  }
  let body;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1GetVoiceConnectorLoggingConfigurationCommand =
  serializeAws_restJson1GetVoiceConnectorLoggingConfigurationCommand;
const serializeAws_restJson1GetVoiceConnectorOriginationCommand = async (input, context) => {
  const headers = {};
  let resolvedPath = "/voice-connectors/{VoiceConnectorId}/origination";
  if (input.VoiceConnectorId !== undefined) {
    const labelValue = input.VoiceConnectorId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: VoiceConnectorId.");
    }
    resolvedPath = resolvedPath.replace("{VoiceConnectorId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: VoiceConnectorId.");
  }
  let body;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1GetVoiceConnectorOriginationCommand =
  serializeAws_restJson1GetVoiceConnectorOriginationCommand;
const serializeAws_restJson1GetVoiceConnectorProxyCommand = async (input, context) => {
  const headers = {};
  let resolvedPath = "/voice-connectors/{VoiceConnectorId}/programmable-numbers/proxy";
  if (input.VoiceConnectorId !== undefined) {
    const labelValue = input.VoiceConnectorId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: VoiceConnectorId.");
    }
    resolvedPath = resolvedPath.replace("{VoiceConnectorId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: VoiceConnectorId.");
  }
  let body;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1GetVoiceConnectorProxyCommand = serializeAws_restJson1GetVoiceConnectorProxyCommand;
const serializeAws_restJson1GetVoiceConnectorStreamingConfigurationCommand = async (input, context) => {
  const headers = {};
  let resolvedPath = "/voice-connectors/{VoiceConnectorId}/streaming-configuration";
  if (input.VoiceConnectorId !== undefined) {
    const labelValue = input.VoiceConnectorId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: VoiceConnectorId.");
    }
    resolvedPath = resolvedPath.replace("{VoiceConnectorId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: VoiceConnectorId.");
  }
  let body;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1GetVoiceConnectorStreamingConfigurationCommand =
  serializeAws_restJson1GetVoiceConnectorStreamingConfigurationCommand;
const serializeAws_restJson1GetVoiceConnectorTerminationCommand = async (input, context) => {
  const headers = {};
  let resolvedPath = "/voice-connectors/{VoiceConnectorId}/termination";
  if (input.VoiceConnectorId !== undefined) {
    const labelValue = input.VoiceConnectorId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: VoiceConnectorId.");
    }
    resolvedPath = resolvedPath.replace("{VoiceConnectorId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: VoiceConnectorId.");
  }
  let body;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1GetVoiceConnectorTerminationCommand =
  serializeAws_restJson1GetVoiceConnectorTerminationCommand;
const serializeAws_restJson1GetVoiceConnectorTerminationHealthCommand = async (input, context) => {
  const headers = {};
  let resolvedPath = "/voice-connectors/{VoiceConnectorId}/termination/health";
  if (input.VoiceConnectorId !== undefined) {
    const labelValue = input.VoiceConnectorId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: VoiceConnectorId.");
    }
    resolvedPath = resolvedPath.replace("{VoiceConnectorId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: VoiceConnectorId.");
  }
  let body;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1GetVoiceConnectorTerminationHealthCommand =
  serializeAws_restJson1GetVoiceConnectorTerminationHealthCommand;
const serializeAws_restJson1InviteUsersCommand = async (input, context) => {
  const headers = {
    "content-type": "application/json",
  };
  let resolvedPath = "/accounts/{AccountId}/users";
  if (input.AccountId !== undefined) {
    const labelValue = input.AccountId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AccountId.");
    }
    resolvedPath = resolvedPath.replace("{AccountId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: AccountId.");
  }
  const query = {
    operation: "add",
  };
  let body;
  body = JSON.stringify({
    ...(input.UserEmailList !== undefined &&
      input.UserEmailList !== null && {
        UserEmailList: serializeAws_restJson1UserEmailList(input.UserEmailList, context),
      }),
    ...(input.UserType !== undefined && input.UserType !== null && { UserType: input.UserType }),
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};
exports.serializeAws_restJson1InviteUsersCommand = serializeAws_restJson1InviteUsersCommand;
const serializeAws_restJson1ListAccountsCommand = async (input, context) => {
  const headers = {};
  let resolvedPath = "/accounts";
  const query = {
    ...(input.Name !== undefined && { name: input.Name }),
    ...(input.UserEmail !== undefined && { "user-email": input.UserEmail }),
    ...(input.NextToken !== undefined && { "next-token": input.NextToken }),
    ...(input.MaxResults !== undefined && { "max-results": input.MaxResults.toString() }),
  };
  let body;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};
exports.serializeAws_restJson1ListAccountsCommand = serializeAws_restJson1ListAccountsCommand;
const serializeAws_restJson1ListAppInstanceAdminsCommand = async (input, context) => {
  const headers = {};
  let resolvedPath = "/app-instances/{AppInstanceArn}/admins";
  if (input.AppInstanceArn !== undefined) {
    const labelValue = input.AppInstanceArn;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AppInstanceArn.");
    }
    resolvedPath = resolvedPath.replace("{AppInstanceArn}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: AppInstanceArn.");
  }
  const query = {
    ...(input.MaxResults !== undefined && { "max-results": input.MaxResults.toString() }),
    ...(input.NextToken !== undefined && { "next-token": input.NextToken }),
  };
  let body;
  let { hostname: resolvedHostname } = await context.endpoint();
  if (context.disableHostPrefix !== true) {
    resolvedHostname = "identity-" + resolvedHostname;
    if (!protocol_http_1.isValidHostname(resolvedHostname)) {
      throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
    }
  }
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname: resolvedHostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};
exports.serializeAws_restJson1ListAppInstanceAdminsCommand = serializeAws_restJson1ListAppInstanceAdminsCommand;
const serializeAws_restJson1ListAppInstancesCommand = async (input, context) => {
  const headers = {};
  let resolvedPath = "/app-instances";
  const query = {
    ...(input.MaxResults !== undefined && { "max-results": input.MaxResults.toString() }),
    ...(input.NextToken !== undefined && { "next-token": input.NextToken }),
  };
  let body;
  let { hostname: resolvedHostname } = await context.endpoint();
  if (context.disableHostPrefix !== true) {
    resolvedHostname = "identity-" + resolvedHostname;
    if (!protocol_http_1.isValidHostname(resolvedHostname)) {
      throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
    }
  }
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname: resolvedHostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};
exports.serializeAws_restJson1ListAppInstancesCommand = serializeAws_restJson1ListAppInstancesCommand;
const serializeAws_restJson1ListAppInstanceUsersCommand = async (input, context) => {
  const headers = {};
  let resolvedPath = "/app-instance-users";
  const query = {
    ...(input.AppInstanceArn !== undefined && { "app-instance-arn": input.AppInstanceArn }),
    ...(input.MaxResults !== undefined && { "max-results": input.MaxResults.toString() }),
    ...(input.NextToken !== undefined && { "next-token": input.NextToken }),
  };
  let body;
  let { hostname: resolvedHostname } = await context.endpoint();
  if (context.disableHostPrefix !== true) {
    resolvedHostname = "identity-" + resolvedHostname;
    if (!protocol_http_1.isValidHostname(resolvedHostname)) {
      throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
    }
  }
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname: resolvedHostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};
exports.serializeAws_restJson1ListAppInstanceUsersCommand = serializeAws_restJson1ListAppInstanceUsersCommand;
const serializeAws_restJson1ListAttendeesCommand = async (input, context) => {
  const headers = {};
  let resolvedPath = "/meetings/{MeetingId}/attendees";
  if (input.MeetingId !== undefined) {
    const labelValue = input.MeetingId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: MeetingId.");
    }
    resolvedPath = resolvedPath.replace("{MeetingId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: MeetingId.");
  }
  const query = {
    ...(input.NextToken !== undefined && { "next-token": input.NextToken }),
    ...(input.MaxResults !== undefined && { "max-results": input.MaxResults.toString() }),
  };
  let body;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};
exports.serializeAws_restJson1ListAttendeesCommand = serializeAws_restJson1ListAttendeesCommand;
const serializeAws_restJson1ListAttendeeTagsCommand = async (input, context) => {
  const headers = {};
  let resolvedPath = "/meetings/{MeetingId}/attendees/{AttendeeId}/tags";
  if (input.MeetingId !== undefined) {
    const labelValue = input.MeetingId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: MeetingId.");
    }
    resolvedPath = resolvedPath.replace("{MeetingId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: MeetingId.");
  }
  if (input.AttendeeId !== undefined) {
    const labelValue = input.AttendeeId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AttendeeId.");
    }
    resolvedPath = resolvedPath.replace("{AttendeeId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: AttendeeId.");
  }
  let body;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1ListAttendeeTagsCommand = serializeAws_restJson1ListAttendeeTagsCommand;
const serializeAws_restJson1ListBotsCommand = async (input, context) => {
  const headers = {};
  let resolvedPath = "/accounts/{AccountId}/bots";
  if (input.AccountId !== undefined) {
    const labelValue = input.AccountId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AccountId.");
    }
    resolvedPath = resolvedPath.replace("{AccountId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: AccountId.");
  }
  const query = {
    ...(input.MaxResults !== undefined && { "max-results": input.MaxResults.toString() }),
    ...(input.NextToken !== undefined && { "next-token": input.NextToken }),
  };
  let body;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};
exports.serializeAws_restJson1ListBotsCommand = serializeAws_restJson1ListBotsCommand;
const serializeAws_restJson1ListChannelBansCommand = async (input, context) => {
  const headers = {
    ...(isSerializableHeaderValue(input.ChimeBearer) && { "x-amz-chime-bearer": input.ChimeBearer }),
  };
  let resolvedPath = "/channels/{ChannelArn}/bans";
  if (input.ChannelArn !== undefined) {
    const labelValue = input.ChannelArn;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: ChannelArn.");
    }
    resolvedPath = resolvedPath.replace("{ChannelArn}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: ChannelArn.");
  }
  const query = {
    ...(input.MaxResults !== undefined && { "max-results": input.MaxResults.toString() }),
    ...(input.NextToken !== undefined && { "next-token": input.NextToken }),
  };
  let body;
  let { hostname: resolvedHostname } = await context.endpoint();
  if (context.disableHostPrefix !== true) {
    resolvedHostname = "messaging-" + resolvedHostname;
    if (!protocol_http_1.isValidHostname(resolvedHostname)) {
      throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
    }
  }
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname: resolvedHostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};
exports.serializeAws_restJson1ListChannelBansCommand = serializeAws_restJson1ListChannelBansCommand;
const serializeAws_restJson1ListChannelMembershipsCommand = async (input, context) => {
  const headers = {
    ...(isSerializableHeaderValue(input.ChimeBearer) && { "x-amz-chime-bearer": input.ChimeBearer }),
  };
  let resolvedPath = "/channels/{ChannelArn}/memberships";
  if (input.ChannelArn !== undefined) {
    const labelValue = input.ChannelArn;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: ChannelArn.");
    }
    resolvedPath = resolvedPath.replace("{ChannelArn}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: ChannelArn.");
  }
  const query = {
    ...(input.Type !== undefined && { type: input.Type }),
    ...(input.MaxResults !== undefined && { "max-results": input.MaxResults.toString() }),
    ...(input.NextToken !== undefined && { "next-token": input.NextToken }),
  };
  let body;
  let { hostname: resolvedHostname } = await context.endpoint();
  if (context.disableHostPrefix !== true) {
    resolvedHostname = "messaging-" + resolvedHostname;
    if (!protocol_http_1.isValidHostname(resolvedHostname)) {
      throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
    }
  }
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname: resolvedHostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};
exports.serializeAws_restJson1ListChannelMembershipsCommand = serializeAws_restJson1ListChannelMembershipsCommand;
const serializeAws_restJson1ListChannelMembershipsForAppInstanceUserCommand = async (input, context) => {
  const headers = {
    ...(isSerializableHeaderValue(input.ChimeBearer) && { "x-amz-chime-bearer": input.ChimeBearer }),
  };
  let resolvedPath = "/channels";
  const query = {
    scope: "app-instance-user-memberships",
    ...(input.AppInstanceUserArn !== undefined && { "app-instance-user-arn": input.AppInstanceUserArn }),
    ...(input.MaxResults !== undefined && { "max-results": input.MaxResults.toString() }),
    ...(input.NextToken !== undefined && { "next-token": input.NextToken }),
  };
  let body;
  let { hostname: resolvedHostname } = await context.endpoint();
  if (context.disableHostPrefix !== true) {
    resolvedHostname = "messaging-" + resolvedHostname;
    if (!protocol_http_1.isValidHostname(resolvedHostname)) {
      throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
    }
  }
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname: resolvedHostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};
exports.serializeAws_restJson1ListChannelMembershipsForAppInstanceUserCommand =
  serializeAws_restJson1ListChannelMembershipsForAppInstanceUserCommand;
const serializeAws_restJson1ListChannelMessagesCommand = async (input, context) => {
  const headers = {
    ...(isSerializableHeaderValue(input.ChimeBearer) && { "x-amz-chime-bearer": input.ChimeBearer }),
  };
  let resolvedPath = "/channels/{ChannelArn}/messages";
  if (input.ChannelArn !== undefined) {
    const labelValue = input.ChannelArn;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: ChannelArn.");
    }
    resolvedPath = resolvedPath.replace("{ChannelArn}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: ChannelArn.");
  }
  const query = {
    ...(input.SortOrder !== undefined && { "sort-order": input.SortOrder }),
    ...(input.NotBefore !== undefined && {
      "not-before": (input.NotBefore.toISOString().split(".")[0] + "Z").toString(),
    }),
    ...(input.NotAfter !== undefined && { "not-after": (input.NotAfter.toISOString().split(".")[0] + "Z").toString() }),
    ...(input.MaxResults !== undefined && { "max-results": input.MaxResults.toString() }),
    ...(input.NextToken !== undefined && { "next-token": input.NextToken }),
  };
  let body;
  let { hostname: resolvedHostname } = await context.endpoint();
  if (context.disableHostPrefix !== true) {
    resolvedHostname = "messaging-" + resolvedHostname;
    if (!protocol_http_1.isValidHostname(resolvedHostname)) {
      throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
    }
  }
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname: resolvedHostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};
exports.serializeAws_restJson1ListChannelMessagesCommand = serializeAws_restJson1ListChannelMessagesCommand;
const serializeAws_restJson1ListChannelModeratorsCommand = async (input, context) => {
  const headers = {
    ...(isSerializableHeaderValue(input.ChimeBearer) && { "x-amz-chime-bearer": input.ChimeBearer }),
  };
  let resolvedPath = "/channels/{ChannelArn}/moderators";
  if (input.ChannelArn !== undefined) {
    const labelValue = input.ChannelArn;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: ChannelArn.");
    }
    resolvedPath = resolvedPath.replace("{ChannelArn}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: ChannelArn.");
  }
  const query = {
    ...(input.MaxResults !== undefined && { "max-results": input.MaxResults.toString() }),
    ...(input.NextToken !== undefined && { "next-token": input.NextToken }),
  };
  let body;
  let { hostname: resolvedHostname } = await context.endpoint();
  if (context.disableHostPrefix !== true) {
    resolvedHostname = "messaging-" + resolvedHostname;
    if (!protocol_http_1.isValidHostname(resolvedHostname)) {
      throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
    }
  }
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname: resolvedHostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};
exports.serializeAws_restJson1ListChannelModeratorsCommand = serializeAws_restJson1ListChannelModeratorsCommand;
const serializeAws_restJson1ListChannelsCommand = async (input, context) => {
  const headers = {
    ...(isSerializableHeaderValue(input.ChimeBearer) && { "x-amz-chime-bearer": input.ChimeBearer }),
  };
  let resolvedPath = "/channels";
  const query = {
    ...(input.AppInstanceArn !== undefined && { "app-instance-arn": input.AppInstanceArn }),
    ...(input.Privacy !== undefined && { privacy: input.Privacy }),
    ...(input.MaxResults !== undefined && { "max-results": input.MaxResults.toString() }),
    ...(input.NextToken !== undefined && { "next-token": input.NextToken }),
  };
  let body;
  let { hostname: resolvedHostname } = await context.endpoint();
  if (context.disableHostPrefix !== true) {
    resolvedHostname = "messaging-" + resolvedHostname;
    if (!protocol_http_1.isValidHostname(resolvedHostname)) {
      throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
    }
  }
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname: resolvedHostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};
exports.serializeAws_restJson1ListChannelsCommand = serializeAws_restJson1ListChannelsCommand;
const serializeAws_restJson1ListChannelsModeratedByAppInstanceUserCommand = async (input, context) => {
  const headers = {
    ...(isSerializableHeaderValue(input.ChimeBearer) && { "x-amz-chime-bearer": input.ChimeBearer }),
  };
  let resolvedPath = "/channels";
  const query = {
    scope: "app-instance-user-moderated-channels",
    ...(input.AppInstanceUserArn !== undefined && { "app-instance-user-arn": input.AppInstanceUserArn }),
    ...(input.MaxResults !== undefined && { "max-results": input.MaxResults.toString() }),
    ...(input.NextToken !== undefined && { "next-token": input.NextToken }),
  };
  let body;
  let { hostname: resolvedHostname } = await context.endpoint();
  if (context.disableHostPrefix !== true) {
    resolvedHostname = "messaging-" + resolvedHostname;
    if (!protocol_http_1.isValidHostname(resolvedHostname)) {
      throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
    }
  }
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname: resolvedHostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};
exports.serializeAws_restJson1ListChannelsModeratedByAppInstanceUserCommand =
  serializeAws_restJson1ListChannelsModeratedByAppInstanceUserCommand;
const serializeAws_restJson1ListMeetingsCommand = async (input, context) => {
  const headers = {};
  let resolvedPath = "/meetings";
  const query = {
    ...(input.NextToken !== undefined && { "next-token": input.NextToken }),
    ...(input.MaxResults !== undefined && { "max-results": input.MaxResults.toString() }),
  };
  let body;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};
exports.serializeAws_restJson1ListMeetingsCommand = serializeAws_restJson1ListMeetingsCommand;
const serializeAws_restJson1ListMeetingTagsCommand = async (input, context) => {
  const headers = {};
  let resolvedPath = "/meetings/{MeetingId}/tags";
  if (input.MeetingId !== undefined) {
    const labelValue = input.MeetingId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: MeetingId.");
    }
    resolvedPath = resolvedPath.replace("{MeetingId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: MeetingId.");
  }
  let body;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1ListMeetingTagsCommand = serializeAws_restJson1ListMeetingTagsCommand;
const serializeAws_restJson1ListPhoneNumberOrdersCommand = async (input, context) => {
  const headers = {};
  let resolvedPath = "/phone-number-orders";
  const query = {
    ...(input.NextToken !== undefined && { "next-token": input.NextToken }),
    ...(input.MaxResults !== undefined && { "max-results": input.MaxResults.toString() }),
  };
  let body;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};
exports.serializeAws_restJson1ListPhoneNumberOrdersCommand = serializeAws_restJson1ListPhoneNumberOrdersCommand;
const serializeAws_restJson1ListPhoneNumbersCommand = async (input, context) => {
  const headers = {};
  let resolvedPath = "/phone-numbers";
  const query = {
    ...(input.Status !== undefined && { status: input.Status }),
    ...(input.ProductType !== undefined && { "product-type": input.ProductType }),
    ...(input.FilterName !== undefined && { "filter-name": input.FilterName }),
    ...(input.FilterValue !== undefined && { "filter-value": input.FilterValue }),
    ...(input.MaxResults !== undefined && { "max-results": input.MaxResults.toString() }),
    ...(input.NextToken !== undefined && { "next-token": input.NextToken }),
  };
  let body;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};
exports.serializeAws_restJson1ListPhoneNumbersCommand = serializeAws_restJson1ListPhoneNumbersCommand;
const serializeAws_restJson1ListProxySessionsCommand = async (input, context) => {
  const headers = {};
  let resolvedPath = "/voice-connectors/{VoiceConnectorId}/proxy-sessions";
  if (input.VoiceConnectorId !== undefined) {
    const labelValue = input.VoiceConnectorId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: VoiceConnectorId.");
    }
    resolvedPath = resolvedPath.replace("{VoiceConnectorId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: VoiceConnectorId.");
  }
  const query = {
    ...(input.Status !== undefined && { status: input.Status }),
    ...(input.NextToken !== undefined && { "next-token": input.NextToken }),
    ...(input.MaxResults !== undefined && { "max-results": input.MaxResults.toString() }),
  };
  let body;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};
exports.serializeAws_restJson1ListProxySessionsCommand = serializeAws_restJson1ListProxySessionsCommand;
const serializeAws_restJson1ListRoomMembershipsCommand = async (input, context) => {
  const headers = {};
  let resolvedPath = "/accounts/{AccountId}/rooms/{RoomId}/memberships";
  if (input.AccountId !== undefined) {
    const labelValue = input.AccountId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AccountId.");
    }
    resolvedPath = resolvedPath.replace("{AccountId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: AccountId.");
  }
  if (input.RoomId !== undefined) {
    const labelValue = input.RoomId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: RoomId.");
    }
    resolvedPath = resolvedPath.replace("{RoomId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: RoomId.");
  }
  const query = {
    ...(input.MaxResults !== undefined && { "max-results": input.MaxResults.toString() }),
    ...(input.NextToken !== undefined && { "next-token": input.NextToken }),
  };
  let body;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};
exports.serializeAws_restJson1ListRoomMembershipsCommand = serializeAws_restJson1ListRoomMembershipsCommand;
const serializeAws_restJson1ListRoomsCommand = async (input, context) => {
  const headers = {};
  let resolvedPath = "/accounts/{AccountId}/rooms";
  if (input.AccountId !== undefined) {
    const labelValue = input.AccountId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AccountId.");
    }
    resolvedPath = resolvedPath.replace("{AccountId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: AccountId.");
  }
  const query = {
    ...(input.MemberId !== undefined && { "member-id": input.MemberId }),
    ...(input.MaxResults !== undefined && { "max-results": input.MaxResults.toString() }),
    ...(input.NextToken !== undefined && { "next-token": input.NextToken }),
  };
  let body;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};
exports.serializeAws_restJson1ListRoomsCommand = serializeAws_restJson1ListRoomsCommand;
const serializeAws_restJson1ListSipMediaApplicationsCommand = async (input, context) => {
  const headers = {};
  let resolvedPath = "/sip-media-applications";
  const query = {
    ...(input.MaxResults !== undefined && { "max-results": input.MaxResults.toString() }),
    ...(input.NextToken !== undefined && { "next-token": input.NextToken }),
  };
  let body;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};
exports.serializeAws_restJson1ListSipMediaApplicationsCommand = serializeAws_restJson1ListSipMediaApplicationsCommand;
const serializeAws_restJson1ListSipRulesCommand = async (input, context) => {
  const headers = {};
  let resolvedPath = "/sip-rules";
  const query = {
    ...(input.SipMediaApplicationId !== undefined && { "sip-media-application": input.SipMediaApplicationId }),
    ...(input.MaxResults !== undefined && { "max-results": input.MaxResults.toString() }),
    ...(input.NextToken !== undefined && { "next-token": input.NextToken }),
  };
  let body;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};
exports.serializeAws_restJson1ListSipRulesCommand = serializeAws_restJson1ListSipRulesCommand;
const serializeAws_restJson1ListSupportedPhoneNumberCountriesCommand = async (input, context) => {
  const headers = {};
  let resolvedPath = "/phone-number-countries";
  const query = {
    ...(input.ProductType !== undefined && { "product-type": input.ProductType }),
  };
  let body;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};
exports.serializeAws_restJson1ListSupportedPhoneNumberCountriesCommand =
  serializeAws_restJson1ListSupportedPhoneNumberCountriesCommand;
const serializeAws_restJson1ListTagsForResourceCommand = async (input, context) => {
  const headers = {};
  let resolvedPath = "/tags";
  const query = {
    ...(input.ResourceARN !== undefined && { arn: input.ResourceARN }),
  };
  let body;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};
exports.serializeAws_restJson1ListTagsForResourceCommand = serializeAws_restJson1ListTagsForResourceCommand;
const serializeAws_restJson1ListUsersCommand = async (input, context) => {
  const headers = {};
  let resolvedPath = "/accounts/{AccountId}/users";
  if (input.AccountId !== undefined) {
    const labelValue = input.AccountId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AccountId.");
    }
    resolvedPath = resolvedPath.replace("{AccountId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: AccountId.");
  }
  const query = {
    ...(input.UserEmail !== undefined && { "user-email": input.UserEmail }),
    ...(input.UserType !== undefined && { "user-type": input.UserType }),
    ...(input.MaxResults !== undefined && { "max-results": input.MaxResults.toString() }),
    ...(input.NextToken !== undefined && { "next-token": input.NextToken }),
  };
  let body;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};
exports.serializeAws_restJson1ListUsersCommand = serializeAws_restJson1ListUsersCommand;
const serializeAws_restJson1ListVoiceConnectorGroupsCommand = async (input, context) => {
  const headers = {};
  let resolvedPath = "/voice-connector-groups";
  const query = {
    ...(input.NextToken !== undefined && { "next-token": input.NextToken }),
    ...(input.MaxResults !== undefined && { "max-results": input.MaxResults.toString() }),
  };
  let body;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};
exports.serializeAws_restJson1ListVoiceConnectorGroupsCommand = serializeAws_restJson1ListVoiceConnectorGroupsCommand;
const serializeAws_restJson1ListVoiceConnectorsCommand = async (input, context) => {
  const headers = {};
  let resolvedPath = "/voice-connectors";
  const query = {
    ...(input.NextToken !== undefined && { "next-token": input.NextToken }),
    ...(input.MaxResults !== undefined && { "max-results": input.MaxResults.toString() }),
  };
  let body;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};
exports.serializeAws_restJson1ListVoiceConnectorsCommand = serializeAws_restJson1ListVoiceConnectorsCommand;
const serializeAws_restJson1ListVoiceConnectorTerminationCredentialsCommand = async (input, context) => {
  const headers = {};
  let resolvedPath = "/voice-connectors/{VoiceConnectorId}/termination/credentials";
  if (input.VoiceConnectorId !== undefined) {
    const labelValue = input.VoiceConnectorId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: VoiceConnectorId.");
    }
    resolvedPath = resolvedPath.replace("{VoiceConnectorId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: VoiceConnectorId.");
  }
  let body;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1ListVoiceConnectorTerminationCredentialsCommand =
  serializeAws_restJson1ListVoiceConnectorTerminationCredentialsCommand;
const serializeAws_restJson1LogoutUserCommand = async (input, context) => {
  const headers = {};
  let resolvedPath = "/accounts/{AccountId}/users/{UserId}";
  if (input.AccountId !== undefined) {
    const labelValue = input.AccountId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AccountId.");
    }
    resolvedPath = resolvedPath.replace("{AccountId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: AccountId.");
  }
  if (input.UserId !== undefined) {
    const labelValue = input.UserId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: UserId.");
    }
    resolvedPath = resolvedPath.replace("{UserId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: UserId.");
  }
  const query = {
    operation: "logout",
  };
  let body;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};
exports.serializeAws_restJson1LogoutUserCommand = serializeAws_restJson1LogoutUserCommand;
const serializeAws_restJson1PutAppInstanceRetentionSettingsCommand = async (input, context) => {
  const headers = {
    "content-type": "application/json",
  };
  let resolvedPath = "/app-instances/{AppInstanceArn}/retention-settings";
  if (input.AppInstanceArn !== undefined) {
    const labelValue = input.AppInstanceArn;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AppInstanceArn.");
    }
    resolvedPath = resolvedPath.replace("{AppInstanceArn}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: AppInstanceArn.");
  }
  let body;
  body = JSON.stringify({
    ...(input.AppInstanceRetentionSettings !== undefined &&
      input.AppInstanceRetentionSettings !== null && {
        AppInstanceRetentionSettings: serializeAws_restJson1AppInstanceRetentionSettings(
          input.AppInstanceRetentionSettings,
          context
        ),
      }),
  });
  let { hostname: resolvedHostname } = await context.endpoint();
  if (context.disableHostPrefix !== true) {
    resolvedHostname = "identity-" + resolvedHostname;
    if (!protocol_http_1.isValidHostname(resolvedHostname)) {
      throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
    }
  }
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname: resolvedHostname,
    port,
    method: "PUT",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1PutAppInstanceRetentionSettingsCommand =
  serializeAws_restJson1PutAppInstanceRetentionSettingsCommand;
const serializeAws_restJson1PutAppInstanceStreamingConfigurationsCommand = async (input, context) => {
  const headers = {
    "content-type": "application/json",
  };
  let resolvedPath = "/app-instances/{AppInstanceArn}/streaming-configurations";
  if (input.AppInstanceArn !== undefined) {
    const labelValue = input.AppInstanceArn;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AppInstanceArn.");
    }
    resolvedPath = resolvedPath.replace("{AppInstanceArn}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: AppInstanceArn.");
  }
  let body;
  body = JSON.stringify({
    ...(input.AppInstanceStreamingConfigurations !== undefined &&
      input.AppInstanceStreamingConfigurations !== null && {
        AppInstanceStreamingConfigurations: serializeAws_restJson1AppInstanceStreamingConfigurationList(
          input.AppInstanceStreamingConfigurations,
          context
        ),
      }),
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "PUT",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1PutAppInstanceStreamingConfigurationsCommand =
  serializeAws_restJson1PutAppInstanceStreamingConfigurationsCommand;
const serializeAws_restJson1PutEventsConfigurationCommand = async (input, context) => {
  const headers = {
    "content-type": "application/json",
  };
  let resolvedPath = "/accounts/{AccountId}/bots/{BotId}/events-configuration";
  if (input.AccountId !== undefined) {
    const labelValue = input.AccountId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AccountId.");
    }
    resolvedPath = resolvedPath.replace("{AccountId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: AccountId.");
  }
  if (input.BotId !== undefined) {
    const labelValue = input.BotId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: BotId.");
    }
    resolvedPath = resolvedPath.replace("{BotId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: BotId.");
  }
  let body;
  body = JSON.stringify({
    ...(input.LambdaFunctionArn !== undefined &&
      input.LambdaFunctionArn !== null && { LambdaFunctionArn: input.LambdaFunctionArn }),
    ...(input.OutboundEventsHTTPSEndpoint !== undefined &&
      input.OutboundEventsHTTPSEndpoint !== null && { OutboundEventsHTTPSEndpoint: input.OutboundEventsHTTPSEndpoint }),
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "PUT",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1PutEventsConfigurationCommand = serializeAws_restJson1PutEventsConfigurationCommand;
const serializeAws_restJson1PutRetentionSettingsCommand = async (input, context) => {
  const headers = {
    "content-type": "application/json",
  };
  let resolvedPath = "/accounts/{AccountId}/retention-settings";
  if (input.AccountId !== undefined) {
    const labelValue = input.AccountId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AccountId.");
    }
    resolvedPath = resolvedPath.replace("{AccountId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: AccountId.");
  }
  let body;
  body = JSON.stringify({
    ...(input.RetentionSettings !== undefined &&
      input.RetentionSettings !== null && {
        RetentionSettings: serializeAws_restJson1RetentionSettings(input.RetentionSettings, context),
      }),
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "PUT",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1PutRetentionSettingsCommand = serializeAws_restJson1PutRetentionSettingsCommand;
const serializeAws_restJson1PutSipMediaApplicationLoggingConfigurationCommand = async (input, context) => {
  const headers = {
    "content-type": "application/json",
  };
  let resolvedPath = "/sip-media-applications/{SipMediaApplicationId}/logging-configuration";
  if (input.SipMediaApplicationId !== undefined) {
    const labelValue = input.SipMediaApplicationId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: SipMediaApplicationId.");
    }
    resolvedPath = resolvedPath.replace(
      "{SipMediaApplicationId}",
      smithy_client_1.extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: SipMediaApplicationId.");
  }
  let body;
  body = JSON.stringify({
    ...(input.SipMediaApplicationLoggingConfiguration !== undefined &&
      input.SipMediaApplicationLoggingConfiguration !== null && {
        SipMediaApplicationLoggingConfiguration: serializeAws_restJson1SipMediaApplicationLoggingConfiguration(
          input.SipMediaApplicationLoggingConfiguration,
          context
        ),
      }),
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "PUT",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1PutSipMediaApplicationLoggingConfigurationCommand =
  serializeAws_restJson1PutSipMediaApplicationLoggingConfigurationCommand;
const serializeAws_restJson1PutVoiceConnectorEmergencyCallingConfigurationCommand = async (input, context) => {
  const headers = {
    "content-type": "application/json",
  };
  let resolvedPath = "/voice-connectors/{VoiceConnectorId}/emergency-calling-configuration";
  if (input.VoiceConnectorId !== undefined) {
    const labelValue = input.VoiceConnectorId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: VoiceConnectorId.");
    }
    resolvedPath = resolvedPath.replace("{VoiceConnectorId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: VoiceConnectorId.");
  }
  let body;
  body = JSON.stringify({
    ...(input.EmergencyCallingConfiguration !== undefined &&
      input.EmergencyCallingConfiguration !== null && {
        EmergencyCallingConfiguration: serializeAws_restJson1EmergencyCallingConfiguration(
          input.EmergencyCallingConfiguration,
          context
        ),
      }),
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "PUT",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1PutVoiceConnectorEmergencyCallingConfigurationCommand =
  serializeAws_restJson1PutVoiceConnectorEmergencyCallingConfigurationCommand;
const serializeAws_restJson1PutVoiceConnectorLoggingConfigurationCommand = async (input, context) => {
  const headers = {
    "content-type": "application/json",
  };
  let resolvedPath = "/voice-connectors/{VoiceConnectorId}/logging-configuration";
  if (input.VoiceConnectorId !== undefined) {
    const labelValue = input.VoiceConnectorId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: VoiceConnectorId.");
    }
    resolvedPath = resolvedPath.replace("{VoiceConnectorId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: VoiceConnectorId.");
  }
  let body;
  body = JSON.stringify({
    ...(input.LoggingConfiguration !== undefined &&
      input.LoggingConfiguration !== null && {
        LoggingConfiguration: serializeAws_restJson1LoggingConfiguration(input.LoggingConfiguration, context),
      }),
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "PUT",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1PutVoiceConnectorLoggingConfigurationCommand =
  serializeAws_restJson1PutVoiceConnectorLoggingConfigurationCommand;
const serializeAws_restJson1PutVoiceConnectorOriginationCommand = async (input, context) => {
  const headers = {
    "content-type": "application/json",
  };
  let resolvedPath = "/voice-connectors/{VoiceConnectorId}/origination";
  if (input.VoiceConnectorId !== undefined) {
    const labelValue = input.VoiceConnectorId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: VoiceConnectorId.");
    }
    resolvedPath = resolvedPath.replace("{VoiceConnectorId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: VoiceConnectorId.");
  }
  let body;
  body = JSON.stringify({
    ...(input.Origination !== undefined &&
      input.Origination !== null && { Origination: serializeAws_restJson1Origination(input.Origination, context) }),
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "PUT",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1PutVoiceConnectorOriginationCommand =
  serializeAws_restJson1PutVoiceConnectorOriginationCommand;
const serializeAws_restJson1PutVoiceConnectorProxyCommand = async (input, context) => {
  const headers = {
    "content-type": "application/json",
  };
  let resolvedPath = "/voice-connectors/{VoiceConnectorId}/programmable-numbers/proxy";
  if (input.VoiceConnectorId !== undefined) {
    const labelValue = input.VoiceConnectorId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: VoiceConnectorId.");
    }
    resolvedPath = resolvedPath.replace("{VoiceConnectorId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: VoiceConnectorId.");
  }
  let body;
  body = JSON.stringify({
    ...(input.DefaultSessionExpiryMinutes !== undefined &&
      input.DefaultSessionExpiryMinutes !== null && { DefaultSessionExpiryMinutes: input.DefaultSessionExpiryMinutes }),
    ...(input.Disabled !== undefined && input.Disabled !== null && { Disabled: input.Disabled }),
    ...(input.FallBackPhoneNumber !== undefined &&
      input.FallBackPhoneNumber !== null && { FallBackPhoneNumber: input.FallBackPhoneNumber }),
    ...(input.PhoneNumberPoolCountries !== undefined &&
      input.PhoneNumberPoolCountries !== null && {
        PhoneNumberPoolCountries: serializeAws_restJson1CountryList(input.PhoneNumberPoolCountries, context),
      }),
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "PUT",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1PutVoiceConnectorProxyCommand = serializeAws_restJson1PutVoiceConnectorProxyCommand;
const serializeAws_restJson1PutVoiceConnectorStreamingConfigurationCommand = async (input, context) => {
  const headers = {
    "content-type": "application/json",
  };
  let resolvedPath = "/voice-connectors/{VoiceConnectorId}/streaming-configuration";
  if (input.VoiceConnectorId !== undefined) {
    const labelValue = input.VoiceConnectorId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: VoiceConnectorId.");
    }
    resolvedPath = resolvedPath.replace("{VoiceConnectorId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: VoiceConnectorId.");
  }
  let body;
  body = JSON.stringify({
    ...(input.StreamingConfiguration !== undefined &&
      input.StreamingConfiguration !== null && {
        StreamingConfiguration: serializeAws_restJson1StreamingConfiguration(input.StreamingConfiguration, context),
      }),
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "PUT",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1PutVoiceConnectorStreamingConfigurationCommand =
  serializeAws_restJson1PutVoiceConnectorStreamingConfigurationCommand;
const serializeAws_restJson1PutVoiceConnectorTerminationCommand = async (input, context) => {
  const headers = {
    "content-type": "application/json",
  };
  let resolvedPath = "/voice-connectors/{VoiceConnectorId}/termination";
  if (input.VoiceConnectorId !== undefined) {
    const labelValue = input.VoiceConnectorId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: VoiceConnectorId.");
    }
    resolvedPath = resolvedPath.replace("{VoiceConnectorId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: VoiceConnectorId.");
  }
  let body;
  body = JSON.stringify({
    ...(input.Termination !== undefined &&
      input.Termination !== null && { Termination: serializeAws_restJson1Termination(input.Termination, context) }),
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "PUT",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1PutVoiceConnectorTerminationCommand =
  serializeAws_restJson1PutVoiceConnectorTerminationCommand;
const serializeAws_restJson1PutVoiceConnectorTerminationCredentialsCommand = async (input, context) => {
  const headers = {
    "content-type": "application/json",
  };
  let resolvedPath = "/voice-connectors/{VoiceConnectorId}/termination/credentials";
  if (input.VoiceConnectorId !== undefined) {
    const labelValue = input.VoiceConnectorId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: VoiceConnectorId.");
    }
    resolvedPath = resolvedPath.replace("{VoiceConnectorId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: VoiceConnectorId.");
  }
  const query = {
    operation: "put",
  };
  let body;
  body = JSON.stringify({
    ...(input.Credentials !== undefined &&
      input.Credentials !== null && { Credentials: serializeAws_restJson1CredentialList(input.Credentials, context) }),
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};
exports.serializeAws_restJson1PutVoiceConnectorTerminationCredentialsCommand =
  serializeAws_restJson1PutVoiceConnectorTerminationCredentialsCommand;
const serializeAws_restJson1RedactChannelMessageCommand = async (input, context) => {
  const headers = {
    ...(isSerializableHeaderValue(input.ChimeBearer) && { "x-amz-chime-bearer": input.ChimeBearer }),
  };
  let resolvedPath = "/channels/{ChannelArn}/messages/{MessageId}";
  if (input.ChannelArn !== undefined) {
    const labelValue = input.ChannelArn;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: ChannelArn.");
    }
    resolvedPath = resolvedPath.replace("{ChannelArn}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: ChannelArn.");
  }
  if (input.MessageId !== undefined) {
    const labelValue = input.MessageId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: MessageId.");
    }
    resolvedPath = resolvedPath.replace("{MessageId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: MessageId.");
  }
  const query = {
    operation: "redact",
  };
  let body;
  let { hostname: resolvedHostname } = await context.endpoint();
  if (context.disableHostPrefix !== true) {
    resolvedHostname = "messaging-" + resolvedHostname;
    if (!protocol_http_1.isValidHostname(resolvedHostname)) {
      throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
    }
  }
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname: resolvedHostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};
exports.serializeAws_restJson1RedactChannelMessageCommand = serializeAws_restJson1RedactChannelMessageCommand;
const serializeAws_restJson1RedactConversationMessageCommand = async (input, context) => {
  const headers = {};
  let resolvedPath = "/accounts/{AccountId}/conversations/{ConversationId}/messages/{MessageId}";
  if (input.AccountId !== undefined) {
    const labelValue = input.AccountId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AccountId.");
    }
    resolvedPath = resolvedPath.replace("{AccountId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: AccountId.");
  }
  if (input.ConversationId !== undefined) {
    const labelValue = input.ConversationId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: ConversationId.");
    }
    resolvedPath = resolvedPath.replace("{ConversationId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: ConversationId.");
  }
  if (input.MessageId !== undefined) {
    const labelValue = input.MessageId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: MessageId.");
    }
    resolvedPath = resolvedPath.replace("{MessageId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: MessageId.");
  }
  const query = {
    operation: "redact",
  };
  let body;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};
exports.serializeAws_restJson1RedactConversationMessageCommand = serializeAws_restJson1RedactConversationMessageCommand;
const serializeAws_restJson1RedactRoomMessageCommand = async (input, context) => {
  const headers = {};
  let resolvedPath = "/accounts/{AccountId}/rooms/{RoomId}/messages/{MessageId}";
  if (input.AccountId !== undefined) {
    const labelValue = input.AccountId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AccountId.");
    }
    resolvedPath = resolvedPath.replace("{AccountId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: AccountId.");
  }
  if (input.RoomId !== undefined) {
    const labelValue = input.RoomId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: RoomId.");
    }
    resolvedPath = resolvedPath.replace("{RoomId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: RoomId.");
  }
  if (input.MessageId !== undefined) {
    const labelValue = input.MessageId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: MessageId.");
    }
    resolvedPath = resolvedPath.replace("{MessageId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: MessageId.");
  }
  const query = {
    operation: "redact",
  };
  let body;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};
exports.serializeAws_restJson1RedactRoomMessageCommand = serializeAws_restJson1RedactRoomMessageCommand;
const serializeAws_restJson1RegenerateSecurityTokenCommand = async (input, context) => {
  const headers = {};
  let resolvedPath = "/accounts/{AccountId}/bots/{BotId}";
  if (input.AccountId !== undefined) {
    const labelValue = input.AccountId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AccountId.");
    }
    resolvedPath = resolvedPath.replace("{AccountId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: AccountId.");
  }
  if (input.BotId !== undefined) {
    const labelValue = input.BotId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: BotId.");
    }
    resolvedPath = resolvedPath.replace("{BotId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: BotId.");
  }
  const query = {
    operation: "regenerate-security-token",
  };
  let body;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};
exports.serializeAws_restJson1RegenerateSecurityTokenCommand = serializeAws_restJson1RegenerateSecurityTokenCommand;
const serializeAws_restJson1ResetPersonalPINCommand = async (input, context) => {
  const headers = {};
  let resolvedPath = "/accounts/{AccountId}/users/{UserId}";
  if (input.AccountId !== undefined) {
    const labelValue = input.AccountId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AccountId.");
    }
    resolvedPath = resolvedPath.replace("{AccountId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: AccountId.");
  }
  if (input.UserId !== undefined) {
    const labelValue = input.UserId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: UserId.");
    }
    resolvedPath = resolvedPath.replace("{UserId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: UserId.");
  }
  const query = {
    operation: "reset-personal-pin",
  };
  let body;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};
exports.serializeAws_restJson1ResetPersonalPINCommand = serializeAws_restJson1ResetPersonalPINCommand;
const serializeAws_restJson1RestorePhoneNumberCommand = async (input, context) => {
  const headers = {};
  let resolvedPath = "/phone-numbers/{PhoneNumberId}";
  if (input.PhoneNumberId !== undefined) {
    const labelValue = input.PhoneNumberId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: PhoneNumberId.");
    }
    resolvedPath = resolvedPath.replace("{PhoneNumberId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: PhoneNumberId.");
  }
  const query = {
    operation: "restore",
  };
  let body;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};
exports.serializeAws_restJson1RestorePhoneNumberCommand = serializeAws_restJson1RestorePhoneNumberCommand;
const serializeAws_restJson1SearchAvailablePhoneNumbersCommand = async (input, context) => {
  const headers = {};
  let resolvedPath = "/search";
  const query = {
    type: "phone-numbers",
    ...(input.AreaCode !== undefined && { "area-code": input.AreaCode }),
    ...(input.City !== undefined && { city: input.City }),
    ...(input.Country !== undefined && { country: input.Country }),
    ...(input.State !== undefined && { state: input.State }),
    ...(input.TollFreePrefix !== undefined && { "toll-free-prefix": input.TollFreePrefix }),
    ...(input.PhoneNumberType !== undefined && { "phone-number-type": input.PhoneNumberType }),
    ...(input.MaxResults !== undefined && { "max-results": input.MaxResults.toString() }),
    ...(input.NextToken !== undefined && { "next-token": input.NextToken }),
  };
  let body;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};
exports.serializeAws_restJson1SearchAvailablePhoneNumbersCommand =
  serializeAws_restJson1SearchAvailablePhoneNumbersCommand;
const serializeAws_restJson1SendChannelMessageCommand = async (input, context) => {
  var _a;
  const headers = {
    "content-type": "application/json",
    ...(isSerializableHeaderValue(input.ChimeBearer) && { "x-amz-chime-bearer": input.ChimeBearer }),
  };
  let resolvedPath = "/channels/{ChannelArn}/messages";
  if (input.ChannelArn !== undefined) {
    const labelValue = input.ChannelArn;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: ChannelArn.");
    }
    resolvedPath = resolvedPath.replace("{ChannelArn}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: ChannelArn.");
  }
  let body;
  body = JSON.stringify({
    ClientRequestToken: (_a = input.ClientRequestToken) !== null && _a !== void 0 ? _a : uuid_1.v4(),
    ...(input.Content !== undefined && input.Content !== null && { Content: input.Content }),
    ...(input.Metadata !== undefined && input.Metadata !== null && { Metadata: input.Metadata }),
    ...(input.Persistence !== undefined && input.Persistence !== null && { Persistence: input.Persistence }),
    ...(input.Type !== undefined && input.Type !== null && { Type: input.Type }),
  });
  let { hostname: resolvedHostname } = await context.endpoint();
  if (context.disableHostPrefix !== true) {
    resolvedHostname = "messaging-" + resolvedHostname;
    if (!protocol_http_1.isValidHostname(resolvedHostname)) {
      throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
    }
  }
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname: resolvedHostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1SendChannelMessageCommand = serializeAws_restJson1SendChannelMessageCommand;
const serializeAws_restJson1TagAttendeeCommand = async (input, context) => {
  const headers = {
    "content-type": "application/json",
  };
  let resolvedPath = "/meetings/{MeetingId}/attendees/{AttendeeId}/tags";
  if (input.MeetingId !== undefined) {
    const labelValue = input.MeetingId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: MeetingId.");
    }
    resolvedPath = resolvedPath.replace("{MeetingId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: MeetingId.");
  }
  if (input.AttendeeId !== undefined) {
    const labelValue = input.AttendeeId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AttendeeId.");
    }
    resolvedPath = resolvedPath.replace("{AttendeeId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: AttendeeId.");
  }
  const query = {
    operation: "add",
  };
  let body;
  body = JSON.stringify({
    ...(input.Tags !== undefined &&
      input.Tags !== null && { Tags: serializeAws_restJson1AttendeeTagList(input.Tags, context) }),
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};
exports.serializeAws_restJson1TagAttendeeCommand = serializeAws_restJson1TagAttendeeCommand;
const serializeAws_restJson1TagMeetingCommand = async (input, context) => {
  const headers = {
    "content-type": "application/json",
  };
  let resolvedPath = "/meetings/{MeetingId}/tags";
  if (input.MeetingId !== undefined) {
    const labelValue = input.MeetingId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: MeetingId.");
    }
    resolvedPath = resolvedPath.replace("{MeetingId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: MeetingId.");
  }
  const query = {
    operation: "add",
  };
  let body;
  body = JSON.stringify({
    ...(input.Tags !== undefined &&
      input.Tags !== null && { Tags: serializeAws_restJson1MeetingTagList(input.Tags, context) }),
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};
exports.serializeAws_restJson1TagMeetingCommand = serializeAws_restJson1TagMeetingCommand;
const serializeAws_restJson1TagResourceCommand = async (input, context) => {
  const headers = {
    "content-type": "application/json",
  };
  let resolvedPath = "/tags";
  const query = {
    operation: "tag-resource",
  };
  let body;
  body = JSON.stringify({
    ...(input.ResourceARN !== undefined && input.ResourceARN !== null && { ResourceARN: input.ResourceARN }),
    ...(input.Tags !== undefined &&
      input.Tags !== null && { Tags: serializeAws_restJson1TagList(input.Tags, context) }),
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};
exports.serializeAws_restJson1TagResourceCommand = serializeAws_restJson1TagResourceCommand;
const serializeAws_restJson1UntagAttendeeCommand = async (input, context) => {
  const headers = {
    "content-type": "application/json",
  };
  let resolvedPath = "/meetings/{MeetingId}/attendees/{AttendeeId}/tags";
  if (input.MeetingId !== undefined) {
    const labelValue = input.MeetingId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: MeetingId.");
    }
    resolvedPath = resolvedPath.replace("{MeetingId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: MeetingId.");
  }
  if (input.AttendeeId !== undefined) {
    const labelValue = input.AttendeeId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AttendeeId.");
    }
    resolvedPath = resolvedPath.replace("{AttendeeId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: AttendeeId.");
  }
  const query = {
    operation: "delete",
  };
  let body;
  body = JSON.stringify({
    ...(input.TagKeys !== undefined &&
      input.TagKeys !== null && { TagKeys: serializeAws_restJson1AttendeeTagKeyList(input.TagKeys, context) }),
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};
exports.serializeAws_restJson1UntagAttendeeCommand = serializeAws_restJson1UntagAttendeeCommand;
const serializeAws_restJson1UntagMeetingCommand = async (input, context) => {
  const headers = {
    "content-type": "application/json",
  };
  let resolvedPath = "/meetings/{MeetingId}/tags";
  if (input.MeetingId !== undefined) {
    const labelValue = input.MeetingId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: MeetingId.");
    }
    resolvedPath = resolvedPath.replace("{MeetingId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: MeetingId.");
  }
  const query = {
    operation: "delete",
  };
  let body;
  body = JSON.stringify({
    ...(input.TagKeys !== undefined &&
      input.TagKeys !== null && { TagKeys: serializeAws_restJson1MeetingTagKeyList(input.TagKeys, context) }),
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};
exports.serializeAws_restJson1UntagMeetingCommand = serializeAws_restJson1UntagMeetingCommand;
const serializeAws_restJson1UntagResourceCommand = async (input, context) => {
  const headers = {
    "content-type": "application/json",
  };
  let resolvedPath = "/tags";
  const query = {
    operation: "untag-resource",
  };
  let body;
  body = JSON.stringify({
    ...(input.ResourceARN !== undefined && input.ResourceARN !== null && { ResourceARN: input.ResourceARN }),
    ...(input.TagKeys !== undefined &&
      input.TagKeys !== null && { TagKeys: serializeAws_restJson1TagKeyList(input.TagKeys, context) }),
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};
exports.serializeAws_restJson1UntagResourceCommand = serializeAws_restJson1UntagResourceCommand;
const serializeAws_restJson1UpdateAccountCommand = async (input, context) => {
  const headers = {
    "content-type": "application/json",
  };
  let resolvedPath = "/accounts/{AccountId}";
  if (input.AccountId !== undefined) {
    const labelValue = input.AccountId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AccountId.");
    }
    resolvedPath = resolvedPath.replace("{AccountId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: AccountId.");
  }
  let body;
  body = JSON.stringify({
    ...(input.Name !== undefined && input.Name !== null && { Name: input.Name }),
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1UpdateAccountCommand = serializeAws_restJson1UpdateAccountCommand;
const serializeAws_restJson1UpdateAccountSettingsCommand = async (input, context) => {
  const headers = {
    "content-type": "application/json",
  };
  let resolvedPath = "/accounts/{AccountId}/settings";
  if (input.AccountId !== undefined) {
    const labelValue = input.AccountId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AccountId.");
    }
    resolvedPath = resolvedPath.replace("{AccountId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: AccountId.");
  }
  let body;
  body = JSON.stringify({
    ...(input.AccountSettings !== undefined &&
      input.AccountSettings !== null && {
        AccountSettings: serializeAws_restJson1AccountSettings(input.AccountSettings, context),
      }),
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "PUT",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1UpdateAccountSettingsCommand = serializeAws_restJson1UpdateAccountSettingsCommand;
const serializeAws_restJson1UpdateAppInstanceCommand = async (input, context) => {
  const headers = {
    "content-type": "application/json",
  };
  let resolvedPath = "/app-instances/{AppInstanceArn}";
  if (input.AppInstanceArn !== undefined) {
    const labelValue = input.AppInstanceArn;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AppInstanceArn.");
    }
    resolvedPath = resolvedPath.replace("{AppInstanceArn}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: AppInstanceArn.");
  }
  let body;
  body = JSON.stringify({
    ...(input.Metadata !== undefined && input.Metadata !== null && { Metadata: input.Metadata }),
    ...(input.Name !== undefined && input.Name !== null && { Name: input.Name }),
  });
  let { hostname: resolvedHostname } = await context.endpoint();
  if (context.disableHostPrefix !== true) {
    resolvedHostname = "identity-" + resolvedHostname;
    if (!protocol_http_1.isValidHostname(resolvedHostname)) {
      throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
    }
  }
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname: resolvedHostname,
    port,
    method: "PUT",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1UpdateAppInstanceCommand = serializeAws_restJson1UpdateAppInstanceCommand;
const serializeAws_restJson1UpdateAppInstanceUserCommand = async (input, context) => {
  const headers = {
    "content-type": "application/json",
  };
  let resolvedPath = "/app-instance-users/{AppInstanceUserArn}";
  if (input.AppInstanceUserArn !== undefined) {
    const labelValue = input.AppInstanceUserArn;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AppInstanceUserArn.");
    }
    resolvedPath = resolvedPath.replace("{AppInstanceUserArn}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: AppInstanceUserArn.");
  }
  let body;
  body = JSON.stringify({
    ...(input.Metadata !== undefined && input.Metadata !== null && { Metadata: input.Metadata }),
    ...(input.Name !== undefined && input.Name !== null && { Name: input.Name }),
  });
  let { hostname: resolvedHostname } = await context.endpoint();
  if (context.disableHostPrefix !== true) {
    resolvedHostname = "identity-" + resolvedHostname;
    if (!protocol_http_1.isValidHostname(resolvedHostname)) {
      throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
    }
  }
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname: resolvedHostname,
    port,
    method: "PUT",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1UpdateAppInstanceUserCommand = serializeAws_restJson1UpdateAppInstanceUserCommand;
const serializeAws_restJson1UpdateBotCommand = async (input, context) => {
  const headers = {
    "content-type": "application/json",
  };
  let resolvedPath = "/accounts/{AccountId}/bots/{BotId}";
  if (input.AccountId !== undefined) {
    const labelValue = input.AccountId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AccountId.");
    }
    resolvedPath = resolvedPath.replace("{AccountId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: AccountId.");
  }
  if (input.BotId !== undefined) {
    const labelValue = input.BotId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: BotId.");
    }
    resolvedPath = resolvedPath.replace("{BotId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: BotId.");
  }
  let body;
  body = JSON.stringify({
    ...(input.Disabled !== undefined && input.Disabled !== null && { Disabled: input.Disabled }),
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1UpdateBotCommand = serializeAws_restJson1UpdateBotCommand;
const serializeAws_restJson1UpdateChannelCommand = async (input, context) => {
  const headers = {
    "content-type": "application/json",
    ...(isSerializableHeaderValue(input.ChimeBearer) && { "x-amz-chime-bearer": input.ChimeBearer }),
  };
  let resolvedPath = "/channels/{ChannelArn}";
  if (input.ChannelArn !== undefined) {
    const labelValue = input.ChannelArn;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: ChannelArn.");
    }
    resolvedPath = resolvedPath.replace("{ChannelArn}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: ChannelArn.");
  }
  let body;
  body = JSON.stringify({
    ...(input.Metadata !== undefined && input.Metadata !== null && { Metadata: input.Metadata }),
    ...(input.Mode !== undefined && input.Mode !== null && { Mode: input.Mode }),
    ...(input.Name !== undefined && input.Name !== null && { Name: input.Name }),
  });
  let { hostname: resolvedHostname } = await context.endpoint();
  if (context.disableHostPrefix !== true) {
    resolvedHostname = "messaging-" + resolvedHostname;
    if (!protocol_http_1.isValidHostname(resolvedHostname)) {
      throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
    }
  }
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname: resolvedHostname,
    port,
    method: "PUT",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1UpdateChannelCommand = serializeAws_restJson1UpdateChannelCommand;
const serializeAws_restJson1UpdateChannelMessageCommand = async (input, context) => {
  const headers = {
    "content-type": "application/json",
    ...(isSerializableHeaderValue(input.ChimeBearer) && { "x-amz-chime-bearer": input.ChimeBearer }),
  };
  let resolvedPath = "/channels/{ChannelArn}/messages/{MessageId}";
  if (input.ChannelArn !== undefined) {
    const labelValue = input.ChannelArn;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: ChannelArn.");
    }
    resolvedPath = resolvedPath.replace("{ChannelArn}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: ChannelArn.");
  }
  if (input.MessageId !== undefined) {
    const labelValue = input.MessageId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: MessageId.");
    }
    resolvedPath = resolvedPath.replace("{MessageId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: MessageId.");
  }
  let body;
  body = JSON.stringify({
    ...(input.Content !== undefined && input.Content !== null && { Content: input.Content }),
    ...(input.Metadata !== undefined && input.Metadata !== null && { Metadata: input.Metadata }),
  });
  let { hostname: resolvedHostname } = await context.endpoint();
  if (context.disableHostPrefix !== true) {
    resolvedHostname = "messaging-" + resolvedHostname;
    if (!protocol_http_1.isValidHostname(resolvedHostname)) {
      throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
    }
  }
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname: resolvedHostname,
    port,
    method: "PUT",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1UpdateChannelMessageCommand = serializeAws_restJson1UpdateChannelMessageCommand;
const serializeAws_restJson1UpdateChannelReadMarkerCommand = async (input, context) => {
  const headers = {
    ...(isSerializableHeaderValue(input.ChimeBearer) && { "x-amz-chime-bearer": input.ChimeBearer }),
  };
  let resolvedPath = "/channels/{ChannelArn}/readMarker";
  if (input.ChannelArn !== undefined) {
    const labelValue = input.ChannelArn;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: ChannelArn.");
    }
    resolvedPath = resolvedPath.replace("{ChannelArn}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: ChannelArn.");
  }
  let body;
  let { hostname: resolvedHostname } = await context.endpoint();
  if (context.disableHostPrefix !== true) {
    resolvedHostname = "messaging-" + resolvedHostname;
    if (!protocol_http_1.isValidHostname(resolvedHostname)) {
      throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
    }
  }
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname: resolvedHostname,
    port,
    method: "PUT",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1UpdateChannelReadMarkerCommand = serializeAws_restJson1UpdateChannelReadMarkerCommand;
const serializeAws_restJson1UpdateGlobalSettingsCommand = async (input, context) => {
  const headers = {
    "content-type": "application/json",
  };
  let resolvedPath = "/settings";
  let body;
  body = JSON.stringify({
    ...(input.BusinessCalling !== undefined &&
      input.BusinessCalling !== null && {
        BusinessCalling: serializeAws_restJson1BusinessCallingSettings(input.BusinessCalling, context),
      }),
    ...(input.VoiceConnector !== undefined &&
      input.VoiceConnector !== null && {
        VoiceConnector: serializeAws_restJson1VoiceConnectorSettings(input.VoiceConnector, context),
      }),
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "PUT",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1UpdateGlobalSettingsCommand = serializeAws_restJson1UpdateGlobalSettingsCommand;
const serializeAws_restJson1UpdatePhoneNumberCommand = async (input, context) => {
  const headers = {
    "content-type": "application/json",
  };
  let resolvedPath = "/phone-numbers/{PhoneNumberId}";
  if (input.PhoneNumberId !== undefined) {
    const labelValue = input.PhoneNumberId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: PhoneNumberId.");
    }
    resolvedPath = resolvedPath.replace("{PhoneNumberId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: PhoneNumberId.");
  }
  let body;
  body = JSON.stringify({
    ...(input.CallingName !== undefined && input.CallingName !== null && { CallingName: input.CallingName }),
    ...(input.ProductType !== undefined && input.ProductType !== null && { ProductType: input.ProductType }),
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1UpdatePhoneNumberCommand = serializeAws_restJson1UpdatePhoneNumberCommand;
const serializeAws_restJson1UpdatePhoneNumberSettingsCommand = async (input, context) => {
  const headers = {
    "content-type": "application/json",
  };
  let resolvedPath = "/settings/phone-number";
  let body;
  body = JSON.stringify({
    ...(input.CallingName !== undefined && input.CallingName !== null && { CallingName: input.CallingName }),
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "PUT",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1UpdatePhoneNumberSettingsCommand = serializeAws_restJson1UpdatePhoneNumberSettingsCommand;
const serializeAws_restJson1UpdateProxySessionCommand = async (input, context) => {
  const headers = {
    "content-type": "application/json",
  };
  let resolvedPath = "/voice-connectors/{VoiceConnectorId}/proxy-sessions/{ProxySessionId}";
  if (input.VoiceConnectorId !== undefined) {
    const labelValue = input.VoiceConnectorId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: VoiceConnectorId.");
    }
    resolvedPath = resolvedPath.replace("{VoiceConnectorId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: VoiceConnectorId.");
  }
  if (input.ProxySessionId !== undefined) {
    const labelValue = input.ProxySessionId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: ProxySessionId.");
    }
    resolvedPath = resolvedPath.replace("{ProxySessionId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: ProxySessionId.");
  }
  let body;
  body = JSON.stringify({
    ...(input.Capabilities !== undefined &&
      input.Capabilities !== null && {
        Capabilities: serializeAws_restJson1CapabilityList(input.Capabilities, context),
      }),
    ...(input.ExpiryMinutes !== undefined && input.ExpiryMinutes !== null && { ExpiryMinutes: input.ExpiryMinutes }),
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1UpdateProxySessionCommand = serializeAws_restJson1UpdateProxySessionCommand;
const serializeAws_restJson1UpdateRoomCommand = async (input, context) => {
  const headers = {
    "content-type": "application/json",
  };
  let resolvedPath = "/accounts/{AccountId}/rooms/{RoomId}";
  if (input.AccountId !== undefined) {
    const labelValue = input.AccountId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AccountId.");
    }
    resolvedPath = resolvedPath.replace("{AccountId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: AccountId.");
  }
  if (input.RoomId !== undefined) {
    const labelValue = input.RoomId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: RoomId.");
    }
    resolvedPath = resolvedPath.replace("{RoomId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: RoomId.");
  }
  let body;
  body = JSON.stringify({
    ...(input.Name !== undefined && input.Name !== null && { Name: input.Name }),
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1UpdateRoomCommand = serializeAws_restJson1UpdateRoomCommand;
const serializeAws_restJson1UpdateRoomMembershipCommand = async (input, context) => {
  const headers = {
    "content-type": "application/json",
  };
  let resolvedPath = "/accounts/{AccountId}/rooms/{RoomId}/memberships/{MemberId}";
  if (input.AccountId !== undefined) {
    const labelValue = input.AccountId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AccountId.");
    }
    resolvedPath = resolvedPath.replace("{AccountId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: AccountId.");
  }
  if (input.RoomId !== undefined) {
    const labelValue = input.RoomId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: RoomId.");
    }
    resolvedPath = resolvedPath.replace("{RoomId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: RoomId.");
  }
  if (input.MemberId !== undefined) {
    const labelValue = input.MemberId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: MemberId.");
    }
    resolvedPath = resolvedPath.replace("{MemberId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: MemberId.");
  }
  let body;
  body = JSON.stringify({
    ...(input.Role !== undefined && input.Role !== null && { Role: input.Role }),
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1UpdateRoomMembershipCommand = serializeAws_restJson1UpdateRoomMembershipCommand;
const serializeAws_restJson1UpdateSipMediaApplicationCommand = async (input, context) => {
  const headers = {
    "content-type": "application/json",
  };
  let resolvedPath = "/sip-media-applications/{SipMediaApplicationId}";
  if (input.SipMediaApplicationId !== undefined) {
    const labelValue = input.SipMediaApplicationId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: SipMediaApplicationId.");
    }
    resolvedPath = resolvedPath.replace(
      "{SipMediaApplicationId}",
      smithy_client_1.extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: SipMediaApplicationId.");
  }
  let body;
  body = JSON.stringify({
    ...(input.Endpoints !== undefined &&
      input.Endpoints !== null && {
        Endpoints: serializeAws_restJson1SipMediaApplicationEndpointList(input.Endpoints, context),
      }),
    ...(input.Name !== undefined && input.Name !== null && { Name: input.Name }),
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "PUT",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1UpdateSipMediaApplicationCommand = serializeAws_restJson1UpdateSipMediaApplicationCommand;
const serializeAws_restJson1UpdateSipRuleCommand = async (input, context) => {
  const headers = {
    "content-type": "application/json",
  };
  let resolvedPath = "/sip-rules/{SipRuleId}";
  if (input.SipRuleId !== undefined) {
    const labelValue = input.SipRuleId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: SipRuleId.");
    }
    resolvedPath = resolvedPath.replace("{SipRuleId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: SipRuleId.");
  }
  let body;
  body = JSON.stringify({
    ...(input.Disabled !== undefined && input.Disabled !== null && { Disabled: input.Disabled }),
    ...(input.Name !== undefined && input.Name !== null && { Name: input.Name }),
    ...(input.TargetApplications !== undefined &&
      input.TargetApplications !== null && {
        TargetApplications: serializeAws_restJson1SipRuleTargetApplicationList(input.TargetApplications, context),
      }),
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "PUT",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1UpdateSipRuleCommand = serializeAws_restJson1UpdateSipRuleCommand;
const serializeAws_restJson1UpdateUserCommand = async (input, context) => {
  const headers = {
    "content-type": "application/json",
  };
  let resolvedPath = "/accounts/{AccountId}/users/{UserId}";
  if (input.AccountId !== undefined) {
    const labelValue = input.AccountId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AccountId.");
    }
    resolvedPath = resolvedPath.replace("{AccountId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: AccountId.");
  }
  if (input.UserId !== undefined) {
    const labelValue = input.UserId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: UserId.");
    }
    resolvedPath = resolvedPath.replace("{UserId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: UserId.");
  }
  let body;
  body = JSON.stringify({
    ...(input.AlexaForBusinessMetadata !== undefined &&
      input.AlexaForBusinessMetadata !== null && {
        AlexaForBusinessMetadata: serializeAws_restJson1AlexaForBusinessMetadata(
          input.AlexaForBusinessMetadata,
          context
        ),
      }),
    ...(input.LicenseType !== undefined && input.LicenseType !== null && { LicenseType: input.LicenseType }),
    ...(input.UserType !== undefined && input.UserType !== null && { UserType: input.UserType }),
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1UpdateUserCommand = serializeAws_restJson1UpdateUserCommand;
const serializeAws_restJson1UpdateUserSettingsCommand = async (input, context) => {
  const headers = {
    "content-type": "application/json",
  };
  let resolvedPath = "/accounts/{AccountId}/users/{UserId}/settings";
  if (input.AccountId !== undefined) {
    const labelValue = input.AccountId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AccountId.");
    }
    resolvedPath = resolvedPath.replace("{AccountId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: AccountId.");
  }
  if (input.UserId !== undefined) {
    const labelValue = input.UserId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: UserId.");
    }
    resolvedPath = resolvedPath.replace("{UserId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: UserId.");
  }
  let body;
  body = JSON.stringify({
    ...(input.UserSettings !== undefined &&
      input.UserSettings !== null && { UserSettings: serializeAws_restJson1UserSettings(input.UserSettings, context) }),
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "PUT",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1UpdateUserSettingsCommand = serializeAws_restJson1UpdateUserSettingsCommand;
const serializeAws_restJson1UpdateVoiceConnectorCommand = async (input, context) => {
  const headers = {
    "content-type": "application/json",
  };
  let resolvedPath = "/voice-connectors/{VoiceConnectorId}";
  if (input.VoiceConnectorId !== undefined) {
    const labelValue = input.VoiceConnectorId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: VoiceConnectorId.");
    }
    resolvedPath = resolvedPath.replace("{VoiceConnectorId}", smithy_client_1.extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: VoiceConnectorId.");
  }
  let body;
  body = JSON.stringify({
    ...(input.Name !== undefined && input.Name !== null && { Name: input.Name }),
    ...(input.RequireEncryption !== undefined &&
      input.RequireEncryption !== null && { RequireEncryption: input.RequireEncryption }),
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "PUT",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1UpdateVoiceConnectorCommand = serializeAws_restJson1UpdateVoiceConnectorCommand;
const serializeAws_restJson1UpdateVoiceConnectorGroupCommand = async (input, context) => {
  const headers = {
    "content-type": "application/json",
  };
  let resolvedPath = "/voice-connector-groups/{VoiceConnectorGroupId}";
  if (input.VoiceConnectorGroupId !== undefined) {
    const labelValue = input.VoiceConnectorGroupId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: VoiceConnectorGroupId.");
    }
    resolvedPath = resolvedPath.replace(
      "{VoiceConnectorGroupId}",
      smithy_client_1.extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: VoiceConnectorGroupId.");
  }
  let body;
  body = JSON.stringify({
    ...(input.Name !== undefined && input.Name !== null && { Name: input.Name }),
    ...(input.VoiceConnectorItems !== undefined &&
      input.VoiceConnectorItems !== null && {
        VoiceConnectorItems: serializeAws_restJson1VoiceConnectorItemList(input.VoiceConnectorItems, context),
      }),
  });
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new protocol_http_1.HttpRequest({
    protocol,
    hostname,
    port,
    method: "PUT",
    headers,
    path: resolvedPath,
    body,
  });
};
exports.serializeAws_restJson1UpdateVoiceConnectorGroupCommand = serializeAws_restJson1UpdateVoiceConnectorGroupCommand;
const deserializeAws_restJson1AssociatePhoneNumbersWithVoiceConnectorCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1AssociatePhoneNumbersWithVoiceConnectorCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    PhoneNumberErrors: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.PhoneNumberErrors !== undefined && data.PhoneNumberErrors !== null) {
    contents.PhoneNumberErrors = deserializeAws_restJson1PhoneNumberErrorList(data.PhoneNumberErrors, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1AssociatePhoneNumbersWithVoiceConnectorCommand =
  deserializeAws_restJson1AssociatePhoneNumbersWithVoiceConnectorCommand;
const deserializeAws_restJson1AssociatePhoneNumbersWithVoiceConnectorCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.chime#AccessDeniedException":
      response = {
        ...(await deserializeAws_restJson1AccessDeniedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1AssociatePhoneNumbersWithVoiceConnectorGroupCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1AssociatePhoneNumbersWithVoiceConnectorGroupCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    PhoneNumberErrors: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.PhoneNumberErrors !== undefined && data.PhoneNumberErrors !== null) {
    contents.PhoneNumberErrors = deserializeAws_restJson1PhoneNumberErrorList(data.PhoneNumberErrors, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1AssociatePhoneNumbersWithVoiceConnectorGroupCommand =
  deserializeAws_restJson1AssociatePhoneNumbersWithVoiceConnectorGroupCommand;
const deserializeAws_restJson1AssociatePhoneNumbersWithVoiceConnectorGroupCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.chime#AccessDeniedException":
      response = {
        ...(await deserializeAws_restJson1AccessDeniedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1AssociatePhoneNumberWithUserCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1AssociatePhoneNumberWithUserCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1AssociatePhoneNumberWithUserCommand =
  deserializeAws_restJson1AssociatePhoneNumberWithUserCommand;
const deserializeAws_restJson1AssociatePhoneNumberWithUserCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.chime#AccessDeniedException":
      response = {
        ...(await deserializeAws_restJson1AccessDeniedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1AssociateSigninDelegateGroupsWithAccountCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1AssociateSigninDelegateGroupsWithAccountCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1AssociateSigninDelegateGroupsWithAccountCommand =
  deserializeAws_restJson1AssociateSigninDelegateGroupsWithAccountCommand;
const deserializeAws_restJson1AssociateSigninDelegateGroupsWithAccountCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1BatchCreateAttendeeCommand = async (output, context) => {
  if (output.statusCode !== 201 && output.statusCode >= 300) {
    return deserializeAws_restJson1BatchCreateAttendeeCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    Attendees: undefined,
    Errors: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.Attendees !== undefined && data.Attendees !== null) {
    contents.Attendees = deserializeAws_restJson1AttendeeList(data.Attendees, context);
  }
  if (data.Errors !== undefined && data.Errors !== null) {
    contents.Errors = deserializeAws_restJson1BatchCreateAttendeeErrorList(data.Errors, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1BatchCreateAttendeeCommand = deserializeAws_restJson1BatchCreateAttendeeCommand;
const deserializeAws_restJson1BatchCreateAttendeeCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceLimitExceededException":
    case "com.amazonaws.chime#ResourceLimitExceededException":
      response = {
        ...(await deserializeAws_restJson1ResourceLimitExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1BatchCreateChannelMembershipCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1BatchCreateChannelMembershipCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    BatchChannelMemberships: undefined,
    Errors: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.BatchChannelMemberships !== undefined && data.BatchChannelMemberships !== null) {
    contents.BatchChannelMemberships = deserializeAws_restJson1BatchChannelMemberships(
      data.BatchChannelMemberships,
      context
    );
  }
  if (data.Errors !== undefined && data.Errors !== null) {
    contents.Errors = deserializeAws_restJson1BatchCreateChannelMembershipErrors(data.Errors, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1BatchCreateChannelMembershipCommand =
  deserializeAws_restJson1BatchCreateChannelMembershipCommand;
const deserializeAws_restJson1BatchCreateChannelMembershipCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1BatchCreateRoomMembershipCommand = async (output, context) => {
  if (output.statusCode !== 201 && output.statusCode >= 300) {
    return deserializeAws_restJson1BatchCreateRoomMembershipCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    Errors: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.Errors !== undefined && data.Errors !== null) {
    contents.Errors = deserializeAws_restJson1MemberErrorList(data.Errors, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1BatchCreateRoomMembershipCommand =
  deserializeAws_restJson1BatchCreateRoomMembershipCommand;
const deserializeAws_restJson1BatchCreateRoomMembershipCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1BatchDeletePhoneNumberCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1BatchDeletePhoneNumberCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    PhoneNumberErrors: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.PhoneNumberErrors !== undefined && data.PhoneNumberErrors !== null) {
    contents.PhoneNumberErrors = deserializeAws_restJson1PhoneNumberErrorList(data.PhoneNumberErrors, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1BatchDeletePhoneNumberCommand = deserializeAws_restJson1BatchDeletePhoneNumberCommand;
const deserializeAws_restJson1BatchDeletePhoneNumberCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1BatchSuspendUserCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1BatchSuspendUserCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    UserErrors: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.UserErrors !== undefined && data.UserErrors !== null) {
    contents.UserErrors = deserializeAws_restJson1UserErrorList(data.UserErrors, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1BatchSuspendUserCommand = deserializeAws_restJson1BatchSuspendUserCommand;
const deserializeAws_restJson1BatchSuspendUserCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1BatchUnsuspendUserCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1BatchUnsuspendUserCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    UserErrors: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.UserErrors !== undefined && data.UserErrors !== null) {
    contents.UserErrors = deserializeAws_restJson1UserErrorList(data.UserErrors, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1BatchUnsuspendUserCommand = deserializeAws_restJson1BatchUnsuspendUserCommand;
const deserializeAws_restJson1BatchUnsuspendUserCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1BatchUpdatePhoneNumberCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1BatchUpdatePhoneNumberCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    PhoneNumberErrors: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.PhoneNumberErrors !== undefined && data.PhoneNumberErrors !== null) {
    contents.PhoneNumberErrors = deserializeAws_restJson1PhoneNumberErrorList(data.PhoneNumberErrors, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1BatchUpdatePhoneNumberCommand = deserializeAws_restJson1BatchUpdatePhoneNumberCommand;
const deserializeAws_restJson1BatchUpdatePhoneNumberCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1BatchUpdateUserCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1BatchUpdateUserCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    UserErrors: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.UserErrors !== undefined && data.UserErrors !== null) {
    contents.UserErrors = deserializeAws_restJson1UserErrorList(data.UserErrors, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1BatchUpdateUserCommand = deserializeAws_restJson1BatchUpdateUserCommand;
const deserializeAws_restJson1BatchUpdateUserCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1CreateAccountCommand = async (output, context) => {
  if (output.statusCode !== 201 && output.statusCode >= 300) {
    return deserializeAws_restJson1CreateAccountCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    Account: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.Account !== undefined && data.Account !== null) {
    contents.Account = deserializeAws_restJson1Account(data.Account, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1CreateAccountCommand = deserializeAws_restJson1CreateAccountCommand;
const deserializeAws_restJson1CreateAccountCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1CreateAppInstanceCommand = async (output, context) => {
  if (output.statusCode !== 201 && output.statusCode >= 300) {
    return deserializeAws_restJson1CreateAppInstanceCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    AppInstanceArn: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.AppInstanceArn !== undefined && data.AppInstanceArn !== null) {
    contents.AppInstanceArn = data.AppInstanceArn;
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1CreateAppInstanceCommand = deserializeAws_restJson1CreateAppInstanceCommand;
const deserializeAws_restJson1CreateAppInstanceCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ConflictException":
    case "com.amazonaws.chime#ConflictException":
      response = {
        ...(await deserializeAws_restJson1ConflictExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceLimitExceededException":
    case "com.amazonaws.chime#ResourceLimitExceededException":
      response = {
        ...(await deserializeAws_restJson1ResourceLimitExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1CreateAppInstanceAdminCommand = async (output, context) => {
  if (output.statusCode !== 201 && output.statusCode >= 300) {
    return deserializeAws_restJson1CreateAppInstanceAdminCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    AppInstanceAdmin: undefined,
    AppInstanceArn: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.AppInstanceAdmin !== undefined && data.AppInstanceAdmin !== null) {
    contents.AppInstanceAdmin = deserializeAws_restJson1Identity(data.AppInstanceAdmin, context);
  }
  if (data.AppInstanceArn !== undefined && data.AppInstanceArn !== null) {
    contents.AppInstanceArn = data.AppInstanceArn;
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1CreateAppInstanceAdminCommand = deserializeAws_restJson1CreateAppInstanceAdminCommand;
const deserializeAws_restJson1CreateAppInstanceAdminCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ConflictException":
    case "com.amazonaws.chime#ConflictException":
      response = {
        ...(await deserializeAws_restJson1ConflictExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceLimitExceededException":
    case "com.amazonaws.chime#ResourceLimitExceededException":
      response = {
        ...(await deserializeAws_restJson1ResourceLimitExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1CreateAppInstanceUserCommand = async (output, context) => {
  if (output.statusCode !== 201 && output.statusCode >= 300) {
    return deserializeAws_restJson1CreateAppInstanceUserCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    AppInstanceUserArn: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.AppInstanceUserArn !== undefined && data.AppInstanceUserArn !== null) {
    contents.AppInstanceUserArn = data.AppInstanceUserArn;
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1CreateAppInstanceUserCommand = deserializeAws_restJson1CreateAppInstanceUserCommand;
const deserializeAws_restJson1CreateAppInstanceUserCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ConflictException":
    case "com.amazonaws.chime#ConflictException":
      response = {
        ...(await deserializeAws_restJson1ConflictExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceLimitExceededException":
    case "com.amazonaws.chime#ResourceLimitExceededException":
      response = {
        ...(await deserializeAws_restJson1ResourceLimitExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1CreateAttendeeCommand = async (output, context) => {
  if (output.statusCode !== 201 && output.statusCode >= 300) {
    return deserializeAws_restJson1CreateAttendeeCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    Attendee: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.Attendee !== undefined && data.Attendee !== null) {
    contents.Attendee = deserializeAws_restJson1Attendee(data.Attendee, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1CreateAttendeeCommand = deserializeAws_restJson1CreateAttendeeCommand;
const deserializeAws_restJson1CreateAttendeeCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceLimitExceededException":
    case "com.amazonaws.chime#ResourceLimitExceededException":
      response = {
        ...(await deserializeAws_restJson1ResourceLimitExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1CreateBotCommand = async (output, context) => {
  if (output.statusCode !== 201 && output.statusCode >= 300) {
    return deserializeAws_restJson1CreateBotCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    Bot: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.Bot !== undefined && data.Bot !== null) {
    contents.Bot = deserializeAws_restJson1Bot(data.Bot, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1CreateBotCommand = deserializeAws_restJson1CreateBotCommand;
const deserializeAws_restJson1CreateBotCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceLimitExceededException":
    case "com.amazonaws.chime#ResourceLimitExceededException":
      response = {
        ...(await deserializeAws_restJson1ResourceLimitExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1CreateChannelCommand = async (output, context) => {
  if (output.statusCode !== 201 && output.statusCode >= 300) {
    return deserializeAws_restJson1CreateChannelCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    ChannelArn: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.ChannelArn !== undefined && data.ChannelArn !== null) {
    contents.ChannelArn = data.ChannelArn;
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1CreateChannelCommand = deserializeAws_restJson1CreateChannelCommand;
const deserializeAws_restJson1CreateChannelCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ConflictException":
    case "com.amazonaws.chime#ConflictException":
      response = {
        ...(await deserializeAws_restJson1ConflictExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceLimitExceededException":
    case "com.amazonaws.chime#ResourceLimitExceededException":
      response = {
        ...(await deserializeAws_restJson1ResourceLimitExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1CreateChannelBanCommand = async (output, context) => {
  if (output.statusCode !== 201 && output.statusCode >= 300) {
    return deserializeAws_restJson1CreateChannelBanCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    ChannelArn: undefined,
    Member: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.ChannelArn !== undefined && data.ChannelArn !== null) {
    contents.ChannelArn = data.ChannelArn;
  }
  if (data.Member !== undefined && data.Member !== null) {
    contents.Member = deserializeAws_restJson1Identity(data.Member, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1CreateChannelBanCommand = deserializeAws_restJson1CreateChannelBanCommand;
const deserializeAws_restJson1CreateChannelBanCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ConflictException":
    case "com.amazonaws.chime#ConflictException":
      response = {
        ...(await deserializeAws_restJson1ConflictExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceLimitExceededException":
    case "com.amazonaws.chime#ResourceLimitExceededException":
      response = {
        ...(await deserializeAws_restJson1ResourceLimitExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1CreateChannelMembershipCommand = async (output, context) => {
  if (output.statusCode !== 201 && output.statusCode >= 300) {
    return deserializeAws_restJson1CreateChannelMembershipCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    ChannelArn: undefined,
    Member: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.ChannelArn !== undefined && data.ChannelArn !== null) {
    contents.ChannelArn = data.ChannelArn;
  }
  if (data.Member !== undefined && data.Member !== null) {
    contents.Member = deserializeAws_restJson1Identity(data.Member, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1CreateChannelMembershipCommand = deserializeAws_restJson1CreateChannelMembershipCommand;
const deserializeAws_restJson1CreateChannelMembershipCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ConflictException":
    case "com.amazonaws.chime#ConflictException":
      response = {
        ...(await deserializeAws_restJson1ConflictExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceLimitExceededException":
    case "com.amazonaws.chime#ResourceLimitExceededException":
      response = {
        ...(await deserializeAws_restJson1ResourceLimitExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1CreateChannelModeratorCommand = async (output, context) => {
  if (output.statusCode !== 201 && output.statusCode >= 300) {
    return deserializeAws_restJson1CreateChannelModeratorCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    ChannelArn: undefined,
    ChannelModerator: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.ChannelArn !== undefined && data.ChannelArn !== null) {
    contents.ChannelArn = data.ChannelArn;
  }
  if (data.ChannelModerator !== undefined && data.ChannelModerator !== null) {
    contents.ChannelModerator = deserializeAws_restJson1Identity(data.ChannelModerator, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1CreateChannelModeratorCommand = deserializeAws_restJson1CreateChannelModeratorCommand;
const deserializeAws_restJson1CreateChannelModeratorCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ConflictException":
    case "com.amazonaws.chime#ConflictException":
      response = {
        ...(await deserializeAws_restJson1ConflictExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceLimitExceededException":
    case "com.amazonaws.chime#ResourceLimitExceededException":
      response = {
        ...(await deserializeAws_restJson1ResourceLimitExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1CreateMeetingCommand = async (output, context) => {
  if (output.statusCode !== 201 && output.statusCode >= 300) {
    return deserializeAws_restJson1CreateMeetingCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    Meeting: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.Meeting !== undefined && data.Meeting !== null) {
    contents.Meeting = deserializeAws_restJson1Meeting(data.Meeting, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1CreateMeetingCommand = deserializeAws_restJson1CreateMeetingCommand;
const deserializeAws_restJson1CreateMeetingCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceLimitExceededException":
    case "com.amazonaws.chime#ResourceLimitExceededException":
      response = {
        ...(await deserializeAws_restJson1ResourceLimitExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1CreateMeetingDialOutCommand = async (output, context) => {
  if (output.statusCode !== 201 && output.statusCode >= 300) {
    return deserializeAws_restJson1CreateMeetingDialOutCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    TransactionId: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.TransactionId !== undefined && data.TransactionId !== null) {
    contents.TransactionId = data.TransactionId;
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1CreateMeetingDialOutCommand = deserializeAws_restJson1CreateMeetingDialOutCommand;
const deserializeAws_restJson1CreateMeetingDialOutCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceLimitExceededException":
    case "com.amazonaws.chime#ResourceLimitExceededException":
      response = {
        ...(await deserializeAws_restJson1ResourceLimitExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1CreateMeetingWithAttendeesCommand = async (output, context) => {
  if (output.statusCode !== 201 && output.statusCode >= 300) {
    return deserializeAws_restJson1CreateMeetingWithAttendeesCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    Attendees: undefined,
    Errors: undefined,
    Meeting: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.Attendees !== undefined && data.Attendees !== null) {
    contents.Attendees = deserializeAws_restJson1AttendeeList(data.Attendees, context);
  }
  if (data.Errors !== undefined && data.Errors !== null) {
    contents.Errors = deserializeAws_restJson1BatchCreateAttendeeErrorList(data.Errors, context);
  }
  if (data.Meeting !== undefined && data.Meeting !== null) {
    contents.Meeting = deserializeAws_restJson1Meeting(data.Meeting, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1CreateMeetingWithAttendeesCommand =
  deserializeAws_restJson1CreateMeetingWithAttendeesCommand;
const deserializeAws_restJson1CreateMeetingWithAttendeesCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceLimitExceededException":
    case "com.amazonaws.chime#ResourceLimitExceededException":
      response = {
        ...(await deserializeAws_restJson1ResourceLimitExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1CreatePhoneNumberOrderCommand = async (output, context) => {
  if (output.statusCode !== 201 && output.statusCode >= 300) {
    return deserializeAws_restJson1CreatePhoneNumberOrderCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    PhoneNumberOrder: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.PhoneNumberOrder !== undefined && data.PhoneNumberOrder !== null) {
    contents.PhoneNumberOrder = deserializeAws_restJson1PhoneNumberOrder(data.PhoneNumberOrder, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1CreatePhoneNumberOrderCommand = deserializeAws_restJson1CreatePhoneNumberOrderCommand;
const deserializeAws_restJson1CreatePhoneNumberOrderCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.chime#AccessDeniedException":
      response = {
        ...(await deserializeAws_restJson1AccessDeniedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceLimitExceededException":
    case "com.amazonaws.chime#ResourceLimitExceededException":
      response = {
        ...(await deserializeAws_restJson1ResourceLimitExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1CreateProxySessionCommand = async (output, context) => {
  if (output.statusCode !== 201 && output.statusCode >= 300) {
    return deserializeAws_restJson1CreateProxySessionCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    ProxySession: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.ProxySession !== undefined && data.ProxySession !== null) {
    contents.ProxySession = deserializeAws_restJson1ProxySession(data.ProxySession, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1CreateProxySessionCommand = deserializeAws_restJson1CreateProxySessionCommand;
const deserializeAws_restJson1CreateProxySessionCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1CreateRoomCommand = async (output, context) => {
  if (output.statusCode !== 201 && output.statusCode >= 300) {
    return deserializeAws_restJson1CreateRoomCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    Room: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.Room !== undefined && data.Room !== null) {
    contents.Room = deserializeAws_restJson1Room(data.Room, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1CreateRoomCommand = deserializeAws_restJson1CreateRoomCommand;
const deserializeAws_restJson1CreateRoomCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceLimitExceededException":
    case "com.amazonaws.chime#ResourceLimitExceededException":
      response = {
        ...(await deserializeAws_restJson1ResourceLimitExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1CreateRoomMembershipCommand = async (output, context) => {
  if (output.statusCode !== 201 && output.statusCode >= 300) {
    return deserializeAws_restJson1CreateRoomMembershipCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    RoomMembership: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.RoomMembership !== undefined && data.RoomMembership !== null) {
    contents.RoomMembership = deserializeAws_restJson1RoomMembership(data.RoomMembership, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1CreateRoomMembershipCommand = deserializeAws_restJson1CreateRoomMembershipCommand;
const deserializeAws_restJson1CreateRoomMembershipCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ConflictException":
    case "com.amazonaws.chime#ConflictException":
      response = {
        ...(await deserializeAws_restJson1ConflictExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceLimitExceededException":
    case "com.amazonaws.chime#ResourceLimitExceededException":
      response = {
        ...(await deserializeAws_restJson1ResourceLimitExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1CreateSipMediaApplicationCommand = async (output, context) => {
  if (output.statusCode !== 201 && output.statusCode >= 300) {
    return deserializeAws_restJson1CreateSipMediaApplicationCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    SipMediaApplication: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.SipMediaApplication !== undefined && data.SipMediaApplication !== null) {
    contents.SipMediaApplication = deserializeAws_restJson1SipMediaApplication(data.SipMediaApplication, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1CreateSipMediaApplicationCommand =
  deserializeAws_restJson1CreateSipMediaApplicationCommand;
const deserializeAws_restJson1CreateSipMediaApplicationCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.chime#AccessDeniedException":
      response = {
        ...(await deserializeAws_restJson1AccessDeniedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ConflictException":
    case "com.amazonaws.chime#ConflictException":
      response = {
        ...(await deserializeAws_restJson1ConflictExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceLimitExceededException":
    case "com.amazonaws.chime#ResourceLimitExceededException":
      response = {
        ...(await deserializeAws_restJson1ResourceLimitExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1CreateSipMediaApplicationCallCommand = async (output, context) => {
  if (output.statusCode !== 201 && output.statusCode >= 300) {
    return deserializeAws_restJson1CreateSipMediaApplicationCallCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    SipMediaApplicationCall: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.SipMediaApplicationCall !== undefined && data.SipMediaApplicationCall !== null) {
    contents.SipMediaApplicationCall = deserializeAws_restJson1SipMediaApplicationCall(
      data.SipMediaApplicationCall,
      context
    );
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1CreateSipMediaApplicationCallCommand =
  deserializeAws_restJson1CreateSipMediaApplicationCallCommand;
const deserializeAws_restJson1CreateSipMediaApplicationCallCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceLimitExceededException":
    case "com.amazonaws.chime#ResourceLimitExceededException":
      response = {
        ...(await deserializeAws_restJson1ResourceLimitExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1CreateSipRuleCommand = async (output, context) => {
  if (output.statusCode !== 201 && output.statusCode >= 300) {
    return deserializeAws_restJson1CreateSipRuleCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    SipRule: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.SipRule !== undefined && data.SipRule !== null) {
    contents.SipRule = deserializeAws_restJson1SipRule(data.SipRule, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1CreateSipRuleCommand = deserializeAws_restJson1CreateSipRuleCommand;
const deserializeAws_restJson1CreateSipRuleCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.chime#AccessDeniedException":
      response = {
        ...(await deserializeAws_restJson1AccessDeniedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ConflictException":
    case "com.amazonaws.chime#ConflictException":
      response = {
        ...(await deserializeAws_restJson1ConflictExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceLimitExceededException":
    case "com.amazonaws.chime#ResourceLimitExceededException":
      response = {
        ...(await deserializeAws_restJson1ResourceLimitExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1CreateUserCommand = async (output, context) => {
  if (output.statusCode !== 201 && output.statusCode >= 300) {
    return deserializeAws_restJson1CreateUserCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    User: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.User !== undefined && data.User !== null) {
    contents.User = deserializeAws_restJson1User(data.User, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1CreateUserCommand = deserializeAws_restJson1CreateUserCommand;
const deserializeAws_restJson1CreateUserCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ConflictException":
    case "com.amazonaws.chime#ConflictException":
      response = {
        ...(await deserializeAws_restJson1ConflictExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1CreateVoiceConnectorCommand = async (output, context) => {
  if (output.statusCode !== 201 && output.statusCode >= 300) {
    return deserializeAws_restJson1CreateVoiceConnectorCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    VoiceConnector: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.VoiceConnector !== undefined && data.VoiceConnector !== null) {
    contents.VoiceConnector = deserializeAws_restJson1VoiceConnector(data.VoiceConnector, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1CreateVoiceConnectorCommand = deserializeAws_restJson1CreateVoiceConnectorCommand;
const deserializeAws_restJson1CreateVoiceConnectorCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.chime#AccessDeniedException":
      response = {
        ...(await deserializeAws_restJson1AccessDeniedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceLimitExceededException":
    case "com.amazonaws.chime#ResourceLimitExceededException":
      response = {
        ...(await deserializeAws_restJson1ResourceLimitExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1CreateVoiceConnectorGroupCommand = async (output, context) => {
  if (output.statusCode !== 201 && output.statusCode >= 300) {
    return deserializeAws_restJson1CreateVoiceConnectorGroupCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    VoiceConnectorGroup: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.VoiceConnectorGroup !== undefined && data.VoiceConnectorGroup !== null) {
    contents.VoiceConnectorGroup = deserializeAws_restJson1VoiceConnectorGroup(data.VoiceConnectorGroup, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1CreateVoiceConnectorGroupCommand =
  deserializeAws_restJson1CreateVoiceConnectorGroupCommand;
const deserializeAws_restJson1CreateVoiceConnectorGroupCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.chime#AccessDeniedException":
      response = {
        ...(await deserializeAws_restJson1AccessDeniedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceLimitExceededException":
    case "com.amazonaws.chime#ResourceLimitExceededException":
      response = {
        ...(await deserializeAws_restJson1ResourceLimitExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DeleteAccountCommand = async (output, context) => {
  if (output.statusCode !== 204 && output.statusCode >= 300) {
    return deserializeAws_restJson1DeleteAccountCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DeleteAccountCommand = deserializeAws_restJson1DeleteAccountCommand;
const deserializeAws_restJson1DeleteAccountCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnprocessableEntityException":
    case "com.amazonaws.chime#UnprocessableEntityException":
      response = {
        ...(await deserializeAws_restJson1UnprocessableEntityExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DeleteAppInstanceCommand = async (output, context) => {
  if (output.statusCode !== 204 && output.statusCode >= 300) {
    return deserializeAws_restJson1DeleteAppInstanceCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DeleteAppInstanceCommand = deserializeAws_restJson1DeleteAppInstanceCommand;
const deserializeAws_restJson1DeleteAppInstanceCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DeleteAppInstanceAdminCommand = async (output, context) => {
  if (output.statusCode !== 204 && output.statusCode >= 300) {
    return deserializeAws_restJson1DeleteAppInstanceAdminCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DeleteAppInstanceAdminCommand = deserializeAws_restJson1DeleteAppInstanceAdminCommand;
const deserializeAws_restJson1DeleteAppInstanceAdminCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ConflictException":
    case "com.amazonaws.chime#ConflictException":
      response = {
        ...(await deserializeAws_restJson1ConflictExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DeleteAppInstanceStreamingConfigurationsCommand = async (output, context) => {
  if (output.statusCode !== 204 && output.statusCode >= 300) {
    return deserializeAws_restJson1DeleteAppInstanceStreamingConfigurationsCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DeleteAppInstanceStreamingConfigurationsCommand =
  deserializeAws_restJson1DeleteAppInstanceStreamingConfigurationsCommand;
const deserializeAws_restJson1DeleteAppInstanceStreamingConfigurationsCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DeleteAppInstanceUserCommand = async (output, context) => {
  if (output.statusCode !== 204 && output.statusCode >= 300) {
    return deserializeAws_restJson1DeleteAppInstanceUserCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DeleteAppInstanceUserCommand = deserializeAws_restJson1DeleteAppInstanceUserCommand;
const deserializeAws_restJson1DeleteAppInstanceUserCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DeleteAttendeeCommand = async (output, context) => {
  if (output.statusCode !== 204 && output.statusCode >= 300) {
    return deserializeAws_restJson1DeleteAttendeeCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DeleteAttendeeCommand = deserializeAws_restJson1DeleteAttendeeCommand;
const deserializeAws_restJson1DeleteAttendeeCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DeleteChannelCommand = async (output, context) => {
  if (output.statusCode !== 204 && output.statusCode >= 300) {
    return deserializeAws_restJson1DeleteChannelCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DeleteChannelCommand = deserializeAws_restJson1DeleteChannelCommand;
const deserializeAws_restJson1DeleteChannelCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DeleteChannelBanCommand = async (output, context) => {
  if (output.statusCode !== 204 && output.statusCode >= 300) {
    return deserializeAws_restJson1DeleteChannelBanCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DeleteChannelBanCommand = deserializeAws_restJson1DeleteChannelBanCommand;
const deserializeAws_restJson1DeleteChannelBanCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DeleteChannelMembershipCommand = async (output, context) => {
  if (output.statusCode !== 204 && output.statusCode >= 300) {
    return deserializeAws_restJson1DeleteChannelMembershipCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DeleteChannelMembershipCommand = deserializeAws_restJson1DeleteChannelMembershipCommand;
const deserializeAws_restJson1DeleteChannelMembershipCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ConflictException":
    case "com.amazonaws.chime#ConflictException":
      response = {
        ...(await deserializeAws_restJson1ConflictExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DeleteChannelMessageCommand = async (output, context) => {
  if (output.statusCode !== 204 && output.statusCode >= 300) {
    return deserializeAws_restJson1DeleteChannelMessageCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DeleteChannelMessageCommand = deserializeAws_restJson1DeleteChannelMessageCommand;
const deserializeAws_restJson1DeleteChannelMessageCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DeleteChannelModeratorCommand = async (output, context) => {
  if (output.statusCode !== 204 && output.statusCode >= 300) {
    return deserializeAws_restJson1DeleteChannelModeratorCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DeleteChannelModeratorCommand = deserializeAws_restJson1DeleteChannelModeratorCommand;
const deserializeAws_restJson1DeleteChannelModeratorCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DeleteEventsConfigurationCommand = async (output, context) => {
  if (output.statusCode !== 204 && output.statusCode >= 300) {
    return deserializeAws_restJson1DeleteEventsConfigurationCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DeleteEventsConfigurationCommand =
  deserializeAws_restJson1DeleteEventsConfigurationCommand;
const deserializeAws_restJson1DeleteEventsConfigurationCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceLimitExceededException":
    case "com.amazonaws.chime#ResourceLimitExceededException":
      response = {
        ...(await deserializeAws_restJson1ResourceLimitExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DeleteMeetingCommand = async (output, context) => {
  if (output.statusCode !== 204 && output.statusCode >= 300) {
    return deserializeAws_restJson1DeleteMeetingCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DeleteMeetingCommand = deserializeAws_restJson1DeleteMeetingCommand;
const deserializeAws_restJson1DeleteMeetingCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DeletePhoneNumberCommand = async (output, context) => {
  if (output.statusCode !== 204 && output.statusCode >= 300) {
    return deserializeAws_restJson1DeletePhoneNumberCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DeletePhoneNumberCommand = deserializeAws_restJson1DeletePhoneNumberCommand;
const deserializeAws_restJson1DeletePhoneNumberCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DeleteProxySessionCommand = async (output, context) => {
  if (output.statusCode !== 204 && output.statusCode >= 300) {
    return deserializeAws_restJson1DeleteProxySessionCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DeleteProxySessionCommand = deserializeAws_restJson1DeleteProxySessionCommand;
const deserializeAws_restJson1DeleteProxySessionCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DeleteRoomCommand = async (output, context) => {
  if (output.statusCode !== 204 && output.statusCode >= 300) {
    return deserializeAws_restJson1DeleteRoomCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DeleteRoomCommand = deserializeAws_restJson1DeleteRoomCommand;
const deserializeAws_restJson1DeleteRoomCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DeleteRoomMembershipCommand = async (output, context) => {
  if (output.statusCode !== 204 && output.statusCode >= 300) {
    return deserializeAws_restJson1DeleteRoomMembershipCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DeleteRoomMembershipCommand = deserializeAws_restJson1DeleteRoomMembershipCommand;
const deserializeAws_restJson1DeleteRoomMembershipCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DeleteSipMediaApplicationCommand = async (output, context) => {
  if (output.statusCode !== 204 && output.statusCode >= 300) {
    return deserializeAws_restJson1DeleteSipMediaApplicationCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DeleteSipMediaApplicationCommand =
  deserializeAws_restJson1DeleteSipMediaApplicationCommand;
const deserializeAws_restJson1DeleteSipMediaApplicationCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ConflictException":
    case "com.amazonaws.chime#ConflictException":
      response = {
        ...(await deserializeAws_restJson1ConflictExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DeleteSipRuleCommand = async (output, context) => {
  if (output.statusCode !== 204 && output.statusCode >= 300) {
    return deserializeAws_restJson1DeleteSipRuleCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DeleteSipRuleCommand = deserializeAws_restJson1DeleteSipRuleCommand;
const deserializeAws_restJson1DeleteSipRuleCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ConflictException":
    case "com.amazonaws.chime#ConflictException":
      response = {
        ...(await deserializeAws_restJson1ConflictExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DeleteVoiceConnectorCommand = async (output, context) => {
  if (output.statusCode !== 204 && output.statusCode >= 300) {
    return deserializeAws_restJson1DeleteVoiceConnectorCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DeleteVoiceConnectorCommand = deserializeAws_restJson1DeleteVoiceConnectorCommand;
const deserializeAws_restJson1DeleteVoiceConnectorCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ConflictException":
    case "com.amazonaws.chime#ConflictException":
      response = {
        ...(await deserializeAws_restJson1ConflictExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DeleteVoiceConnectorEmergencyCallingConfigurationCommand = async (output, context) => {
  if (output.statusCode !== 204 && output.statusCode >= 300) {
    return deserializeAws_restJson1DeleteVoiceConnectorEmergencyCallingConfigurationCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DeleteVoiceConnectorEmergencyCallingConfigurationCommand =
  deserializeAws_restJson1DeleteVoiceConnectorEmergencyCallingConfigurationCommand;
const deserializeAws_restJson1DeleteVoiceConnectorEmergencyCallingConfigurationCommandError = async (
  output,
  context
) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DeleteVoiceConnectorGroupCommand = async (output, context) => {
  if (output.statusCode !== 204 && output.statusCode >= 300) {
    return deserializeAws_restJson1DeleteVoiceConnectorGroupCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DeleteVoiceConnectorGroupCommand =
  deserializeAws_restJson1DeleteVoiceConnectorGroupCommand;
const deserializeAws_restJson1DeleteVoiceConnectorGroupCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ConflictException":
    case "com.amazonaws.chime#ConflictException":
      response = {
        ...(await deserializeAws_restJson1ConflictExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DeleteVoiceConnectorOriginationCommand = async (output, context) => {
  if (output.statusCode !== 204 && output.statusCode >= 300) {
    return deserializeAws_restJson1DeleteVoiceConnectorOriginationCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DeleteVoiceConnectorOriginationCommand =
  deserializeAws_restJson1DeleteVoiceConnectorOriginationCommand;
const deserializeAws_restJson1DeleteVoiceConnectorOriginationCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DeleteVoiceConnectorProxyCommand = async (output, context) => {
  if (output.statusCode !== 204 && output.statusCode >= 300) {
    return deserializeAws_restJson1DeleteVoiceConnectorProxyCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DeleteVoiceConnectorProxyCommand =
  deserializeAws_restJson1DeleteVoiceConnectorProxyCommand;
const deserializeAws_restJson1DeleteVoiceConnectorProxyCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DeleteVoiceConnectorStreamingConfigurationCommand = async (output, context) => {
  if (output.statusCode !== 204 && output.statusCode >= 300) {
    return deserializeAws_restJson1DeleteVoiceConnectorStreamingConfigurationCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DeleteVoiceConnectorStreamingConfigurationCommand =
  deserializeAws_restJson1DeleteVoiceConnectorStreamingConfigurationCommand;
const deserializeAws_restJson1DeleteVoiceConnectorStreamingConfigurationCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DeleteVoiceConnectorTerminationCommand = async (output, context) => {
  if (output.statusCode !== 204 && output.statusCode >= 300) {
    return deserializeAws_restJson1DeleteVoiceConnectorTerminationCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DeleteVoiceConnectorTerminationCommand =
  deserializeAws_restJson1DeleteVoiceConnectorTerminationCommand;
const deserializeAws_restJson1DeleteVoiceConnectorTerminationCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DeleteVoiceConnectorTerminationCredentialsCommand = async (output, context) => {
  if (output.statusCode !== 204 && output.statusCode >= 300) {
    return deserializeAws_restJson1DeleteVoiceConnectorTerminationCredentialsCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DeleteVoiceConnectorTerminationCredentialsCommand =
  deserializeAws_restJson1DeleteVoiceConnectorTerminationCredentialsCommand;
const deserializeAws_restJson1DeleteVoiceConnectorTerminationCredentialsCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DescribeAppInstanceCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1DescribeAppInstanceCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    AppInstance: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.AppInstance !== undefined && data.AppInstance !== null) {
    contents.AppInstance = deserializeAws_restJson1AppInstance(data.AppInstance, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DescribeAppInstanceCommand = deserializeAws_restJson1DescribeAppInstanceCommand;
const deserializeAws_restJson1DescribeAppInstanceCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DescribeAppInstanceAdminCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1DescribeAppInstanceAdminCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    AppInstanceAdmin: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.AppInstanceAdmin !== undefined && data.AppInstanceAdmin !== null) {
    contents.AppInstanceAdmin = deserializeAws_restJson1AppInstanceAdmin(data.AppInstanceAdmin, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DescribeAppInstanceAdminCommand =
  deserializeAws_restJson1DescribeAppInstanceAdminCommand;
const deserializeAws_restJson1DescribeAppInstanceAdminCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DescribeAppInstanceUserCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1DescribeAppInstanceUserCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    AppInstanceUser: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.AppInstanceUser !== undefined && data.AppInstanceUser !== null) {
    contents.AppInstanceUser = deserializeAws_restJson1AppInstanceUser(data.AppInstanceUser, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DescribeAppInstanceUserCommand = deserializeAws_restJson1DescribeAppInstanceUserCommand;
const deserializeAws_restJson1DescribeAppInstanceUserCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DescribeChannelCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1DescribeChannelCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    Channel: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.Channel !== undefined && data.Channel !== null) {
    contents.Channel = deserializeAws_restJson1Channel(data.Channel, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DescribeChannelCommand = deserializeAws_restJson1DescribeChannelCommand;
const deserializeAws_restJson1DescribeChannelCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DescribeChannelBanCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1DescribeChannelBanCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    ChannelBan: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.ChannelBan !== undefined && data.ChannelBan !== null) {
    contents.ChannelBan = deserializeAws_restJson1ChannelBan(data.ChannelBan, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DescribeChannelBanCommand = deserializeAws_restJson1DescribeChannelBanCommand;
const deserializeAws_restJson1DescribeChannelBanCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DescribeChannelMembershipCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1DescribeChannelMembershipCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    ChannelMembership: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.ChannelMembership !== undefined && data.ChannelMembership !== null) {
    contents.ChannelMembership = deserializeAws_restJson1ChannelMembership(data.ChannelMembership, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DescribeChannelMembershipCommand =
  deserializeAws_restJson1DescribeChannelMembershipCommand;
const deserializeAws_restJson1DescribeChannelMembershipCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DescribeChannelMembershipForAppInstanceUserCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1DescribeChannelMembershipForAppInstanceUserCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    ChannelMembership: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.ChannelMembership !== undefined && data.ChannelMembership !== null) {
    contents.ChannelMembership = deserializeAws_restJson1ChannelMembershipForAppInstanceUserSummary(
      data.ChannelMembership,
      context
    );
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DescribeChannelMembershipForAppInstanceUserCommand =
  deserializeAws_restJson1DescribeChannelMembershipForAppInstanceUserCommand;
const deserializeAws_restJson1DescribeChannelMembershipForAppInstanceUserCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DescribeChannelModeratedByAppInstanceUserCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1DescribeChannelModeratedByAppInstanceUserCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    Channel: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.Channel !== undefined && data.Channel !== null) {
    contents.Channel = deserializeAws_restJson1ChannelModeratedByAppInstanceUserSummary(data.Channel, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DescribeChannelModeratedByAppInstanceUserCommand =
  deserializeAws_restJson1DescribeChannelModeratedByAppInstanceUserCommand;
const deserializeAws_restJson1DescribeChannelModeratedByAppInstanceUserCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DescribeChannelModeratorCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1DescribeChannelModeratorCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    ChannelModerator: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.ChannelModerator !== undefined && data.ChannelModerator !== null) {
    contents.ChannelModerator = deserializeAws_restJson1ChannelModerator(data.ChannelModerator, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DescribeChannelModeratorCommand =
  deserializeAws_restJson1DescribeChannelModeratorCommand;
const deserializeAws_restJson1DescribeChannelModeratorCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DisassociatePhoneNumberFromUserCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1DisassociatePhoneNumberFromUserCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DisassociatePhoneNumberFromUserCommand =
  deserializeAws_restJson1DisassociatePhoneNumberFromUserCommand;
const deserializeAws_restJson1DisassociatePhoneNumberFromUserCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DisassociatePhoneNumbersFromVoiceConnectorCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1DisassociatePhoneNumbersFromVoiceConnectorCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    PhoneNumberErrors: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.PhoneNumberErrors !== undefined && data.PhoneNumberErrors !== null) {
    contents.PhoneNumberErrors = deserializeAws_restJson1PhoneNumberErrorList(data.PhoneNumberErrors, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DisassociatePhoneNumbersFromVoiceConnectorCommand =
  deserializeAws_restJson1DisassociatePhoneNumbersFromVoiceConnectorCommand;
const deserializeAws_restJson1DisassociatePhoneNumbersFromVoiceConnectorCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DisassociatePhoneNumbersFromVoiceConnectorGroupCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1DisassociatePhoneNumbersFromVoiceConnectorGroupCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    PhoneNumberErrors: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.PhoneNumberErrors !== undefined && data.PhoneNumberErrors !== null) {
    contents.PhoneNumberErrors = deserializeAws_restJson1PhoneNumberErrorList(data.PhoneNumberErrors, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DisassociatePhoneNumbersFromVoiceConnectorGroupCommand =
  deserializeAws_restJson1DisassociatePhoneNumbersFromVoiceConnectorGroupCommand;
const deserializeAws_restJson1DisassociatePhoneNumbersFromVoiceConnectorGroupCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1DisassociateSigninDelegateGroupsFromAccountCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1DisassociateSigninDelegateGroupsFromAccountCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DisassociateSigninDelegateGroupsFromAccountCommand =
  deserializeAws_restJson1DisassociateSigninDelegateGroupsFromAccountCommand;
const deserializeAws_restJson1DisassociateSigninDelegateGroupsFromAccountCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1GetAccountCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1GetAccountCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    Account: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.Account !== undefined && data.Account !== null) {
    contents.Account = deserializeAws_restJson1Account(data.Account, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1GetAccountCommand = deserializeAws_restJson1GetAccountCommand;
const deserializeAws_restJson1GetAccountCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1GetAccountSettingsCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1GetAccountSettingsCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    AccountSettings: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.AccountSettings !== undefined && data.AccountSettings !== null) {
    contents.AccountSettings = deserializeAws_restJson1AccountSettings(data.AccountSettings, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1GetAccountSettingsCommand = deserializeAws_restJson1GetAccountSettingsCommand;
const deserializeAws_restJson1GetAccountSettingsCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1GetAppInstanceRetentionSettingsCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1GetAppInstanceRetentionSettingsCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    AppInstanceRetentionSettings: undefined,
    InitiateDeletionTimestamp: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.AppInstanceRetentionSettings !== undefined && data.AppInstanceRetentionSettings !== null) {
    contents.AppInstanceRetentionSettings = deserializeAws_restJson1AppInstanceRetentionSettings(
      data.AppInstanceRetentionSettings,
      context
    );
  }
  if (data.InitiateDeletionTimestamp !== undefined && data.InitiateDeletionTimestamp !== null) {
    contents.InitiateDeletionTimestamp = new Date(Math.round(data.InitiateDeletionTimestamp * 1000));
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1GetAppInstanceRetentionSettingsCommand =
  deserializeAws_restJson1GetAppInstanceRetentionSettingsCommand;
const deserializeAws_restJson1GetAppInstanceRetentionSettingsCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1GetAppInstanceStreamingConfigurationsCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1GetAppInstanceStreamingConfigurationsCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    AppInstanceStreamingConfigurations: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.AppInstanceStreamingConfigurations !== undefined && data.AppInstanceStreamingConfigurations !== null) {
    contents.AppInstanceStreamingConfigurations = deserializeAws_restJson1AppInstanceStreamingConfigurationList(
      data.AppInstanceStreamingConfigurations,
      context
    );
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1GetAppInstanceStreamingConfigurationsCommand =
  deserializeAws_restJson1GetAppInstanceStreamingConfigurationsCommand;
const deserializeAws_restJson1GetAppInstanceStreamingConfigurationsCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1GetAttendeeCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1GetAttendeeCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    Attendee: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.Attendee !== undefined && data.Attendee !== null) {
    contents.Attendee = deserializeAws_restJson1Attendee(data.Attendee, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1GetAttendeeCommand = deserializeAws_restJson1GetAttendeeCommand;
const deserializeAws_restJson1GetAttendeeCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1GetBotCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1GetBotCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    Bot: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.Bot !== undefined && data.Bot !== null) {
    contents.Bot = deserializeAws_restJson1Bot(data.Bot, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1GetBotCommand = deserializeAws_restJson1GetBotCommand;
const deserializeAws_restJson1GetBotCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1GetChannelMessageCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1GetChannelMessageCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    ChannelMessage: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.ChannelMessage !== undefined && data.ChannelMessage !== null) {
    contents.ChannelMessage = deserializeAws_restJson1ChannelMessage(data.ChannelMessage, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1GetChannelMessageCommand = deserializeAws_restJson1GetChannelMessageCommand;
const deserializeAws_restJson1GetChannelMessageCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1GetEventsConfigurationCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1GetEventsConfigurationCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    EventsConfiguration: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.EventsConfiguration !== undefined && data.EventsConfiguration !== null) {
    contents.EventsConfiguration = deserializeAws_restJson1EventsConfiguration(data.EventsConfiguration, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1GetEventsConfigurationCommand = deserializeAws_restJson1GetEventsConfigurationCommand;
const deserializeAws_restJson1GetEventsConfigurationCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceLimitExceededException":
    case "com.amazonaws.chime#ResourceLimitExceededException":
      response = {
        ...(await deserializeAws_restJson1ResourceLimitExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1GetGlobalSettingsCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1GetGlobalSettingsCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    BusinessCalling: undefined,
    VoiceConnector: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.BusinessCalling !== undefined && data.BusinessCalling !== null) {
    contents.BusinessCalling = deserializeAws_restJson1BusinessCallingSettings(data.BusinessCalling, context);
  }
  if (data.VoiceConnector !== undefined && data.VoiceConnector !== null) {
    contents.VoiceConnector = deserializeAws_restJson1VoiceConnectorSettings(data.VoiceConnector, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1GetGlobalSettingsCommand = deserializeAws_restJson1GetGlobalSettingsCommand;
const deserializeAws_restJson1GetGlobalSettingsCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1GetMeetingCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1GetMeetingCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    Meeting: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.Meeting !== undefined && data.Meeting !== null) {
    contents.Meeting = deserializeAws_restJson1Meeting(data.Meeting, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1GetMeetingCommand = deserializeAws_restJson1GetMeetingCommand;
const deserializeAws_restJson1GetMeetingCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1GetMessagingSessionEndpointCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1GetMessagingSessionEndpointCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    Endpoint: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.Endpoint !== undefined && data.Endpoint !== null) {
    contents.Endpoint = deserializeAws_restJson1MessagingSessionEndpoint(data.Endpoint, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1GetMessagingSessionEndpointCommand =
  deserializeAws_restJson1GetMessagingSessionEndpointCommand;
const deserializeAws_restJson1GetMessagingSessionEndpointCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1GetPhoneNumberCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1GetPhoneNumberCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    PhoneNumber: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.PhoneNumber !== undefined && data.PhoneNumber !== null) {
    contents.PhoneNumber = deserializeAws_restJson1PhoneNumber(data.PhoneNumber, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1GetPhoneNumberCommand = deserializeAws_restJson1GetPhoneNumberCommand;
const deserializeAws_restJson1GetPhoneNumberCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1GetPhoneNumberOrderCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1GetPhoneNumberOrderCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    PhoneNumberOrder: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.PhoneNumberOrder !== undefined && data.PhoneNumberOrder !== null) {
    contents.PhoneNumberOrder = deserializeAws_restJson1PhoneNumberOrder(data.PhoneNumberOrder, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1GetPhoneNumberOrderCommand = deserializeAws_restJson1GetPhoneNumberOrderCommand;
const deserializeAws_restJson1GetPhoneNumberOrderCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1GetPhoneNumberSettingsCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1GetPhoneNumberSettingsCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    CallingName: undefined,
    CallingNameUpdatedTimestamp: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.CallingName !== undefined && data.CallingName !== null) {
    contents.CallingName = data.CallingName;
  }
  if (data.CallingNameUpdatedTimestamp !== undefined && data.CallingNameUpdatedTimestamp !== null) {
    contents.CallingNameUpdatedTimestamp = new Date(data.CallingNameUpdatedTimestamp);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1GetPhoneNumberSettingsCommand = deserializeAws_restJson1GetPhoneNumberSettingsCommand;
const deserializeAws_restJson1GetPhoneNumberSettingsCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1GetProxySessionCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1GetProxySessionCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    ProxySession: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.ProxySession !== undefined && data.ProxySession !== null) {
    contents.ProxySession = deserializeAws_restJson1ProxySession(data.ProxySession, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1GetProxySessionCommand = deserializeAws_restJson1GetProxySessionCommand;
const deserializeAws_restJson1GetProxySessionCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1GetRetentionSettingsCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1GetRetentionSettingsCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    InitiateDeletionTimestamp: undefined,
    RetentionSettings: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.InitiateDeletionTimestamp !== undefined && data.InitiateDeletionTimestamp !== null) {
    contents.InitiateDeletionTimestamp = new Date(data.InitiateDeletionTimestamp);
  }
  if (data.RetentionSettings !== undefined && data.RetentionSettings !== null) {
    contents.RetentionSettings = deserializeAws_restJson1RetentionSettings(data.RetentionSettings, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1GetRetentionSettingsCommand = deserializeAws_restJson1GetRetentionSettingsCommand;
const deserializeAws_restJson1GetRetentionSettingsCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1GetRoomCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1GetRoomCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    Room: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.Room !== undefined && data.Room !== null) {
    contents.Room = deserializeAws_restJson1Room(data.Room, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1GetRoomCommand = deserializeAws_restJson1GetRoomCommand;
const deserializeAws_restJson1GetRoomCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1GetSipMediaApplicationCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1GetSipMediaApplicationCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    SipMediaApplication: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.SipMediaApplication !== undefined && data.SipMediaApplication !== null) {
    contents.SipMediaApplication = deserializeAws_restJson1SipMediaApplication(data.SipMediaApplication, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1GetSipMediaApplicationCommand = deserializeAws_restJson1GetSipMediaApplicationCommand;
const deserializeAws_restJson1GetSipMediaApplicationCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1GetSipMediaApplicationLoggingConfigurationCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1GetSipMediaApplicationLoggingConfigurationCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    SipMediaApplicationLoggingConfiguration: undefined,
  };
  const data = await parseBody(output.body, context);
  if (
    data.SipMediaApplicationLoggingConfiguration !== undefined &&
    data.SipMediaApplicationLoggingConfiguration !== null
  ) {
    contents.SipMediaApplicationLoggingConfiguration = deserializeAws_restJson1SipMediaApplicationLoggingConfiguration(
      data.SipMediaApplicationLoggingConfiguration,
      context
    );
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1GetSipMediaApplicationLoggingConfigurationCommand =
  deserializeAws_restJson1GetSipMediaApplicationLoggingConfigurationCommand;
const deserializeAws_restJson1GetSipMediaApplicationLoggingConfigurationCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1GetSipRuleCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1GetSipRuleCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    SipRule: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.SipRule !== undefined && data.SipRule !== null) {
    contents.SipRule = deserializeAws_restJson1SipRule(data.SipRule, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1GetSipRuleCommand = deserializeAws_restJson1GetSipRuleCommand;
const deserializeAws_restJson1GetSipRuleCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1GetUserCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1GetUserCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    User: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.User !== undefined && data.User !== null) {
    contents.User = deserializeAws_restJson1User(data.User, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1GetUserCommand = deserializeAws_restJson1GetUserCommand;
const deserializeAws_restJson1GetUserCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1GetUserSettingsCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1GetUserSettingsCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    UserSettings: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.UserSettings !== undefined && data.UserSettings !== null) {
    contents.UserSettings = deserializeAws_restJson1UserSettings(data.UserSettings, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1GetUserSettingsCommand = deserializeAws_restJson1GetUserSettingsCommand;
const deserializeAws_restJson1GetUserSettingsCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1GetVoiceConnectorCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1GetVoiceConnectorCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    VoiceConnector: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.VoiceConnector !== undefined && data.VoiceConnector !== null) {
    contents.VoiceConnector = deserializeAws_restJson1VoiceConnector(data.VoiceConnector, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1GetVoiceConnectorCommand = deserializeAws_restJson1GetVoiceConnectorCommand;
const deserializeAws_restJson1GetVoiceConnectorCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1GetVoiceConnectorEmergencyCallingConfigurationCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1GetVoiceConnectorEmergencyCallingConfigurationCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    EmergencyCallingConfiguration: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.EmergencyCallingConfiguration !== undefined && data.EmergencyCallingConfiguration !== null) {
    contents.EmergencyCallingConfiguration = deserializeAws_restJson1EmergencyCallingConfiguration(
      data.EmergencyCallingConfiguration,
      context
    );
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1GetVoiceConnectorEmergencyCallingConfigurationCommand =
  deserializeAws_restJson1GetVoiceConnectorEmergencyCallingConfigurationCommand;
const deserializeAws_restJson1GetVoiceConnectorEmergencyCallingConfigurationCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1GetVoiceConnectorGroupCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1GetVoiceConnectorGroupCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    VoiceConnectorGroup: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.VoiceConnectorGroup !== undefined && data.VoiceConnectorGroup !== null) {
    contents.VoiceConnectorGroup = deserializeAws_restJson1VoiceConnectorGroup(data.VoiceConnectorGroup, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1GetVoiceConnectorGroupCommand = deserializeAws_restJson1GetVoiceConnectorGroupCommand;
const deserializeAws_restJson1GetVoiceConnectorGroupCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1GetVoiceConnectorLoggingConfigurationCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1GetVoiceConnectorLoggingConfigurationCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    LoggingConfiguration: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.LoggingConfiguration !== undefined && data.LoggingConfiguration !== null) {
    contents.LoggingConfiguration = deserializeAws_restJson1LoggingConfiguration(data.LoggingConfiguration, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1GetVoiceConnectorLoggingConfigurationCommand =
  deserializeAws_restJson1GetVoiceConnectorLoggingConfigurationCommand;
const deserializeAws_restJson1GetVoiceConnectorLoggingConfigurationCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1GetVoiceConnectorOriginationCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1GetVoiceConnectorOriginationCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    Origination: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.Origination !== undefined && data.Origination !== null) {
    contents.Origination = deserializeAws_restJson1Origination(data.Origination, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1GetVoiceConnectorOriginationCommand =
  deserializeAws_restJson1GetVoiceConnectorOriginationCommand;
const deserializeAws_restJson1GetVoiceConnectorOriginationCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1GetVoiceConnectorProxyCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1GetVoiceConnectorProxyCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    Proxy: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.Proxy !== undefined && data.Proxy !== null) {
    contents.Proxy = deserializeAws_restJson1Proxy(data.Proxy, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1GetVoiceConnectorProxyCommand = deserializeAws_restJson1GetVoiceConnectorProxyCommand;
const deserializeAws_restJson1GetVoiceConnectorProxyCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1GetVoiceConnectorStreamingConfigurationCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1GetVoiceConnectorStreamingConfigurationCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    StreamingConfiguration: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.StreamingConfiguration !== undefined && data.StreamingConfiguration !== null) {
    contents.StreamingConfiguration = deserializeAws_restJson1StreamingConfiguration(
      data.StreamingConfiguration,
      context
    );
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1GetVoiceConnectorStreamingConfigurationCommand =
  deserializeAws_restJson1GetVoiceConnectorStreamingConfigurationCommand;
const deserializeAws_restJson1GetVoiceConnectorStreamingConfigurationCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1GetVoiceConnectorTerminationCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1GetVoiceConnectorTerminationCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    Termination: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.Termination !== undefined && data.Termination !== null) {
    contents.Termination = deserializeAws_restJson1Termination(data.Termination, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1GetVoiceConnectorTerminationCommand =
  deserializeAws_restJson1GetVoiceConnectorTerminationCommand;
const deserializeAws_restJson1GetVoiceConnectorTerminationCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1GetVoiceConnectorTerminationHealthCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1GetVoiceConnectorTerminationHealthCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    TerminationHealth: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.TerminationHealth !== undefined && data.TerminationHealth !== null) {
    contents.TerminationHealth = deserializeAws_restJson1TerminationHealth(data.TerminationHealth, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1GetVoiceConnectorTerminationHealthCommand =
  deserializeAws_restJson1GetVoiceConnectorTerminationHealthCommand;
const deserializeAws_restJson1GetVoiceConnectorTerminationHealthCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1InviteUsersCommand = async (output, context) => {
  if (output.statusCode !== 201 && output.statusCode >= 300) {
    return deserializeAws_restJson1InviteUsersCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    Invites: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.Invites !== undefined && data.Invites !== null) {
    contents.Invites = deserializeAws_restJson1InviteList(data.Invites, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1InviteUsersCommand = deserializeAws_restJson1InviteUsersCommand;
const deserializeAws_restJson1InviteUsersCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1ListAccountsCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ListAccountsCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    Accounts: undefined,
    NextToken: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.Accounts !== undefined && data.Accounts !== null) {
    contents.Accounts = deserializeAws_restJson1AccountList(data.Accounts, context);
  }
  if (data.NextToken !== undefined && data.NextToken !== null) {
    contents.NextToken = data.NextToken;
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListAccountsCommand = deserializeAws_restJson1ListAccountsCommand;
const deserializeAws_restJson1ListAccountsCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1ListAppInstanceAdminsCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ListAppInstanceAdminsCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    AppInstanceAdmins: undefined,
    AppInstanceArn: undefined,
    NextToken: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.AppInstanceAdmins !== undefined && data.AppInstanceAdmins !== null) {
    contents.AppInstanceAdmins = deserializeAws_restJson1AppInstanceAdminList(data.AppInstanceAdmins, context);
  }
  if (data.AppInstanceArn !== undefined && data.AppInstanceArn !== null) {
    contents.AppInstanceArn = data.AppInstanceArn;
  }
  if (data.NextToken !== undefined && data.NextToken !== null) {
    contents.NextToken = data.NextToken;
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListAppInstanceAdminsCommand = deserializeAws_restJson1ListAppInstanceAdminsCommand;
const deserializeAws_restJson1ListAppInstanceAdminsCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1ListAppInstancesCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ListAppInstancesCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    AppInstances: undefined,
    NextToken: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.AppInstances !== undefined && data.AppInstances !== null) {
    contents.AppInstances = deserializeAws_restJson1AppInstanceList(data.AppInstances, context);
  }
  if (data.NextToken !== undefined && data.NextToken !== null) {
    contents.NextToken = data.NextToken;
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListAppInstancesCommand = deserializeAws_restJson1ListAppInstancesCommand;
const deserializeAws_restJson1ListAppInstancesCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1ListAppInstanceUsersCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ListAppInstanceUsersCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    AppInstanceArn: undefined,
    AppInstanceUsers: undefined,
    NextToken: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.AppInstanceArn !== undefined && data.AppInstanceArn !== null) {
    contents.AppInstanceArn = data.AppInstanceArn;
  }
  if (data.AppInstanceUsers !== undefined && data.AppInstanceUsers !== null) {
    contents.AppInstanceUsers = deserializeAws_restJson1AppInstanceUserList(data.AppInstanceUsers, context);
  }
  if (data.NextToken !== undefined && data.NextToken !== null) {
    contents.NextToken = data.NextToken;
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListAppInstanceUsersCommand = deserializeAws_restJson1ListAppInstanceUsersCommand;
const deserializeAws_restJson1ListAppInstanceUsersCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1ListAttendeesCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ListAttendeesCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    Attendees: undefined,
    NextToken: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.Attendees !== undefined && data.Attendees !== null) {
    contents.Attendees = deserializeAws_restJson1AttendeeList(data.Attendees, context);
  }
  if (data.NextToken !== undefined && data.NextToken !== null) {
    contents.NextToken = data.NextToken;
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListAttendeesCommand = deserializeAws_restJson1ListAttendeesCommand;
const deserializeAws_restJson1ListAttendeesCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1ListAttendeeTagsCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ListAttendeeTagsCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    Tags: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.Tags !== undefined && data.Tags !== null) {
    contents.Tags = deserializeAws_restJson1TagList(data.Tags, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListAttendeeTagsCommand = deserializeAws_restJson1ListAttendeeTagsCommand;
const deserializeAws_restJson1ListAttendeeTagsCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1ListBotsCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ListBotsCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    Bots: undefined,
    NextToken: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.Bots !== undefined && data.Bots !== null) {
    contents.Bots = deserializeAws_restJson1BotList(data.Bots, context);
  }
  if (data.NextToken !== undefined && data.NextToken !== null) {
    contents.NextToken = data.NextToken;
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListBotsCommand = deserializeAws_restJson1ListBotsCommand;
const deserializeAws_restJson1ListBotsCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1ListChannelBansCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ListChannelBansCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    ChannelArn: undefined,
    ChannelBans: undefined,
    NextToken: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.ChannelArn !== undefined && data.ChannelArn !== null) {
    contents.ChannelArn = data.ChannelArn;
  }
  if (data.ChannelBans !== undefined && data.ChannelBans !== null) {
    contents.ChannelBans = deserializeAws_restJson1ChannelBanSummaryList(data.ChannelBans, context);
  }
  if (data.NextToken !== undefined && data.NextToken !== null) {
    contents.NextToken = data.NextToken;
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListChannelBansCommand = deserializeAws_restJson1ListChannelBansCommand;
const deserializeAws_restJson1ListChannelBansCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1ListChannelMembershipsCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ListChannelMembershipsCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    ChannelArn: undefined,
    ChannelMemberships: undefined,
    NextToken: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.ChannelArn !== undefined && data.ChannelArn !== null) {
    contents.ChannelArn = data.ChannelArn;
  }
  if (data.ChannelMemberships !== undefined && data.ChannelMemberships !== null) {
    contents.ChannelMemberships = deserializeAws_restJson1ChannelMembershipSummaryList(
      data.ChannelMemberships,
      context
    );
  }
  if (data.NextToken !== undefined && data.NextToken !== null) {
    contents.NextToken = data.NextToken;
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListChannelMembershipsCommand = deserializeAws_restJson1ListChannelMembershipsCommand;
const deserializeAws_restJson1ListChannelMembershipsCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1ListChannelMembershipsForAppInstanceUserCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ListChannelMembershipsForAppInstanceUserCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    ChannelMemberships: undefined,
    NextToken: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.ChannelMemberships !== undefined && data.ChannelMemberships !== null) {
    contents.ChannelMemberships = deserializeAws_restJson1ChannelMembershipForAppInstanceUserSummaryList(
      data.ChannelMemberships,
      context
    );
  }
  if (data.NextToken !== undefined && data.NextToken !== null) {
    contents.NextToken = data.NextToken;
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListChannelMembershipsForAppInstanceUserCommand =
  deserializeAws_restJson1ListChannelMembershipsForAppInstanceUserCommand;
const deserializeAws_restJson1ListChannelMembershipsForAppInstanceUserCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1ListChannelMessagesCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ListChannelMessagesCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    ChannelArn: undefined,
    ChannelMessages: undefined,
    NextToken: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.ChannelArn !== undefined && data.ChannelArn !== null) {
    contents.ChannelArn = data.ChannelArn;
  }
  if (data.ChannelMessages !== undefined && data.ChannelMessages !== null) {
    contents.ChannelMessages = deserializeAws_restJson1ChannelMessageSummaryList(data.ChannelMessages, context);
  }
  if (data.NextToken !== undefined && data.NextToken !== null) {
    contents.NextToken = data.NextToken;
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListChannelMessagesCommand = deserializeAws_restJson1ListChannelMessagesCommand;
const deserializeAws_restJson1ListChannelMessagesCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1ListChannelModeratorsCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ListChannelModeratorsCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    ChannelArn: undefined,
    ChannelModerators: undefined,
    NextToken: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.ChannelArn !== undefined && data.ChannelArn !== null) {
    contents.ChannelArn = data.ChannelArn;
  }
  if (data.ChannelModerators !== undefined && data.ChannelModerators !== null) {
    contents.ChannelModerators = deserializeAws_restJson1ChannelModeratorSummaryList(data.ChannelModerators, context);
  }
  if (data.NextToken !== undefined && data.NextToken !== null) {
    contents.NextToken = data.NextToken;
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListChannelModeratorsCommand = deserializeAws_restJson1ListChannelModeratorsCommand;
const deserializeAws_restJson1ListChannelModeratorsCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1ListChannelsCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ListChannelsCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    Channels: undefined,
    NextToken: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.Channels !== undefined && data.Channels !== null) {
    contents.Channels = deserializeAws_restJson1ChannelSummaryList(data.Channels, context);
  }
  if (data.NextToken !== undefined && data.NextToken !== null) {
    contents.NextToken = data.NextToken;
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListChannelsCommand = deserializeAws_restJson1ListChannelsCommand;
const deserializeAws_restJson1ListChannelsCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1ListChannelsModeratedByAppInstanceUserCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ListChannelsModeratedByAppInstanceUserCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    Channels: undefined,
    NextToken: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.Channels !== undefined && data.Channels !== null) {
    contents.Channels = deserializeAws_restJson1ChannelModeratedByAppInstanceUserSummaryList(data.Channels, context);
  }
  if (data.NextToken !== undefined && data.NextToken !== null) {
    contents.NextToken = data.NextToken;
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListChannelsModeratedByAppInstanceUserCommand =
  deserializeAws_restJson1ListChannelsModeratedByAppInstanceUserCommand;
const deserializeAws_restJson1ListChannelsModeratedByAppInstanceUserCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1ListMeetingsCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ListMeetingsCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    Meetings: undefined,
    NextToken: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.Meetings !== undefined && data.Meetings !== null) {
    contents.Meetings = deserializeAws_restJson1MeetingList(data.Meetings, context);
  }
  if (data.NextToken !== undefined && data.NextToken !== null) {
    contents.NextToken = data.NextToken;
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListMeetingsCommand = deserializeAws_restJson1ListMeetingsCommand;
const deserializeAws_restJson1ListMeetingsCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1ListMeetingTagsCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ListMeetingTagsCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    Tags: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.Tags !== undefined && data.Tags !== null) {
    contents.Tags = deserializeAws_restJson1TagList(data.Tags, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListMeetingTagsCommand = deserializeAws_restJson1ListMeetingTagsCommand;
const deserializeAws_restJson1ListMeetingTagsCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1ListPhoneNumberOrdersCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ListPhoneNumberOrdersCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    NextToken: undefined,
    PhoneNumberOrders: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.NextToken !== undefined && data.NextToken !== null) {
    contents.NextToken = data.NextToken;
  }
  if (data.PhoneNumberOrders !== undefined && data.PhoneNumberOrders !== null) {
    contents.PhoneNumberOrders = deserializeAws_restJson1PhoneNumberOrderList(data.PhoneNumberOrders, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListPhoneNumberOrdersCommand = deserializeAws_restJson1ListPhoneNumberOrdersCommand;
const deserializeAws_restJson1ListPhoneNumberOrdersCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1ListPhoneNumbersCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ListPhoneNumbersCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    NextToken: undefined,
    PhoneNumbers: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.NextToken !== undefined && data.NextToken !== null) {
    contents.NextToken = data.NextToken;
  }
  if (data.PhoneNumbers !== undefined && data.PhoneNumbers !== null) {
    contents.PhoneNumbers = deserializeAws_restJson1PhoneNumberList(data.PhoneNumbers, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListPhoneNumbersCommand = deserializeAws_restJson1ListPhoneNumbersCommand;
const deserializeAws_restJson1ListPhoneNumbersCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1ListProxySessionsCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ListProxySessionsCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    NextToken: undefined,
    ProxySessions: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.NextToken !== undefined && data.NextToken !== null) {
    contents.NextToken = data.NextToken;
  }
  if (data.ProxySessions !== undefined && data.ProxySessions !== null) {
    contents.ProxySessions = deserializeAws_restJson1ProxySessions(data.ProxySessions, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListProxySessionsCommand = deserializeAws_restJson1ListProxySessionsCommand;
const deserializeAws_restJson1ListProxySessionsCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1ListRoomMembershipsCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ListRoomMembershipsCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    NextToken: undefined,
    RoomMemberships: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.NextToken !== undefined && data.NextToken !== null) {
    contents.NextToken = data.NextToken;
  }
  if (data.RoomMemberships !== undefined && data.RoomMemberships !== null) {
    contents.RoomMemberships = deserializeAws_restJson1RoomMembershipList(data.RoomMemberships, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListRoomMembershipsCommand = deserializeAws_restJson1ListRoomMembershipsCommand;
const deserializeAws_restJson1ListRoomMembershipsCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1ListRoomsCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ListRoomsCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    NextToken: undefined,
    Rooms: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.NextToken !== undefined && data.NextToken !== null) {
    contents.NextToken = data.NextToken;
  }
  if (data.Rooms !== undefined && data.Rooms !== null) {
    contents.Rooms = deserializeAws_restJson1RoomList(data.Rooms, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListRoomsCommand = deserializeAws_restJson1ListRoomsCommand;
const deserializeAws_restJson1ListRoomsCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1ListSipMediaApplicationsCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ListSipMediaApplicationsCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    NextToken: undefined,
    SipMediaApplications: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.NextToken !== undefined && data.NextToken !== null) {
    contents.NextToken = data.NextToken;
  }
  if (data.SipMediaApplications !== undefined && data.SipMediaApplications !== null) {
    contents.SipMediaApplications = deserializeAws_restJson1SipMediaApplicationList(data.SipMediaApplications, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListSipMediaApplicationsCommand =
  deserializeAws_restJson1ListSipMediaApplicationsCommand;
const deserializeAws_restJson1ListSipMediaApplicationsCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1ListSipRulesCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ListSipRulesCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    NextToken: undefined,
    SipRules: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.NextToken !== undefined && data.NextToken !== null) {
    contents.NextToken = data.NextToken;
  }
  if (data.SipRules !== undefined && data.SipRules !== null) {
    contents.SipRules = deserializeAws_restJson1SipRuleList(data.SipRules, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListSipRulesCommand = deserializeAws_restJson1ListSipRulesCommand;
const deserializeAws_restJson1ListSipRulesCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1ListSupportedPhoneNumberCountriesCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ListSupportedPhoneNumberCountriesCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    PhoneNumberCountries: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.PhoneNumberCountries !== undefined && data.PhoneNumberCountries !== null) {
    contents.PhoneNumberCountries = deserializeAws_restJson1PhoneNumberCountriesList(
      data.PhoneNumberCountries,
      context
    );
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListSupportedPhoneNumberCountriesCommand =
  deserializeAws_restJson1ListSupportedPhoneNumberCountriesCommand;
const deserializeAws_restJson1ListSupportedPhoneNumberCountriesCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.chime#AccessDeniedException":
      response = {
        ...(await deserializeAws_restJson1AccessDeniedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1ListTagsForResourceCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ListTagsForResourceCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    Tags: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.Tags !== undefined && data.Tags !== null) {
    contents.Tags = deserializeAws_restJson1TagList(data.Tags, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListTagsForResourceCommand = deserializeAws_restJson1ListTagsForResourceCommand;
const deserializeAws_restJson1ListTagsForResourceCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1ListUsersCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ListUsersCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    NextToken: undefined,
    Users: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.NextToken !== undefined && data.NextToken !== null) {
    contents.NextToken = data.NextToken;
  }
  if (data.Users !== undefined && data.Users !== null) {
    contents.Users = deserializeAws_restJson1UserList(data.Users, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListUsersCommand = deserializeAws_restJson1ListUsersCommand;
const deserializeAws_restJson1ListUsersCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1ListVoiceConnectorGroupsCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ListVoiceConnectorGroupsCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    NextToken: undefined,
    VoiceConnectorGroups: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.NextToken !== undefined && data.NextToken !== null) {
    contents.NextToken = data.NextToken;
  }
  if (data.VoiceConnectorGroups !== undefined && data.VoiceConnectorGroups !== null) {
    contents.VoiceConnectorGroups = deserializeAws_restJson1VoiceConnectorGroupList(data.VoiceConnectorGroups, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListVoiceConnectorGroupsCommand =
  deserializeAws_restJson1ListVoiceConnectorGroupsCommand;
const deserializeAws_restJson1ListVoiceConnectorGroupsCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1ListVoiceConnectorsCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ListVoiceConnectorsCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    NextToken: undefined,
    VoiceConnectors: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.NextToken !== undefined && data.NextToken !== null) {
    contents.NextToken = data.NextToken;
  }
  if (data.VoiceConnectors !== undefined && data.VoiceConnectors !== null) {
    contents.VoiceConnectors = deserializeAws_restJson1VoiceConnectorList(data.VoiceConnectors, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListVoiceConnectorsCommand = deserializeAws_restJson1ListVoiceConnectorsCommand;
const deserializeAws_restJson1ListVoiceConnectorsCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1ListVoiceConnectorTerminationCredentialsCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ListVoiceConnectorTerminationCredentialsCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    Usernames: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.Usernames !== undefined && data.Usernames !== null) {
    contents.Usernames = deserializeAws_restJson1SensitiveStringList(data.Usernames, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListVoiceConnectorTerminationCredentialsCommand =
  deserializeAws_restJson1ListVoiceConnectorTerminationCredentialsCommand;
const deserializeAws_restJson1ListVoiceConnectorTerminationCredentialsCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1LogoutUserCommand = async (output, context) => {
  if (output.statusCode !== 204 && output.statusCode >= 300) {
    return deserializeAws_restJson1LogoutUserCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1LogoutUserCommand = deserializeAws_restJson1LogoutUserCommand;
const deserializeAws_restJson1LogoutUserCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1PutAppInstanceRetentionSettingsCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1PutAppInstanceRetentionSettingsCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    AppInstanceRetentionSettings: undefined,
    InitiateDeletionTimestamp: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.AppInstanceRetentionSettings !== undefined && data.AppInstanceRetentionSettings !== null) {
    contents.AppInstanceRetentionSettings = deserializeAws_restJson1AppInstanceRetentionSettings(
      data.AppInstanceRetentionSettings,
      context
    );
  }
  if (data.InitiateDeletionTimestamp !== undefined && data.InitiateDeletionTimestamp !== null) {
    contents.InitiateDeletionTimestamp = new Date(Math.round(data.InitiateDeletionTimestamp * 1000));
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1PutAppInstanceRetentionSettingsCommand =
  deserializeAws_restJson1PutAppInstanceRetentionSettingsCommand;
const deserializeAws_restJson1PutAppInstanceRetentionSettingsCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ConflictException":
    case "com.amazonaws.chime#ConflictException":
      response = {
        ...(await deserializeAws_restJson1ConflictExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1PutAppInstanceStreamingConfigurationsCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1PutAppInstanceStreamingConfigurationsCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    AppInstanceStreamingConfigurations: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.AppInstanceStreamingConfigurations !== undefined && data.AppInstanceStreamingConfigurations !== null) {
    contents.AppInstanceStreamingConfigurations = deserializeAws_restJson1AppInstanceStreamingConfigurationList(
      data.AppInstanceStreamingConfigurations,
      context
    );
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1PutAppInstanceStreamingConfigurationsCommand =
  deserializeAws_restJson1PutAppInstanceStreamingConfigurationsCommand;
const deserializeAws_restJson1PutAppInstanceStreamingConfigurationsCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1PutEventsConfigurationCommand = async (output, context) => {
  if (output.statusCode !== 201 && output.statusCode >= 300) {
    return deserializeAws_restJson1PutEventsConfigurationCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    EventsConfiguration: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.EventsConfiguration !== undefined && data.EventsConfiguration !== null) {
    contents.EventsConfiguration = deserializeAws_restJson1EventsConfiguration(data.EventsConfiguration, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1PutEventsConfigurationCommand = deserializeAws_restJson1PutEventsConfigurationCommand;
const deserializeAws_restJson1PutEventsConfigurationCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceLimitExceededException":
    case "com.amazonaws.chime#ResourceLimitExceededException":
      response = {
        ...(await deserializeAws_restJson1ResourceLimitExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1PutRetentionSettingsCommand = async (output, context) => {
  if (output.statusCode !== 204 && output.statusCode >= 300) {
    return deserializeAws_restJson1PutRetentionSettingsCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    InitiateDeletionTimestamp: undefined,
    RetentionSettings: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.InitiateDeletionTimestamp !== undefined && data.InitiateDeletionTimestamp !== null) {
    contents.InitiateDeletionTimestamp = new Date(data.InitiateDeletionTimestamp);
  }
  if (data.RetentionSettings !== undefined && data.RetentionSettings !== null) {
    contents.RetentionSettings = deserializeAws_restJson1RetentionSettings(data.RetentionSettings, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1PutRetentionSettingsCommand = deserializeAws_restJson1PutRetentionSettingsCommand;
const deserializeAws_restJson1PutRetentionSettingsCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ConflictException":
    case "com.amazonaws.chime#ConflictException":
      response = {
        ...(await deserializeAws_restJson1ConflictExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1PutSipMediaApplicationLoggingConfigurationCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1PutSipMediaApplicationLoggingConfigurationCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    SipMediaApplicationLoggingConfiguration: undefined,
  };
  const data = await parseBody(output.body, context);
  if (
    data.SipMediaApplicationLoggingConfiguration !== undefined &&
    data.SipMediaApplicationLoggingConfiguration !== null
  ) {
    contents.SipMediaApplicationLoggingConfiguration = deserializeAws_restJson1SipMediaApplicationLoggingConfiguration(
      data.SipMediaApplicationLoggingConfiguration,
      context
    );
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1PutSipMediaApplicationLoggingConfigurationCommand =
  deserializeAws_restJson1PutSipMediaApplicationLoggingConfigurationCommand;
const deserializeAws_restJson1PutSipMediaApplicationLoggingConfigurationCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1PutVoiceConnectorEmergencyCallingConfigurationCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1PutVoiceConnectorEmergencyCallingConfigurationCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    EmergencyCallingConfiguration: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.EmergencyCallingConfiguration !== undefined && data.EmergencyCallingConfiguration !== null) {
    contents.EmergencyCallingConfiguration = deserializeAws_restJson1EmergencyCallingConfiguration(
      data.EmergencyCallingConfiguration,
      context
    );
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1PutVoiceConnectorEmergencyCallingConfigurationCommand =
  deserializeAws_restJson1PutVoiceConnectorEmergencyCallingConfigurationCommand;
const deserializeAws_restJson1PutVoiceConnectorEmergencyCallingConfigurationCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1PutVoiceConnectorLoggingConfigurationCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1PutVoiceConnectorLoggingConfigurationCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    LoggingConfiguration: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.LoggingConfiguration !== undefined && data.LoggingConfiguration !== null) {
    contents.LoggingConfiguration = deserializeAws_restJson1LoggingConfiguration(data.LoggingConfiguration, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1PutVoiceConnectorLoggingConfigurationCommand =
  deserializeAws_restJson1PutVoiceConnectorLoggingConfigurationCommand;
const deserializeAws_restJson1PutVoiceConnectorLoggingConfigurationCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1PutVoiceConnectorOriginationCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1PutVoiceConnectorOriginationCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    Origination: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.Origination !== undefined && data.Origination !== null) {
    contents.Origination = deserializeAws_restJson1Origination(data.Origination, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1PutVoiceConnectorOriginationCommand =
  deserializeAws_restJson1PutVoiceConnectorOriginationCommand;
const deserializeAws_restJson1PutVoiceConnectorOriginationCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1PutVoiceConnectorProxyCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1PutVoiceConnectorProxyCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    Proxy: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.Proxy !== undefined && data.Proxy !== null) {
    contents.Proxy = deserializeAws_restJson1Proxy(data.Proxy, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1PutVoiceConnectorProxyCommand = deserializeAws_restJson1PutVoiceConnectorProxyCommand;
const deserializeAws_restJson1PutVoiceConnectorProxyCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.chime#AccessDeniedException":
      response = {
        ...(await deserializeAws_restJson1AccessDeniedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1PutVoiceConnectorStreamingConfigurationCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1PutVoiceConnectorStreamingConfigurationCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    StreamingConfiguration: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.StreamingConfiguration !== undefined && data.StreamingConfiguration !== null) {
    contents.StreamingConfiguration = deserializeAws_restJson1StreamingConfiguration(
      data.StreamingConfiguration,
      context
    );
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1PutVoiceConnectorStreamingConfigurationCommand =
  deserializeAws_restJson1PutVoiceConnectorStreamingConfigurationCommand;
const deserializeAws_restJson1PutVoiceConnectorStreamingConfigurationCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1PutVoiceConnectorTerminationCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1PutVoiceConnectorTerminationCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    Termination: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.Termination !== undefined && data.Termination !== null) {
    contents.Termination = deserializeAws_restJson1Termination(data.Termination, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1PutVoiceConnectorTerminationCommand =
  deserializeAws_restJson1PutVoiceConnectorTerminationCommand;
const deserializeAws_restJson1PutVoiceConnectorTerminationCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.chime#AccessDeniedException":
      response = {
        ...(await deserializeAws_restJson1AccessDeniedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1PutVoiceConnectorTerminationCredentialsCommand = async (output, context) => {
  if (output.statusCode !== 204 && output.statusCode >= 300) {
    return deserializeAws_restJson1PutVoiceConnectorTerminationCredentialsCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1PutVoiceConnectorTerminationCredentialsCommand =
  deserializeAws_restJson1PutVoiceConnectorTerminationCredentialsCommand;
const deserializeAws_restJson1PutVoiceConnectorTerminationCredentialsCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1RedactChannelMessageCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1RedactChannelMessageCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    ChannelArn: undefined,
    MessageId: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.ChannelArn !== undefined && data.ChannelArn !== null) {
    contents.ChannelArn = data.ChannelArn;
  }
  if (data.MessageId !== undefined && data.MessageId !== null) {
    contents.MessageId = data.MessageId;
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1RedactChannelMessageCommand = deserializeAws_restJson1RedactChannelMessageCommand;
const deserializeAws_restJson1RedactChannelMessageCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1RedactConversationMessageCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1RedactConversationMessageCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1RedactConversationMessageCommand =
  deserializeAws_restJson1RedactConversationMessageCommand;
const deserializeAws_restJson1RedactConversationMessageCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1RedactRoomMessageCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1RedactRoomMessageCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1RedactRoomMessageCommand = deserializeAws_restJson1RedactRoomMessageCommand;
const deserializeAws_restJson1RedactRoomMessageCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1RegenerateSecurityTokenCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1RegenerateSecurityTokenCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    Bot: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.Bot !== undefined && data.Bot !== null) {
    contents.Bot = deserializeAws_restJson1Bot(data.Bot, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1RegenerateSecurityTokenCommand = deserializeAws_restJson1RegenerateSecurityTokenCommand;
const deserializeAws_restJson1RegenerateSecurityTokenCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1ResetPersonalPINCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ResetPersonalPINCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    User: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.User !== undefined && data.User !== null) {
    contents.User = deserializeAws_restJson1User(data.User, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ResetPersonalPINCommand = deserializeAws_restJson1ResetPersonalPINCommand;
const deserializeAws_restJson1ResetPersonalPINCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1RestorePhoneNumberCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1RestorePhoneNumberCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    PhoneNumber: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.PhoneNumber !== undefined && data.PhoneNumber !== null) {
    contents.PhoneNumber = deserializeAws_restJson1PhoneNumber(data.PhoneNumber, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1RestorePhoneNumberCommand = deserializeAws_restJson1RestorePhoneNumberCommand;
const deserializeAws_restJson1RestorePhoneNumberCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceLimitExceededException":
    case "com.amazonaws.chime#ResourceLimitExceededException":
      response = {
        ...(await deserializeAws_restJson1ResourceLimitExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1SearchAvailablePhoneNumbersCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1SearchAvailablePhoneNumbersCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    E164PhoneNumbers: undefined,
    NextToken: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.E164PhoneNumbers !== undefined && data.E164PhoneNumbers !== null) {
    contents.E164PhoneNumbers = deserializeAws_restJson1E164PhoneNumberList(data.E164PhoneNumbers, context);
  }
  if (data.NextToken !== undefined && data.NextToken !== null) {
    contents.NextToken = data.NextToken;
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1SearchAvailablePhoneNumbersCommand =
  deserializeAws_restJson1SearchAvailablePhoneNumbersCommand;
const deserializeAws_restJson1SearchAvailablePhoneNumbersCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.chime#AccessDeniedException":
      response = {
        ...(await deserializeAws_restJson1AccessDeniedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1SendChannelMessageCommand = async (output, context) => {
  if (output.statusCode !== 201 && output.statusCode >= 300) {
    return deserializeAws_restJson1SendChannelMessageCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    ChannelArn: undefined,
    MessageId: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.ChannelArn !== undefined && data.ChannelArn !== null) {
    contents.ChannelArn = data.ChannelArn;
  }
  if (data.MessageId !== undefined && data.MessageId !== null) {
    contents.MessageId = data.MessageId;
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1SendChannelMessageCommand = deserializeAws_restJson1SendChannelMessageCommand;
const deserializeAws_restJson1SendChannelMessageCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ConflictException":
    case "com.amazonaws.chime#ConflictException":
      response = {
        ...(await deserializeAws_restJson1ConflictExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1TagAttendeeCommand = async (output, context) => {
  if (output.statusCode !== 204 && output.statusCode >= 300) {
    return deserializeAws_restJson1TagAttendeeCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1TagAttendeeCommand = deserializeAws_restJson1TagAttendeeCommand;
const deserializeAws_restJson1TagAttendeeCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceLimitExceededException":
    case "com.amazonaws.chime#ResourceLimitExceededException":
      response = {
        ...(await deserializeAws_restJson1ResourceLimitExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1TagMeetingCommand = async (output, context) => {
  if (output.statusCode !== 204 && output.statusCode >= 300) {
    return deserializeAws_restJson1TagMeetingCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1TagMeetingCommand = deserializeAws_restJson1TagMeetingCommand;
const deserializeAws_restJson1TagMeetingCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceLimitExceededException":
    case "com.amazonaws.chime#ResourceLimitExceededException":
      response = {
        ...(await deserializeAws_restJson1ResourceLimitExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1TagResourceCommand = async (output, context) => {
  if (output.statusCode !== 204 && output.statusCode >= 300) {
    return deserializeAws_restJson1TagResourceCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1TagResourceCommand = deserializeAws_restJson1TagResourceCommand;
const deserializeAws_restJson1TagResourceCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1UntagAttendeeCommand = async (output, context) => {
  if (output.statusCode !== 204 && output.statusCode >= 300) {
    return deserializeAws_restJson1UntagAttendeeCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1UntagAttendeeCommand = deserializeAws_restJson1UntagAttendeeCommand;
const deserializeAws_restJson1UntagAttendeeCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1UntagMeetingCommand = async (output, context) => {
  if (output.statusCode !== 204 && output.statusCode >= 300) {
    return deserializeAws_restJson1UntagMeetingCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1UntagMeetingCommand = deserializeAws_restJson1UntagMeetingCommand;
const deserializeAws_restJson1UntagMeetingCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1UntagResourceCommand = async (output, context) => {
  if (output.statusCode !== 204 && output.statusCode >= 300) {
    return deserializeAws_restJson1UntagResourceCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1UntagResourceCommand = deserializeAws_restJson1UntagResourceCommand;
const deserializeAws_restJson1UntagResourceCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1UpdateAccountCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1UpdateAccountCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    Account: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.Account !== undefined && data.Account !== null) {
    contents.Account = deserializeAws_restJson1Account(data.Account, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1UpdateAccountCommand = deserializeAws_restJson1UpdateAccountCommand;
const deserializeAws_restJson1UpdateAccountCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1UpdateAccountSettingsCommand = async (output, context) => {
  if (output.statusCode !== 204 && output.statusCode >= 300) {
    return deserializeAws_restJson1UpdateAccountSettingsCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1UpdateAccountSettingsCommand = deserializeAws_restJson1UpdateAccountSettingsCommand;
const deserializeAws_restJson1UpdateAccountSettingsCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ConflictException":
    case "com.amazonaws.chime#ConflictException":
      response = {
        ...(await deserializeAws_restJson1ConflictExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1UpdateAppInstanceCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1UpdateAppInstanceCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    AppInstanceArn: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.AppInstanceArn !== undefined && data.AppInstanceArn !== null) {
    contents.AppInstanceArn = data.AppInstanceArn;
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1UpdateAppInstanceCommand = deserializeAws_restJson1UpdateAppInstanceCommand;
const deserializeAws_restJson1UpdateAppInstanceCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ConflictException":
    case "com.amazonaws.chime#ConflictException":
      response = {
        ...(await deserializeAws_restJson1ConflictExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1UpdateAppInstanceUserCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1UpdateAppInstanceUserCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    AppInstanceUserArn: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.AppInstanceUserArn !== undefined && data.AppInstanceUserArn !== null) {
    contents.AppInstanceUserArn = data.AppInstanceUserArn;
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1UpdateAppInstanceUserCommand = deserializeAws_restJson1UpdateAppInstanceUserCommand;
const deserializeAws_restJson1UpdateAppInstanceUserCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ConflictException":
    case "com.amazonaws.chime#ConflictException":
      response = {
        ...(await deserializeAws_restJson1ConflictExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1UpdateBotCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1UpdateBotCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    Bot: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.Bot !== undefined && data.Bot !== null) {
    contents.Bot = deserializeAws_restJson1Bot(data.Bot, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1UpdateBotCommand = deserializeAws_restJson1UpdateBotCommand;
const deserializeAws_restJson1UpdateBotCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1UpdateChannelCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1UpdateChannelCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    ChannelArn: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.ChannelArn !== undefined && data.ChannelArn !== null) {
    contents.ChannelArn = data.ChannelArn;
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1UpdateChannelCommand = deserializeAws_restJson1UpdateChannelCommand;
const deserializeAws_restJson1UpdateChannelCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ConflictException":
    case "com.amazonaws.chime#ConflictException":
      response = {
        ...(await deserializeAws_restJson1ConflictExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1UpdateChannelMessageCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1UpdateChannelMessageCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    ChannelArn: undefined,
    MessageId: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.ChannelArn !== undefined && data.ChannelArn !== null) {
    contents.ChannelArn = data.ChannelArn;
  }
  if (data.MessageId !== undefined && data.MessageId !== null) {
    contents.MessageId = data.MessageId;
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1UpdateChannelMessageCommand = deserializeAws_restJson1UpdateChannelMessageCommand;
const deserializeAws_restJson1UpdateChannelMessageCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ConflictException":
    case "com.amazonaws.chime#ConflictException":
      response = {
        ...(await deserializeAws_restJson1ConflictExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1UpdateChannelReadMarkerCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1UpdateChannelReadMarkerCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    ChannelArn: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.ChannelArn !== undefined && data.ChannelArn !== null) {
    contents.ChannelArn = data.ChannelArn;
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1UpdateChannelReadMarkerCommand = deserializeAws_restJson1UpdateChannelReadMarkerCommand;
const deserializeAws_restJson1UpdateChannelReadMarkerCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ConflictException":
    case "com.amazonaws.chime#ConflictException":
      response = {
        ...(await deserializeAws_restJson1ConflictExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1UpdateGlobalSettingsCommand = async (output, context) => {
  if (output.statusCode !== 204 && output.statusCode >= 300) {
    return deserializeAws_restJson1UpdateGlobalSettingsCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1UpdateGlobalSettingsCommand = deserializeAws_restJson1UpdateGlobalSettingsCommand;
const deserializeAws_restJson1UpdateGlobalSettingsCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1UpdatePhoneNumberCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1UpdatePhoneNumberCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    PhoneNumber: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.PhoneNumber !== undefined && data.PhoneNumber !== null) {
    contents.PhoneNumber = deserializeAws_restJson1PhoneNumber(data.PhoneNumber, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1UpdatePhoneNumberCommand = deserializeAws_restJson1UpdatePhoneNumberCommand;
const deserializeAws_restJson1UpdatePhoneNumberCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1UpdatePhoneNumberSettingsCommand = async (output, context) => {
  if (output.statusCode !== 204 && output.statusCode >= 300) {
    return deserializeAws_restJson1UpdatePhoneNumberSettingsCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1UpdatePhoneNumberSettingsCommand =
  deserializeAws_restJson1UpdatePhoneNumberSettingsCommand;
const deserializeAws_restJson1UpdatePhoneNumberSettingsCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1UpdateProxySessionCommand = async (output, context) => {
  if (output.statusCode !== 201 && output.statusCode >= 300) {
    return deserializeAws_restJson1UpdateProxySessionCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    ProxySession: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.ProxySession !== undefined && data.ProxySession !== null) {
    contents.ProxySession = deserializeAws_restJson1ProxySession(data.ProxySession, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1UpdateProxySessionCommand = deserializeAws_restJson1UpdateProxySessionCommand;
const deserializeAws_restJson1UpdateProxySessionCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1UpdateRoomCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1UpdateRoomCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    Room: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.Room !== undefined && data.Room !== null) {
    contents.Room = deserializeAws_restJson1Room(data.Room, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1UpdateRoomCommand = deserializeAws_restJson1UpdateRoomCommand;
const deserializeAws_restJson1UpdateRoomCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1UpdateRoomMembershipCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1UpdateRoomMembershipCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    RoomMembership: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.RoomMembership !== undefined && data.RoomMembership !== null) {
    contents.RoomMembership = deserializeAws_restJson1RoomMembership(data.RoomMembership, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1UpdateRoomMembershipCommand = deserializeAws_restJson1UpdateRoomMembershipCommand;
const deserializeAws_restJson1UpdateRoomMembershipCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1UpdateSipMediaApplicationCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1UpdateSipMediaApplicationCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    SipMediaApplication: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.SipMediaApplication !== undefined && data.SipMediaApplication !== null) {
    contents.SipMediaApplication = deserializeAws_restJson1SipMediaApplication(data.SipMediaApplication, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1UpdateSipMediaApplicationCommand =
  deserializeAws_restJson1UpdateSipMediaApplicationCommand;
const deserializeAws_restJson1UpdateSipMediaApplicationCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ConflictException":
    case "com.amazonaws.chime#ConflictException":
      response = {
        ...(await deserializeAws_restJson1ConflictExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1UpdateSipRuleCommand = async (output, context) => {
  if (output.statusCode !== 202 && output.statusCode >= 300) {
    return deserializeAws_restJson1UpdateSipRuleCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    SipRule: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.SipRule !== undefined && data.SipRule !== null) {
    contents.SipRule = deserializeAws_restJson1SipRule(data.SipRule, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1UpdateSipRuleCommand = deserializeAws_restJson1UpdateSipRuleCommand;
const deserializeAws_restJson1UpdateSipRuleCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ConflictException":
    case "com.amazonaws.chime#ConflictException":
      response = {
        ...(await deserializeAws_restJson1ConflictExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceLimitExceededException":
    case "com.amazonaws.chime#ResourceLimitExceededException":
      response = {
        ...(await deserializeAws_restJson1ResourceLimitExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1UpdateUserCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1UpdateUserCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    User: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.User !== undefined && data.User !== null) {
    contents.User = deserializeAws_restJson1User(data.User, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1UpdateUserCommand = deserializeAws_restJson1UpdateUserCommand;
const deserializeAws_restJson1UpdateUserCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1UpdateUserSettingsCommand = async (output, context) => {
  if (output.statusCode !== 204 && output.statusCode >= 300) {
    return deserializeAws_restJson1UpdateUserSettingsCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1UpdateUserSettingsCommand = deserializeAws_restJson1UpdateUserSettingsCommand;
const deserializeAws_restJson1UpdateUserSettingsCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1UpdateVoiceConnectorCommand = async (output, context) => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1UpdateVoiceConnectorCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    VoiceConnector: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.VoiceConnector !== undefined && data.VoiceConnector !== null) {
    contents.VoiceConnector = deserializeAws_restJson1VoiceConnector(data.VoiceConnector, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1UpdateVoiceConnectorCommand = deserializeAws_restJson1UpdateVoiceConnectorCommand;
const deserializeAws_restJson1UpdateVoiceConnectorCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1UpdateVoiceConnectorGroupCommand = async (output, context) => {
  if (output.statusCode !== 202 && output.statusCode >= 300) {
    return deserializeAws_restJson1UpdateVoiceConnectorGroupCommandError(output, context);
  }
  const contents = {
    $metadata: deserializeMetadata(output),
    VoiceConnectorGroup: undefined,
  };
  const data = await parseBody(output.body, context);
  if (data.VoiceConnectorGroup !== undefined && data.VoiceConnectorGroup !== null) {
    contents.VoiceConnectorGroup = deserializeAws_restJson1VoiceConnectorGroup(data.VoiceConnectorGroup, context);
  }
  return Promise.resolve(contents);
};
exports.deserializeAws_restJson1UpdateVoiceConnectorGroupCommand =
  deserializeAws_restJson1UpdateVoiceConnectorGroupCommand;
const deserializeAws_restJson1UpdateVoiceConnectorGroupCommandError = async (output, context) => {
  const parsedOutput = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response;
  let errorCode = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.chime#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1BadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ConflictException":
    case "com.amazonaws.chime#ConflictException":
      response = {
        ...(await deserializeAws_restJson1ConflictExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.chime#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1ForbiddenExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.chime#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1NotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.chime#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1ServiceFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.chime#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.chime#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1ThrottledClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.chime#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedClientExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      };
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};
const deserializeAws_restJson1AccessDeniedExceptionResponse = async (parsedOutput, context) => {
  const contents = {
    name: "AccessDeniedException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Code: undefined,
    Message: undefined,
  };
  const data = parsedOutput.body;
  if (data.Code !== undefined && data.Code !== null) {
    contents.Code = data.Code;
  }
  if (data.Message !== undefined && data.Message !== null) {
    contents.Message = data.Message;
  }
  return contents;
};
const deserializeAws_restJson1BadRequestExceptionResponse = async (parsedOutput, context) => {
  const contents = {
    name: "BadRequestException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Code: undefined,
    Message: undefined,
  };
  const data = parsedOutput.body;
  if (data.Code !== undefined && data.Code !== null) {
    contents.Code = data.Code;
  }
  if (data.Message !== undefined && data.Message !== null) {
    contents.Message = data.Message;
  }
  return contents;
};
const deserializeAws_restJson1ConflictExceptionResponse = async (parsedOutput, context) => {
  const contents = {
    name: "ConflictException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Code: undefined,
    Message: undefined,
  };
  const data = parsedOutput.body;
  if (data.Code !== undefined && data.Code !== null) {
    contents.Code = data.Code;
  }
  if (data.Message !== undefined && data.Message !== null) {
    contents.Message = data.Message;
  }
  return contents;
};
const deserializeAws_restJson1ForbiddenExceptionResponse = async (parsedOutput, context) => {
  const contents = {
    name: "ForbiddenException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Code: undefined,
    Message: undefined,
  };
  const data = parsedOutput.body;
  if (data.Code !== undefined && data.Code !== null) {
    contents.Code = data.Code;
  }
  if (data.Message !== undefined && data.Message !== null) {
    contents.Message = data.Message;
  }
  return contents;
};
const deserializeAws_restJson1NotFoundExceptionResponse = async (parsedOutput, context) => {
  const contents = {
    name: "NotFoundException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Code: undefined,
    Message: undefined,
  };
  const data = parsedOutput.body;
  if (data.Code !== undefined && data.Code !== null) {
    contents.Code = data.Code;
  }
  if (data.Message !== undefined && data.Message !== null) {
    contents.Message = data.Message;
  }
  return contents;
};
const deserializeAws_restJson1ResourceLimitExceededExceptionResponse = async (parsedOutput, context) => {
  const contents = {
    name: "ResourceLimitExceededException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Code: undefined,
    Message: undefined,
  };
  const data = parsedOutput.body;
  if (data.Code !== undefined && data.Code !== null) {
    contents.Code = data.Code;
  }
  if (data.Message !== undefined && data.Message !== null) {
    contents.Message = data.Message;
  }
  return contents;
};
const deserializeAws_restJson1ServiceFailureExceptionResponse = async (parsedOutput, context) => {
  const contents = {
    name: "ServiceFailureException",
    $fault: "server",
    $metadata: deserializeMetadata(parsedOutput),
    Code: undefined,
    Message: undefined,
  };
  const data = parsedOutput.body;
  if (data.Code !== undefined && data.Code !== null) {
    contents.Code = data.Code;
  }
  if (data.Message !== undefined && data.Message !== null) {
    contents.Message = data.Message;
  }
  return contents;
};
const deserializeAws_restJson1ServiceUnavailableExceptionResponse = async (parsedOutput, context) => {
  const contents = {
    name: "ServiceUnavailableException",
    $fault: "server",
    $metadata: deserializeMetadata(parsedOutput),
    Code: undefined,
    Message: undefined,
  };
  const data = parsedOutput.body;
  if (data.Code !== undefined && data.Code !== null) {
    contents.Code = data.Code;
  }
  if (data.Message !== undefined && data.Message !== null) {
    contents.Message = data.Message;
  }
  return contents;
};
const deserializeAws_restJson1ThrottledClientExceptionResponse = async (parsedOutput, context) => {
  const contents = {
    name: "ThrottledClientException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Code: undefined,
    Message: undefined,
  };
  const data = parsedOutput.body;
  if (data.Code !== undefined && data.Code !== null) {
    contents.Code = data.Code;
  }
  if (data.Message !== undefined && data.Message !== null) {
    contents.Message = data.Message;
  }
  return contents;
};
const deserializeAws_restJson1UnauthorizedClientExceptionResponse = async (parsedOutput, context) => {
  const contents = {
    name: "UnauthorizedClientException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Code: undefined,
    Message: undefined,
  };
  const data = parsedOutput.body;
  if (data.Code !== undefined && data.Code !== null) {
    contents.Code = data.Code;
  }
  if (data.Message !== undefined && data.Message !== null) {
    contents.Message = data.Message;
  }
  return contents;
};
const deserializeAws_restJson1UnprocessableEntityExceptionResponse = async (parsedOutput, context) => {
  const contents = {
    name: "UnprocessableEntityException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Code: undefined,
    Message: undefined,
  };
  const data = parsedOutput.body;
  if (data.Code !== undefined && data.Code !== null) {
    contents.Code = data.Code;
  }
  if (data.Message !== undefined && data.Message !== null) {
    contents.Message = data.Message;
  }
  return contents;
};
const serializeAws_restJson1AccountSettings = (input, context) => {
  return {
    ...(input.DisableRemoteControl !== undefined &&
      input.DisableRemoteControl !== null && { DisableRemoteControl: input.DisableRemoteControl }),
    ...(input.EnableDialOut !== undefined && input.EnableDialOut !== null && { EnableDialOut: input.EnableDialOut }),
  };
};
const serializeAws_restJson1AlexaForBusinessMetadata = (input, context) => {
  return {
    ...(input.AlexaForBusinessRoomArn !== undefined &&
      input.AlexaForBusinessRoomArn !== null && { AlexaForBusinessRoomArn: input.AlexaForBusinessRoomArn }),
    ...(input.IsAlexaForBusinessEnabled !== undefined &&
      input.IsAlexaForBusinessEnabled !== null && { IsAlexaForBusinessEnabled: input.IsAlexaForBusinessEnabled }),
  };
};
const serializeAws_restJson1AppInstanceRetentionSettings = (input, context) => {
  return {
    ...(input.ChannelRetentionSettings !== undefined &&
      input.ChannelRetentionSettings !== null && {
        ChannelRetentionSettings: serializeAws_restJson1ChannelRetentionSettings(
          input.ChannelRetentionSettings,
          context
        ),
      }),
  };
};
const serializeAws_restJson1AppInstanceStreamingConfiguration = (input, context) => {
  return {
    ...(input.AppInstanceDataType !== undefined &&
      input.AppInstanceDataType !== null && { AppInstanceDataType: input.AppInstanceDataType }),
    ...(input.ResourceArn !== undefined && input.ResourceArn !== null && { ResourceArn: input.ResourceArn }),
  };
};
const serializeAws_restJson1AppInstanceStreamingConfigurationList = (input, context) => {
  return input
    .filter((e) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null;
      }
      return serializeAws_restJson1AppInstanceStreamingConfiguration(entry, context);
    });
};
const serializeAws_restJson1AttendeeTagKeyList = (input, context) => {
  return input
    .filter((e) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null;
      }
      return entry;
    });
};
const serializeAws_restJson1AttendeeTagList = (input, context) => {
  return input
    .filter((e) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null;
      }
      return serializeAws_restJson1Tag(entry, context);
    });
};
const serializeAws_restJson1BusinessCallingSettings = (input, context) => {
  return {
    ...(input.CdrBucket !== undefined && input.CdrBucket !== null && { CdrBucket: input.CdrBucket }),
  };
};
const serializeAws_restJson1CallingRegionList = (input, context) => {
  return input
    .filter((e) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null;
      }
      return entry;
    });
};
const serializeAws_restJson1CapabilityList = (input, context) => {
  return input
    .filter((e) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null;
      }
      return entry;
    });
};
const serializeAws_restJson1ChannelRetentionSettings = (input, context) => {
  return {
    ...(input.RetentionDays !== undefined && input.RetentionDays !== null && { RetentionDays: input.RetentionDays }),
  };
};
const serializeAws_restJson1ConversationRetentionSettings = (input, context) => {
  return {
    ...(input.RetentionDays !== undefined && input.RetentionDays !== null && { RetentionDays: input.RetentionDays }),
  };
};
const serializeAws_restJson1CountryList = (input, context) => {
  return input
    .filter((e) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null;
      }
      return entry;
    });
};
const serializeAws_restJson1CreateAttendeeRequestItem = (input, context) => {
  return {
    ...(input.ExternalUserId !== undefined &&
      input.ExternalUserId !== null && { ExternalUserId: input.ExternalUserId }),
    ...(input.Tags !== undefined &&
      input.Tags !== null && { Tags: serializeAws_restJson1AttendeeTagList(input.Tags, context) }),
  };
};
const serializeAws_restJson1CreateAttendeeRequestItemList = (input, context) => {
  return input
    .filter((e) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null;
      }
      return serializeAws_restJson1CreateAttendeeRequestItem(entry, context);
    });
};
const serializeAws_restJson1CreateMeetingWithAttendeesRequestItemList = (input, context) => {
  return input
    .filter((e) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null;
      }
      return serializeAws_restJson1CreateAttendeeRequestItem(entry, context);
    });
};
const serializeAws_restJson1Credential = (input, context) => {
  return {
    ...(input.Password !== undefined && input.Password !== null && { Password: input.Password }),
    ...(input.Username !== undefined && input.Username !== null && { Username: input.Username }),
  };
};
const serializeAws_restJson1CredentialList = (input, context) => {
  return input
    .filter((e) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null;
      }
      return serializeAws_restJson1Credential(entry, context);
    });
};
const serializeAws_restJson1DNISEmergencyCallingConfiguration = (input, context) => {
  return {
    ...(input.CallingCountry !== undefined &&
      input.CallingCountry !== null && { CallingCountry: input.CallingCountry }),
    ...(input.EmergencyPhoneNumber !== undefined &&
      input.EmergencyPhoneNumber !== null && { EmergencyPhoneNumber: input.EmergencyPhoneNumber }),
    ...(input.TestPhoneNumber !== undefined &&
      input.TestPhoneNumber !== null && { TestPhoneNumber: input.TestPhoneNumber }),
  };
};
const serializeAws_restJson1DNISEmergencyCallingConfigurationList = (input, context) => {
  return input
    .filter((e) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null;
      }
      return serializeAws_restJson1DNISEmergencyCallingConfiguration(entry, context);
    });
};
const serializeAws_restJson1E164PhoneNumberList = (input, context) => {
  return input
    .filter((e) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null;
      }
      return entry;
    });
};
const serializeAws_restJson1EmergencyCallingConfiguration = (input, context) => {
  return {
    ...(input.DNIS !== undefined &&
      input.DNIS !== null && {
        DNIS: serializeAws_restJson1DNISEmergencyCallingConfigurationList(input.DNIS, context),
      }),
  };
};
const serializeAws_restJson1GeoMatchParams = (input, context) => {
  return {
    ...(input.AreaCode !== undefined && input.AreaCode !== null && { AreaCode: input.AreaCode }),
    ...(input.Country !== undefined && input.Country !== null && { Country: input.Country }),
  };
};
const serializeAws_restJson1LoggingConfiguration = (input, context) => {
  return {
    ...(input.EnableSIPLogs !== undefined && input.EnableSIPLogs !== null && { EnableSIPLogs: input.EnableSIPLogs }),
  };
};
const serializeAws_restJson1MeetingNotificationConfiguration = (input, context) => {
  return {
    ...(input.SnsTopicArn !== undefined && input.SnsTopicArn !== null && { SnsTopicArn: input.SnsTopicArn }),
    ...(input.SqsQueueArn !== undefined && input.SqsQueueArn !== null && { SqsQueueArn: input.SqsQueueArn }),
  };
};
const serializeAws_restJson1MeetingTagKeyList = (input, context) => {
  return input
    .filter((e) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null;
      }
      return entry;
    });
};
const serializeAws_restJson1MeetingTagList = (input, context) => {
  return input
    .filter((e) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null;
      }
      return serializeAws_restJson1Tag(entry, context);
    });
};
const serializeAws_restJson1MemberArns = (input, context) => {
  return input
    .filter((e) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null;
      }
      return entry;
    });
};
const serializeAws_restJson1MembershipItem = (input, context) => {
  return {
    ...(input.MemberId !== undefined && input.MemberId !== null && { MemberId: input.MemberId }),
    ...(input.Role !== undefined && input.Role !== null && { Role: input.Role }),
  };
};
const serializeAws_restJson1MembershipItemList = (input, context) => {
  return input
    .filter((e) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null;
      }
      return serializeAws_restJson1MembershipItem(entry, context);
    });
};
const serializeAws_restJson1NonEmptyStringList = (input, context) => {
  return input
    .filter((e) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null;
      }
      return entry;
    });
};
const serializeAws_restJson1Origination = (input, context) => {
  return {
    ...(input.Disabled !== undefined && input.Disabled !== null && { Disabled: input.Disabled }),
    ...(input.Routes !== undefined &&
      input.Routes !== null && { Routes: serializeAws_restJson1OriginationRouteList(input.Routes, context) }),
  };
};
const serializeAws_restJson1OriginationRoute = (input, context) => {
  return {
    ...(input.Host !== undefined && input.Host !== null && { Host: input.Host }),
    ...(input.Port !== undefined && input.Port !== null && { Port: input.Port }),
    ...(input.Priority !== undefined && input.Priority !== null && { Priority: input.Priority }),
    ...(input.Protocol !== undefined && input.Protocol !== null && { Protocol: input.Protocol }),
    ...(input.Weight !== undefined && input.Weight !== null && { Weight: input.Weight }),
  };
};
const serializeAws_restJson1OriginationRouteList = (input, context) => {
  return input
    .filter((e) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null;
      }
      return serializeAws_restJson1OriginationRoute(entry, context);
    });
};
const serializeAws_restJson1ParticipantPhoneNumberList = (input, context) => {
  return input
    .filter((e) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null;
      }
      return entry;
    });
};
const serializeAws_restJson1RetentionSettings = (input, context) => {
  return {
    ...(input.ConversationRetentionSettings !== undefined &&
      input.ConversationRetentionSettings !== null && {
        ConversationRetentionSettings: serializeAws_restJson1ConversationRetentionSettings(
          input.ConversationRetentionSettings,
          context
        ),
      }),
    ...(input.RoomRetentionSettings !== undefined &&
      input.RoomRetentionSettings !== null && {
        RoomRetentionSettings: serializeAws_restJson1RoomRetentionSettings(input.RoomRetentionSettings, context),
      }),
  };
};
const serializeAws_restJson1RoomRetentionSettings = (input, context) => {
  return {
    ...(input.RetentionDays !== undefined && input.RetentionDays !== null && { RetentionDays: input.RetentionDays }),
  };
};
const serializeAws_restJson1SensitiveStringList = (input, context) => {
  return input
    .filter((e) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null;
      }
      return entry;
    });
};
const serializeAws_restJson1SigninDelegateGroup = (input, context) => {
  return {
    ...(input.GroupName !== undefined && input.GroupName !== null && { GroupName: input.GroupName }),
  };
};
const serializeAws_restJson1SigninDelegateGroupList = (input, context) => {
  return input
    .filter((e) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null;
      }
      return serializeAws_restJson1SigninDelegateGroup(entry, context);
    });
};
const serializeAws_restJson1SipMediaApplicationEndpoint = (input, context) => {
  return {
    ...(input.LambdaArn !== undefined && input.LambdaArn !== null && { LambdaArn: input.LambdaArn }),
  };
};
const serializeAws_restJson1SipMediaApplicationEndpointList = (input, context) => {
  return input
    .filter((e) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null;
      }
      return serializeAws_restJson1SipMediaApplicationEndpoint(entry, context);
    });
};
const serializeAws_restJson1SipMediaApplicationLoggingConfiguration = (input, context) => {
  return {
    ...(input.EnableSipMediaApplicationMessageLogs !== undefined &&
      input.EnableSipMediaApplicationMessageLogs !== null && {
        EnableSipMediaApplicationMessageLogs: input.EnableSipMediaApplicationMessageLogs,
      }),
  };
};
const serializeAws_restJson1SipRuleTargetApplication = (input, context) => {
  return {
    ...(input.AwsRegion !== undefined && input.AwsRegion !== null && { AwsRegion: input.AwsRegion }),
    ...(input.Priority !== undefined && input.Priority !== null && { Priority: input.Priority }),
    ...(input.SipMediaApplicationId !== undefined &&
      input.SipMediaApplicationId !== null && { SipMediaApplicationId: input.SipMediaApplicationId }),
  };
};
const serializeAws_restJson1SipRuleTargetApplicationList = (input, context) => {
  return input
    .filter((e) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null;
      }
      return serializeAws_restJson1SipRuleTargetApplication(entry, context);
    });
};
const serializeAws_restJson1StreamingConfiguration = (input, context) => {
  return {
    ...(input.DataRetentionInHours !== undefined &&
      input.DataRetentionInHours !== null && { DataRetentionInHours: input.DataRetentionInHours }),
    ...(input.Disabled !== undefined && input.Disabled !== null && { Disabled: input.Disabled }),
    ...(input.StreamingNotificationTargets !== undefined &&
      input.StreamingNotificationTargets !== null && {
        StreamingNotificationTargets: serializeAws_restJson1StreamingNotificationTargetList(
          input.StreamingNotificationTargets,
          context
        ),
      }),
  };
};
const serializeAws_restJson1StreamingNotificationTarget = (input, context) => {
  return {
    ...(input.NotificationTarget !== undefined &&
      input.NotificationTarget !== null && { NotificationTarget: input.NotificationTarget }),
  };
};
const serializeAws_restJson1StreamingNotificationTargetList = (input, context) => {
  return input
    .filter((e) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null;
      }
      return serializeAws_restJson1StreamingNotificationTarget(entry, context);
    });
};
const serializeAws_restJson1StringList = (input, context) => {
  return input
    .filter((e) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null;
      }
      return entry;
    });
};
const serializeAws_restJson1Tag = (input, context) => {
  return {
    ...(input.Key !== undefined && input.Key !== null && { Key: input.Key }),
    ...(input.Value !== undefined && input.Value !== null && { Value: input.Value }),
  };
};
const serializeAws_restJson1TagKeyList = (input, context) => {
  return input
    .filter((e) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null;
      }
      return entry;
    });
};
const serializeAws_restJson1TagList = (input, context) => {
  return input
    .filter((e) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null;
      }
      return serializeAws_restJson1Tag(entry, context);
    });
};
const serializeAws_restJson1TelephonySettings = (input, context) => {
  return {
    ...(input.InboundCalling !== undefined &&
      input.InboundCalling !== null && { InboundCalling: input.InboundCalling }),
    ...(input.OutboundCalling !== undefined &&
      input.OutboundCalling !== null && { OutboundCalling: input.OutboundCalling }),
    ...(input.SMS !== undefined && input.SMS !== null && { SMS: input.SMS }),
  };
};
const serializeAws_restJson1Termination = (input, context) => {
  return {
    ...(input.CallingRegions !== undefined &&
      input.CallingRegions !== null && {
        CallingRegions: serializeAws_restJson1CallingRegionList(input.CallingRegions, context),
      }),
    ...(input.CidrAllowedList !== undefined &&
      input.CidrAllowedList !== null && {
        CidrAllowedList: serializeAws_restJson1StringList(input.CidrAllowedList, context),
      }),
    ...(input.CpsLimit !== undefined && input.CpsLimit !== null && { CpsLimit: input.CpsLimit }),
    ...(input.DefaultPhoneNumber !== undefined &&
      input.DefaultPhoneNumber !== null && { DefaultPhoneNumber: input.DefaultPhoneNumber }),
    ...(input.Disabled !== undefined && input.Disabled !== null && { Disabled: input.Disabled }),
  };
};
const serializeAws_restJson1UpdatePhoneNumberRequestItem = (input, context) => {
  return {
    ...(input.CallingName !== undefined && input.CallingName !== null && { CallingName: input.CallingName }),
    ...(input.PhoneNumberId !== undefined && input.PhoneNumberId !== null && { PhoneNumberId: input.PhoneNumberId }),
    ...(input.ProductType !== undefined && input.ProductType !== null && { ProductType: input.ProductType }),
  };
};
const serializeAws_restJson1UpdatePhoneNumberRequestItemList = (input, context) => {
  return input
    .filter((e) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null;
      }
      return serializeAws_restJson1UpdatePhoneNumberRequestItem(entry, context);
    });
};
const serializeAws_restJson1UpdateUserRequestItem = (input, context) => {
  return {
    ...(input.AlexaForBusinessMetadata !== undefined &&
      input.AlexaForBusinessMetadata !== null && {
        AlexaForBusinessMetadata: serializeAws_restJson1AlexaForBusinessMetadata(
          input.AlexaForBusinessMetadata,
          context
        ),
      }),
    ...(input.LicenseType !== undefined && input.LicenseType !== null && { LicenseType: input.LicenseType }),
    ...(input.UserId !== undefined && input.UserId !== null && { UserId: input.UserId }),
    ...(input.UserType !== undefined && input.UserType !== null && { UserType: input.UserType }),
  };
};
const serializeAws_restJson1UpdateUserRequestItemList = (input, context) => {
  return input
    .filter((e) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null;
      }
      return serializeAws_restJson1UpdateUserRequestItem(entry, context);
    });
};
const serializeAws_restJson1UserEmailList = (input, context) => {
  return input
    .filter((e) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null;
      }
      return entry;
    });
};
const serializeAws_restJson1UserIdList = (input, context) => {
  return input
    .filter((e) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null;
      }
      return entry;
    });
};
const serializeAws_restJson1UserSettings = (input, context) => {
  return {
    ...(input.Telephony !== undefined &&
      input.Telephony !== null && { Telephony: serializeAws_restJson1TelephonySettings(input.Telephony, context) }),
  };
};
const serializeAws_restJson1VoiceConnectorItem = (input, context) => {
  return {
    ...(input.Priority !== undefined && input.Priority !== null && { Priority: input.Priority }),
    ...(input.VoiceConnectorId !== undefined &&
      input.VoiceConnectorId !== null && { VoiceConnectorId: input.VoiceConnectorId }),
  };
};
const serializeAws_restJson1VoiceConnectorItemList = (input, context) => {
  return input
    .filter((e) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null;
      }
      return serializeAws_restJson1VoiceConnectorItem(entry, context);
    });
};
const serializeAws_restJson1VoiceConnectorSettings = (input, context) => {
  return {
    ...(input.CdrBucket !== undefined && input.CdrBucket !== null && { CdrBucket: input.CdrBucket }),
  };
};
const deserializeAws_restJson1Account = (output, context) => {
  return {
    AccountId: output.AccountId !== undefined && output.AccountId !== null ? output.AccountId : undefined,
    AccountType: output.AccountType !== undefined && output.AccountType !== null ? output.AccountType : undefined,
    AwsAccountId: output.AwsAccountId !== undefined && output.AwsAccountId !== null ? output.AwsAccountId : undefined,
    CreatedTimestamp:
      output.CreatedTimestamp !== undefined && output.CreatedTimestamp !== null
        ? new Date(output.CreatedTimestamp)
        : undefined,
    DefaultLicense:
      output.DefaultLicense !== undefined && output.DefaultLicense !== null ? output.DefaultLicense : undefined,
    Name: output.Name !== undefined && output.Name !== null ? output.Name : undefined,
    SigninDelegateGroups:
      output.SigninDelegateGroups !== undefined && output.SigninDelegateGroups !== null
        ? deserializeAws_restJson1SigninDelegateGroupList(output.SigninDelegateGroups, context)
        : undefined,
    SupportedLicenses:
      output.SupportedLicenses !== undefined && output.SupportedLicenses !== null
        ? deserializeAws_restJson1LicenseList(output.SupportedLicenses, context)
        : undefined,
  };
};
const deserializeAws_restJson1AccountList = (output, context) => {
  return (output || [])
    .filter((e) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null;
      }
      return deserializeAws_restJson1Account(entry, context);
    });
};
const deserializeAws_restJson1AccountSettings = (output, context) => {
  return {
    DisableRemoteControl:
      output.DisableRemoteControl !== undefined && output.DisableRemoteControl !== null
        ? output.DisableRemoteControl
        : undefined,
    EnableDialOut:
      output.EnableDialOut !== undefined && output.EnableDialOut !== null ? output.EnableDialOut : undefined,
  };
};
const deserializeAws_restJson1AlexaForBusinessMetadata = (output, context) => {
  return {
    AlexaForBusinessRoomArn:
      output.AlexaForBusinessRoomArn !== undefined && output.AlexaForBusinessRoomArn !== null
        ? output.AlexaForBusinessRoomArn
        : undefined,
    IsAlexaForBusinessEnabled:
      output.IsAlexaForBusinessEnabled !== undefined && output.IsAlexaForBusinessEnabled !== null
        ? output.IsAlexaForBusinessEnabled
        : undefined,
  };
};
const deserializeAws_restJson1AppInstance = (output, context) => {
  return {
    AppInstanceArn:
      output.AppInstanceArn !== undefined && output.AppInstanceArn !== null ? output.AppInstanceArn : undefined,
    CreatedTimestamp:
      output.CreatedTimestamp !== undefined && output.CreatedTimestamp !== null
        ? new Date(Math.round(output.CreatedTimestamp * 1000))
        : undefined,
    LastUpdatedTimestamp:
      output.LastUpdatedTimestamp !== undefined && output.LastUpdatedTimestamp !== null
        ? new Date(Math.round(output.LastUpdatedTimestamp * 1000))
        : undefined,
    Metadata: output.Metadata !== undefined && output.Metadata !== null ? output.Metadata : undefined,
    Name: output.Name !== undefined && output.Name !== null ? output.Name : undefined,
  };
};
const deserializeAws_restJson1AppInstanceAdmin = (output, context) => {
  return {
    Admin:
      output.Admin !== undefined && output.Admin !== null
        ? deserializeAws_restJson1Identity(output.Admin, context)
        : undefined,
    AppInstanceArn:
      output.AppInstanceArn !== undefined && output.AppInstanceArn !== null ? output.AppInstanceArn : undefined,
    CreatedTimestamp:
      output.CreatedTimestamp !== undefined && output.CreatedTimestamp !== null
        ? new Date(Math.round(output.CreatedTimestamp * 1000))
        : undefined,
  };
};
const deserializeAws_restJson1AppInstanceAdminList = (output, context) => {
  return (output || [])
    .filter((e) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null;
      }
      return deserializeAws_restJson1AppInstanceAdminSummary(entry, context);
    });
};
const deserializeAws_restJson1AppInstanceAdminSummary = (output, context) => {
  return {
    Admin:
      output.Admin !== undefined && output.Admin !== null
        ? deserializeAws_restJson1Identity(output.Admin, context)
        : undefined,
  };
};
const deserializeAws_restJson1AppInstanceList = (output, context) => {
  return (output || [])
    .filter((e) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null;
      }
      return deserializeAws_restJson1AppInstanceSummary(entry, context);
    });
};
const deserializeAws_restJson1AppInstanceRetentionSettings = (output, context) => {
  return {
    ChannelRetentionSettings:
      output.ChannelRetentionSettings !== undefined && output.ChannelRetentionSettings !== null
        ? deserializeAws_restJson1ChannelRetentionSettings(output.ChannelRetentionSettings, context)
        : undefined,
  };
};
const deserializeAws_restJson1AppInstanceStreamingConfiguration = (output, context) => {
  return {
    AppInstanceDataType:
      output.AppInstanceDataType !== undefined && output.AppInstanceDataType !== null
        ? output.AppInstanceDataType
        : undefined,
    ResourceArn: output.ResourceArn !== undefined && output.ResourceArn !== null ? output.ResourceArn : undefined,
  };
};
const deserializeAws_restJson1AppInstanceStreamingConfigurationList = (output, context) => {
  return (output || [])
    .filter((e) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null;
      }
      return deserializeAws_restJson1AppInstanceStreamingConfiguration(entry, context);
    });
};
const deserializeAws_restJson1AppInstanceSummary = (output, context) => {
  return {
    AppInstanceArn:
      output.AppInstanceArn !== undefined && output.AppInstanceArn !== null ? output.AppInstanceArn : undefined,
    Metadata: output.Metadata !== undefined && output.Metadata !== null ? output.Metadata : undefined,
    Name: output.Name !== undefined && output.Name !== null ? output.Name : undefined,
  };
};
const deserializeAws_restJson1AppInstanceUser = (output, context) => {
  return {
    AppInstanceUserArn:
      output.AppInstanceUserArn !== undefined && output.AppInstanceUserArn !== null
        ? output.AppInstanceUserArn
        : undefined,
    CreatedTimestamp:
      output.CreatedTimestamp !== undefined && output.CreatedTimestamp !== null
        ? new Date(Math.round(output.CreatedTimestamp * 1000))
        : undefined,
    LastUpdatedTimestamp:
      output.LastUpdatedTimestamp !== undefined && output.LastUpdatedTimestamp !== null
        ? new Date(Math.round(output.LastUpdatedTimestamp * 1000))
        : undefined,
    Metadata: output.Metadata !== undefined && output.Metadata !== null ? output.Metadata : undefined,
    Name: output.Name !== undefined && output.Name !== null ? output.Name : undefined,
  };
};
const deserializeAws_restJson1AppInstanceUserList = (output, context) => {
  return (output || [])
    .filter((e) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null;
      }
      return deserializeAws_restJson1AppInstanceUserSummary(entry, context);
    });
};
const deserializeAws_restJson1AppInstanceUserMembershipSummary = (output, context) => {
  return {
    ReadMarkerTimestamp:
      output.ReadMarkerTimestamp !== undefined && output.ReadMarkerTimestamp !== null
        ? new Date(Math.round(output.ReadMarkerTimestamp * 1000))
        : undefined,
    Type: output.Type !== undefined && output.Type !== null ? output.Type : undefined,
  };
};
const deserializeAws_restJson1AppInstanceUserSummary = (output, context) => {
  return {
    AppInstanceUserArn:
      output.AppInstanceUserArn !== undefined && output.AppInstanceUserArn !== null
        ? output.AppInstanceUserArn
        : undefined,
    Metadata: output.Metadata !== undefined && output.Metadata !== null ? output.Metadata : undefined,
    Name: output.Name !== undefined && output.Name !== null ? output.Name : undefined,
  };
};
const deserializeAws_restJson1Attendee = (output, context) => {
  return {
    AttendeeId: output.AttendeeId !== undefined && output.AttendeeId !== null ? output.AttendeeId : undefined,
    ExternalUserId:
      output.ExternalUserId !== undefined && output.ExternalUserId !== null ? output.ExternalUserId : undefined,
    JoinToken: output.JoinToken !== undefined && output.JoinToken !== null ? output.JoinToken : undefined,
  };
};
const deserializeAws_restJson1AttendeeList = (output, context) => {
  return (output || [])
    .filter((e) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null;
      }
      return deserializeAws_restJson1Attendee(entry, context);
    });
};
const deserializeAws_restJson1BatchChannelMemberships = (output, context) => {
  return {
    ChannelArn: output.ChannelArn !== undefined && output.ChannelArn !== null ? output.ChannelArn : undefined,
    InvitedBy:
      output.InvitedBy !== undefined && output.InvitedBy !== null
        ? deserializeAws_restJson1Identity(output.InvitedBy, context)
        : undefined,
    Members:
      output.Members !== undefined && output.Members !== null
        ? deserializeAws_restJson1Members(output.Members, context)
        : undefined,
    Type: output.Type !== undefined && output.Type !== null ? output.Type : undefined,
  };
};
const deserializeAws_restJson1BatchCreateAttendeeErrorList = (output, context) => {
  return (output || [])
    .filter((e) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null;
      }
      return deserializeAws_restJson1CreateAttendeeError(entry, context);
    });
};
const deserializeAws_restJson1BatchCreateChannelMembershipError = (output, context) => {
  return {
    ErrorCode: output.ErrorCode !== undefined && output.ErrorCode !== null ? output.ErrorCode : undefined,
    ErrorMessage: output.ErrorMessage !== undefined && output.ErrorMessage !== null ? output.ErrorMessage : undefined,
    MemberArn: output.MemberArn !== undefined && output.MemberArn !== null ? output.MemberArn : undefined,
  };
};
const deserializeAws_restJson1BatchCreateChannelMembershipErrors = (output, context) => {
  return (output || [])
    .filter((e) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null;
      }
      return deserializeAws_restJson1BatchCreateChannelMembershipError(entry, context);
    });
};
const deserializeAws_restJson1Bot = (output, context) => {
  return {
    BotEmail: output.BotEmail !== undefined && output.BotEmail !== null ? output.BotEmail : undefined,
    BotId: output.BotId !== undefined && output.BotId !== null ? output.BotId : undefined,
    BotType: output.BotType !== undefined && output.BotType !== null ? output.BotType : undefined,
    CreatedTimestamp:
      output.CreatedTimestamp !== undefined && output.CreatedTimestamp !== null
        ? new Date(output.CreatedTimestamp)
        : undefined,
    Disabled: output.Disabled !== undefined && output.Disabled !== null ? output.Disabled : undefined,
    DisplayName: output.DisplayName !== undefined && output.DisplayName !== null ? output.DisplayName : undefined,
    SecurityToken:
      output.SecurityToken !== undefined && output.SecurityToken !== null ? output.SecurityToken : undefined,
    UpdatedTimestamp:
      output.UpdatedTimestamp !== undefined && output.UpdatedTimestamp !== null
        ? new Date(output.UpdatedTimestamp)
        : undefined,
    UserId: output.UserId !== undefined && output.UserId !== null ? output.UserId : undefined,
  };
};
const deserializeAws_restJson1BotList = (output, context) => {
  return (output || [])
    .filter((e) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null;
      }
      return deserializeAws_restJson1Bot(entry, context);
    });
};
const deserializeAws_restJson1BusinessCallingSettings = (output, context) => {
  return {
    CdrBucket: output.CdrBucket !== undefined && output.CdrBucket !== null ? output.CdrBucket : undefined,
  };
};
const deserializeAws_restJson1CallingRegionList = (output, context) => {
  return (output || [])
    .filter((e) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null;
      }
      return entry;
    });
};
const deserializeAws_restJson1CapabilityList = (output, context) => {
  return (output || [])
    .filter((e) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null;
      }
      return entry;
    });
};
const deserializeAws_restJson1Channel = (output, context) => {
  return {
    ChannelArn: output.ChannelArn !== undefined && output.ChannelArn !== null ? output.ChannelArn : undefined,
    CreatedBy:
      output.CreatedBy !== undefined && output.CreatedBy !== null
        ? deserializeAws_restJson1Identity(output.CreatedBy, context)
        : undefined,
    CreatedTimestamp:
      output.CreatedTimestamp !== undefined && output.CreatedTimestamp !== null
        ? new Date(Math.round(output.CreatedTimestamp * 1000))
        : undefined,
    LastMessageTimestamp:
      output.LastMessageTimestamp !== undefined && output.LastMessageTimestamp !== null
        ? new Date(Math.round(output.LastMessageTimestamp * 1000))
        : undefined,
    LastUpdatedTimestamp:
      output.LastUpdatedTimestamp !== undefined && output.LastUpdatedTimestamp !== null
        ? new Date(Math.round(output.LastUpdatedTimestamp * 1000))
        : undefined,
    Metadata: output.Metadata !== undefined && output.Metadata !== null ? output.Metadata : undefined,
    Mode: output.Mode !== undefined && output.Mode !== null ? output.Mode : undefined,
    Name: output.Name !== undefined && output.Name !== null ? output.Name : undefined,
    Privacy: output.Privacy !== undefined && output.Privacy !== null ? output.Privacy : undefined,
  };
};
const deserializeAws_restJson1ChannelBan = (output, context) => {
  return {
    ChannelArn: output.ChannelArn !== undefined && output.ChannelArn !== null ? output.ChannelArn : undefined,
    CreatedBy:
      output.CreatedBy !== undefined && output.CreatedBy !== null
        ? deserializeAws_restJson1Identity(output.CreatedBy, context)
        : undefined,
    CreatedTimestamp:
      output.CreatedTimestamp !== undefined && output.CreatedTimestamp !== null
        ? new Date(Math.round(output.CreatedTimestamp * 1000))
        : undefined,
    Member:
      output.Member !== undefined && output.Member !== null
        ? deserializeAws_restJson1Identity(output.Member, context)
        : undefined,
  };
};
const deserializeAws_restJson1ChannelBanSummary = (output, context) => {
  return {
    Member:
      output.Member !== undefined && output.Member !== null
        ? deserializeAws_restJson1Identity(output.Member, context)
        : undefined,
  };
};
const deserializeAws_restJson1ChannelBanSummaryList = (output, context) => {
  return (output || [])
    .filter((e) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null;
      }
      return deserializeAws_restJson1ChannelBanSummary(entry, context);
    });
};
const deserializeAws_restJson1ChannelMembership = (output, context) => {
  return {
    ChannelArn: output.ChannelArn !== undefined && output.ChannelArn !== null ? output.ChannelArn : undefined,
    CreatedTimestamp:
      output.CreatedTimestamp !== undefined && output.CreatedTimestamp !== null
        ? new Date(Math.round(output.CreatedTimestamp * 1000))
        : undefined,
    InvitedBy:
      output.InvitedBy !== undefined && output.InvitedBy !== null
        ? deserializeAws_restJson1Identity(output.InvitedBy, context)
        : undefined,
    LastUpdatedTimestamp:
      output.LastUpdatedTimestamp !== undefined && output.LastUpdatedTimestamp !== null
        ? new Date(Math.round(output.LastUpdatedTimestamp * 1000))
        : undefined,
    Member:
      output.Member !== undefined && output.Member !== null
        ? deserializeAws_restJson1Identity(output.Member, context)
        : undefined,
    Type: output.Type !== undefined && output.Type !== null ? output.Type : undefined,
  };
};
const deserializeAws_restJson1ChannelMembershipForAppInstanceUserSummary = (output, context) => {
  return {
    AppInstanceUserMembershipSummary:
      output.AppInstanceUserMembershipSummary !== undefined && output.AppInstanceUserMembershipSummary !== null
        ? deserializeAws_restJson1AppInstanceUserMembershipSummary(output.AppInstanceUserMembershipSummary, context)
        : undefined,
    ChannelSummary:
      output.ChannelSummary !== undefined && output.ChannelSummary !== null
        ? deserializeAws_restJson1ChannelSummary(output.ChannelSummary, context)
        : undefined,
  };
};
const deserializeAws_restJson1ChannelMembershipForAppInstanceUserSummaryList = (output, context) => {
  return (output || [])
    .filter((e) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null;
      }
      return deserializeAws_restJson1ChannelMembershipForAppInstanceUserSummary(entry, context);
    });
};
const deserializeAws_restJson1ChannelMembershipSummary = (output, context) => {
  return {
    Member:
      output.Member !== undefined && output.Member !== null
        ? deserializeAws_restJson1Identity(output.Member, context)
        : undefined,
  };
};
const deserializeAws_restJson1ChannelMembershipSummaryList = (output, context) => {
  return (output || [])
    .filter((e) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null;
      }
      return deserializeAws_restJson1ChannelMembershipSummary(entry, context);
    });
};
const deserializeAws_restJson1ChannelMessage = (output, context) => {
  return {
    ChannelArn: output.ChannelArn !== undefined && output.ChannelArn !== null ? output.ChannelArn : undefined,
    Content: output.Content !== undefined && output.Content !== null ? output.Content : undefined,
    CreatedTimestamp:
      output.CreatedTimestamp !== undefined && output.CreatedTimestamp !== null
        ? new Date(Math.round(output.CreatedTimestamp * 1000))
        : undefined,
    LastEditedTimestamp:
      output.LastEditedTimestamp !== undefined && output.LastEditedTimestamp !== null
        ? new Date(Math.round(output.LastEditedTimestamp * 1000))
        : undefined,
    LastUpdatedTimestamp:
      output.LastUpdatedTimestamp !== undefined && output.LastUpdatedTimestamp !== null
        ? new Date(Math.round(output.LastUpdatedTimestamp * 1000))
        : undefined,
    MessageId: output.MessageId !== undefined && output.MessageId !== null ? output.MessageId : undefined,
    Metadata: output.Metadata !== undefined && output.Metadata !== null ? output.Metadata : undefined,
    Persistence: output.Persistence !== undefined && output.Persistence !== null ? output.Persistence : undefined,
    Redacted: output.Redacted !== undefined && output.Redacted !== null ? output.Redacted : undefined,
    Sender:
      output.Sender !== undefined && output.Sender !== null
        ? deserializeAws_restJson1Identity(output.Sender, context)
        : undefined,
    Type: output.Type !== undefined && output.Type !== null ? output.Type : undefined,
  };
};
const deserializeAws_restJson1ChannelMessageSummary = (output, context) => {
  return {
    Content: output.Content !== undefined && output.Content !== null ? output.Content : undefined,
    CreatedTimestamp:
      output.CreatedTimestamp !== undefined && output.CreatedTimestamp !== null
        ? new Date(Math.round(output.CreatedTimestamp * 1000))
        : undefined,
    LastEditedTimestamp:
      output.LastEditedTimestamp !== undefined && output.LastEditedTimestamp !== null
        ? new Date(Math.round(output.LastEditedTimestamp * 1000))
        : undefined,
    LastUpdatedTimestamp:
      output.LastUpdatedTimestamp !== undefined && output.LastUpdatedTimestamp !== null
        ? new Date(Math.round(output.LastUpdatedTimestamp * 1000))
        : undefined,
    MessageId: output.MessageId !== undefined && output.MessageId !== null ? output.MessageId : undefined,
    Metadata: output.Metadata !== undefined && output.Metadata !== null ? output.Metadata : undefined,
    Redacted: output.Redacted !== undefined && output.Redacted !== null ? output.Redacted : undefined,
    Sender:
      output.Sender !== undefined && output.Sender !== null
        ? deserializeAws_restJson1Identity(output.Sender, context)
        : undefined,
    Type: output.Type !== undefined && output.Type !== null ? output.Type : undefined,
  };
};
const deserializeAws_restJson1ChannelMessageSummaryList = (output, context) => {
  return (output || [])
    .filter((e) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null;
      }
      return deserializeAws_restJson1ChannelMessageSummary(entry, context);
    });
};
const deserializeAws_restJson1ChannelModeratedByAppInstanceUserSummary = (output, context) => {
  return {
    ChannelSummary:
      output.ChannelSummary !== undefined && output.ChannelSummary !== null
        ? deserializeAws_restJson1ChannelSummary(output.ChannelSummary, context)
        : undefined,
  };
};
const deserializeAws_restJson1ChannelModeratedByAppInstanceUserSummaryList = (output, context) => {
  return (output || [])
    .filter((e) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null;
      }
      return deserializeAws_restJson1ChannelModeratedByAppInstanceUserSummary(entry, context);
    });
};
const deserializeAws_restJson1ChannelModerator = (output, context) => {
  return {
    ChannelArn: output.ChannelArn !== undefined && output.ChannelArn !== null ? output.ChannelArn : undefined,
    CreatedBy:
      output.CreatedBy !== undefined && output.CreatedBy !== null
        ? deserializeAws_restJson1Identity(output.CreatedBy, context)
        : undefined,
    CreatedTimestamp:
      output.CreatedTimestamp !== undefined && output.CreatedTimestamp !== null
        ? new Date(Math.round(output.CreatedTimestamp * 1000))
        : undefined,
    Moderator:
      output.Moderator !== undefined && output.Moderator !== null
        ? deserializeAws_restJson1Identity(output.Moderator, context)
        : undefined,
  };
};
const deserializeAws_restJson1ChannelModeratorSummary = (output, context) => {
  return {
    Moderator:
      output.Moderator !== undefined && output.Moderator !== null
        ? deserializeAws_restJson1Identity(output.Moderator, context)
        : undefined,
  };
};
const deserializeAws_restJson1ChannelModeratorSummaryList = (output, context) => {
  return (output || [])
    .filter((e) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null;
      }
      return deserializeAws_restJson1ChannelModeratorSummary(entry, context);
    });
};
const deserializeAws_restJson1ChannelRetentionSettings = (output, context) => {
  return {
    RetentionDays:
      output.RetentionDays !== undefined && output.RetentionDays !== null ? output.RetentionDays : undefined,
  };
};
const deserializeAws_restJson1ChannelSummary = (output, context) => {
  return {
    ChannelArn: output.ChannelArn !== undefined && output.ChannelArn !== null ? output.ChannelArn : undefined,
    LastMessageTimestamp:
      output.LastMessageTimestamp !== undefined && output.LastMessageTimestamp !== null
        ? new Date(Math.round(output.LastMessageTimestamp * 1000))
        : undefined,
    Metadata: output.Metadata !== undefined && output.Metadata !== null ? output.Metadata : undefined,
    Mode: output.Mode !== undefined && output.Mode !== null ? output.Mode : undefined,
    Name: output.Name !== undefined && output.Name !== null ? output.Name : undefined,
    Privacy: output.Privacy !== undefined && output.Privacy !== null ? output.Privacy : undefined,
  };
};
const deserializeAws_restJson1ChannelSummaryList = (output, context) => {
  return (output || [])
    .filter((e) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null;
      }
      return deserializeAws_restJson1ChannelSummary(entry, context);
    });
};
const deserializeAws_restJson1ConversationRetentionSettings = (output, context) => {
  return {
    RetentionDays:
      output.RetentionDays !== undefined && output.RetentionDays !== null ? output.RetentionDays : undefined,
  };
};
const deserializeAws_restJson1CreateAttendeeError = (output, context) => {
  return {
    ErrorCode: output.ErrorCode !== undefined && output.ErrorCode !== null ? output.ErrorCode : undefined,
    ErrorMessage: output.ErrorMessage !== undefined && output.ErrorMessage !== null ? output.ErrorMessage : undefined,
    ExternalUserId:
      output.ExternalUserId !== undefined && output.ExternalUserId !== null ? output.ExternalUserId : undefined,
  };
};
const deserializeAws_restJson1DNISEmergencyCallingConfiguration = (output, context) => {
  return {
    CallingCountry:
      output.CallingCountry !== undefined && output.CallingCountry !== null ? output.CallingCountry : undefined,
    EmergencyPhoneNumber:
      output.EmergencyPhoneNumber !== undefined && output.EmergencyPhoneNumber !== null
        ? output.EmergencyPhoneNumber
        : undefined,
    TestPhoneNumber:
      output.TestPhoneNumber !== undefined && output.TestPhoneNumber !== null ? output.TestPhoneNumber : undefined,
  };
};
const deserializeAws_restJson1DNISEmergencyCallingConfigurationList = (output, context) => {
  return (output || [])
    .filter((e) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null;
      }
      return deserializeAws_restJson1DNISEmergencyCallingConfiguration(entry, context);
    });
};
const deserializeAws_restJson1E164PhoneNumberList = (output, context) => {
  return (output || [])
    .filter((e) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null;
      }
      return entry;
    });
};
const deserializeAws_restJson1EmergencyCallingConfiguration = (output, context) => {
  return {
    DNIS:
      output.DNIS !== undefined && output.DNIS !== null
        ? deserializeAws_restJson1DNISEmergencyCallingConfigurationList(output.DNIS, context)
        : undefined,
  };
};
const deserializeAws_restJson1EventsConfiguration = (output, context) => {
  return {
    BotId: output.BotId !== undefined && output.BotId !== null ? output.BotId : undefined,
    LambdaFunctionArn:
      output.LambdaFunctionArn !== undefined && output.LambdaFunctionArn !== null
        ? output.LambdaFunctionArn
        : undefined,
    OutboundEventsHTTPSEndpoint:
      output.OutboundEventsHTTPSEndpoint !== undefined && output.OutboundEventsHTTPSEndpoint !== null
        ? output.OutboundEventsHTTPSEndpoint
        : undefined,
  };
};
const deserializeAws_restJson1GeoMatchParams = (output, context) => {
  return {
    AreaCode: output.AreaCode !== undefined && output.AreaCode !== null ? output.AreaCode : undefined,
    Country: output.Country !== undefined && output.Country !== null ? output.Country : undefined,
  };
};
const deserializeAws_restJson1Identity = (output, context) => {
  return {
    Arn: output.Arn !== undefined && output.Arn !== null ? output.Arn : undefined,
    Name: output.Name !== undefined && output.Name !== null ? output.Name : undefined,
  };
};
const deserializeAws_restJson1Invite = (output, context) => {
  return {
    EmailAddress: output.EmailAddress !== undefined && output.EmailAddress !== null ? output.EmailAddress : undefined,
    EmailStatus: output.EmailStatus !== undefined && output.EmailStatus !== null ? output.EmailStatus : undefined,
    InviteId: output.InviteId !== undefined && output.InviteId !== null ? output.InviteId : undefined,
    Status: output.Status !== undefined && output.Status !== null ? output.Status : undefined,
  };
};
const deserializeAws_restJson1InviteList = (output, context) => {
  return (output || [])
    .filter((e) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null;
      }
      return deserializeAws_restJson1Invite(entry, context);
    });
};
const deserializeAws_restJson1LicenseList = (output, context) => {
  return (output || [])
    .filter((e) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null;
      }
      return entry;
    });
};
const deserializeAws_restJson1LoggingConfiguration = (output, context) => {
  return {
    EnableSIPLogs:
      output.EnableSIPLogs !== undefined && output.EnableSIPLogs !== null ? output.EnableSIPLogs : undefined,
  };
};
const deserializeAws_restJson1MediaPlacement = (output, context) => {
  return {
    AudioFallbackUrl:
      output.AudioFallbackUrl !== undefined && output.AudioFallbackUrl !== null ? output.AudioFallbackUrl : undefined,
    AudioHostUrl: output.AudioHostUrl !== undefined && output.AudioHostUrl !== null ? output.AudioHostUrl : undefined,
    ScreenDataUrl:
      output.ScreenDataUrl !== undefined && output.ScreenDataUrl !== null ? output.ScreenDataUrl : undefined,
    ScreenSharingUrl:
      output.ScreenSharingUrl !== undefined && output.ScreenSharingUrl !== null ? output.ScreenSharingUrl : undefined,
    ScreenViewingUrl:
      output.ScreenViewingUrl !== undefined && output.ScreenViewingUrl !== null ? output.ScreenViewingUrl : undefined,
    SignalingUrl: output.SignalingUrl !== undefined && output.SignalingUrl !== null ? output.SignalingUrl : undefined,
    TurnControlUrl:
      output.TurnControlUrl !== undefined && output.TurnControlUrl !== null ? output.TurnControlUrl : undefined,
  };
};
const deserializeAws_restJson1Meeting = (output, context) => {
  return {
    ExternalMeetingId:
      output.ExternalMeetingId !== undefined && output.ExternalMeetingId !== null
        ? output.ExternalMeetingId
        : undefined,
    MediaPlacement:
      output.MediaPlacement !== undefined && output.MediaPlacement !== null
        ? deserializeAws_restJson1MediaPlacement(output.MediaPlacement, context)
        : undefined,
    MediaRegion: output.MediaRegion !== undefined && output.MediaRegion !== null ? output.MediaRegion : undefined,
    MeetingId: output.MeetingId !== undefined && output.MeetingId !== null ? output.MeetingId : undefined,
  };
};
const deserializeAws_restJson1MeetingList = (output, context) => {
  return (output || [])
    .filter((e) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null;
      }
      return deserializeAws_restJson1Meeting(entry, context);
    });
};
const deserializeAws_restJson1Member = (output, context) => {
  return {
    AccountId: output.AccountId !== undefined && output.AccountId !== null ? output.AccountId : undefined,
    Email: output.Email !== undefined && output.Email !== null ? output.Email : undefined,
    FullName: output.FullName !== undefined && output.FullName !== null ? output.FullName : undefined,
    MemberId: output.MemberId !== undefined && output.MemberId !== null ? output.MemberId : undefined,
    MemberType: output.MemberType !== undefined && output.MemberType !== null ? output.MemberType : undefined,
  };
};
const deserializeAws_restJson1MemberError = (output, context) => {
  return {
    ErrorCode: output.ErrorCode !== undefined && output.ErrorCode !== null ? output.ErrorCode : undefined,
    ErrorMessage: output.ErrorMessage !== undefined && output.ErrorMessage !== null ? output.ErrorMessage : undefined,
    MemberId: output.MemberId !== undefined && output.MemberId !== null ? output.MemberId : undefined,
  };
};
const deserializeAws_restJson1MemberErrorList = (output, context) => {
  return (output || [])
    .filter((e) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null;
      }
      return deserializeAws_restJson1MemberError(entry, context);
    });
};
const deserializeAws_restJson1Members = (output, context) => {
  return (output || [])
    .filter((e) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null;
      }
      return deserializeAws_restJson1Identity(entry, context);
    });
};
const deserializeAws_restJson1MessagingSessionEndpoint = (output, context) => {
  return {
    Url: output.Url !== undefined && output.Url !== null ? output.Url : undefined,
  };
};
const deserializeAws_restJson1OrderedPhoneNumber = (output, context) => {
  return {
    E164PhoneNumber:
      output.E164PhoneNumber !== undefined && output.E164PhoneNumber !== null ? output.E164PhoneNumber : undefined,
    Status: output.Status !== undefined && output.Status !== null ? output.Status : undefined,
  };
};
const deserializeAws_restJson1OrderedPhoneNumberList = (output, context) => {
  return (output || [])
    .filter((e) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null;
      }
      return deserializeAws_restJson1OrderedPhoneNumber(entry, context);
    });
};
const deserializeAws_restJson1Origination = (output, context) => {
  return {
    Disabled: output.Disabled !== undefined && output.Disabled !== null ? output.Disabled : undefined,
    Routes:
      output.Routes !== undefined && output.Routes !== null
        ? deserializeAws_restJson1OriginationRouteList(output.Routes, context)
        : undefined,
  };
};
const deserializeAws_restJson1OriginationRoute = (output, context) => {
  return {
    Host: output.Host !== undefined && output.Host !== null ? output.Host : undefined,
    Port: output.Port !== undefined && output.Port !== null ? output.Port : undefined,
    Priority: output.Priority !== undefined && output.Priority !== null ? output.Priority : undefined,
    Protocol: output.Protocol !== undefined && output.Protocol !== null ? output.Protocol : undefined,
    Weight: output.Weight !== undefined && output.Weight !== null ? output.Weight : undefined,
  };
};
const deserializeAws_restJson1OriginationRouteList = (output, context) => {
  return (output || [])
    .filter((e) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null;
      }
      return deserializeAws_restJson1OriginationRoute(entry, context);
    });
};
const deserializeAws_restJson1Participant = (output, context) => {
  return {
    PhoneNumber: output.PhoneNumber !== undefined && output.PhoneNumber !== null ? output.PhoneNumber : undefined,
    ProxyPhoneNumber:
      output.ProxyPhoneNumber !== undefined && output.ProxyPhoneNumber !== null ? output.ProxyPhoneNumber : undefined,
  };
};
const deserializeAws_restJson1Participants = (output, context) => {
  return (output || [])
    .filter((e) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null;
      }
      return deserializeAws_restJson1Participant(entry, context);
    });
};
const deserializeAws_restJson1PhoneNumber = (output, context) => {
  return {
    Associations:
      output.Associations !== undefined && output.Associations !== null
        ? deserializeAws_restJson1PhoneNumberAssociationList(output.Associations, context)
        : undefined,
    CallingName: output.CallingName !== undefined && output.CallingName !== null ? output.CallingName : undefined,
    CallingNameStatus:
      output.CallingNameStatus !== undefined && output.CallingNameStatus !== null
        ? output.CallingNameStatus
        : undefined,
    Capabilities:
      output.Capabilities !== undefined && output.Capabilities !== null
        ? deserializeAws_restJson1PhoneNumberCapabilities(output.Capabilities, context)
        : undefined,
    Country: output.Country !== undefined && output.Country !== null ? output.Country : undefined,
    CreatedTimestamp:
      output.CreatedTimestamp !== undefined && output.CreatedTimestamp !== null
        ? new Date(output.CreatedTimestamp)
        : undefined,
    DeletionTimestamp:
      output.DeletionTimestamp !== undefined && output.DeletionTimestamp !== null
        ? new Date(output.DeletionTimestamp)
        : undefined,
    E164PhoneNumber:
      output.E164PhoneNumber !== undefined && output.E164PhoneNumber !== null ? output.E164PhoneNumber : undefined,
    PhoneNumberId:
      output.PhoneNumberId !== undefined && output.PhoneNumberId !== null ? output.PhoneNumberId : undefined,
    ProductType: output.ProductType !== undefined && output.ProductType !== null ? output.ProductType : undefined,
    Status: output.Status !== undefined && output.Status !== null ? output.Status : undefined,
    Type: output.Type !== undefined && output.Type !== null ? output.Type : undefined,
    UpdatedTimestamp:
      output.UpdatedTimestamp !== undefined && output.UpdatedTimestamp !== null
        ? new Date(output.UpdatedTimestamp)
        : undefined,
  };
};
const deserializeAws_restJson1PhoneNumberAssociation = (output, context) => {
  return {
    AssociatedTimestamp:
      output.AssociatedTimestamp !== undefined && output.AssociatedTimestamp !== null
        ? new Date(output.AssociatedTimestamp)
        : undefined,
    Name: output.Name !== undefined && output.Name !== null ? output.Name : undefined,
    Value: output.Value !== undefined && output.Value !== null ? output.Value : undefined,
  };
};
const deserializeAws_restJson1PhoneNumberAssociationList = (output, context) => {
  return (output || [])
    .filter((e) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null;
      }
      return deserializeAws_restJson1PhoneNumberAssociation(entry, context);
    });
};
const deserializeAws_restJson1PhoneNumberCapabilities = (output, context) => {
  return {
    InboundCall: output.InboundCall !== undefined && output.InboundCall !== null ? output.InboundCall : undefined,
    InboundMMS: output.InboundMMS !== undefined && output.InboundMMS !== null ? output.InboundMMS : undefined,
    InboundSMS: output.InboundSMS !== undefined && output.InboundSMS !== null ? output.InboundSMS : undefined,
    OutboundCall: output.OutboundCall !== undefined && output.OutboundCall !== null ? output.OutboundCall : undefined,
    OutboundMMS: output.OutboundMMS !== undefined && output.OutboundMMS !== null ? output.OutboundMMS : undefined,
    OutboundSMS: output.OutboundSMS !== undefined && output.OutboundSMS !== null ? output.OutboundSMS : undefined,
  };
};
const deserializeAws_restJson1PhoneNumberCountriesList = (output, context) => {
  return (output || [])
    .filter((e) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null;
      }
      return deserializeAws_restJson1PhoneNumberCountry(entry, context);
    });
};
const deserializeAws_restJson1PhoneNumberCountry = (output, context) => {
  return {
    CountryCode: output.CountryCode !== undefined && output.CountryCode !== null ? output.CountryCode : undefined,
    SupportedPhoneNumberTypes:
      output.SupportedPhoneNumberTypes !== undefined && output.SupportedPhoneNumberTypes !== null
        ? deserializeAws_restJson1PhoneNumberTypeList(output.SupportedPhoneNumberTypes, context)
        : undefined,
  };
};
const deserializeAws_restJson1PhoneNumberError = (output, context) => {
  return {
    ErrorCode: output.ErrorCode !== undefined && output.ErrorCode !== null ? output.ErrorCode : undefined,
    ErrorMessage: output.ErrorMessage !== undefined && output.ErrorMessage !== null ? output.ErrorMessage : undefined,
    PhoneNumberId:
      output.PhoneNumberId !== undefined && output.PhoneNumberId !== null ? output.PhoneNumberId : undefined,
  };
};
const deserializeAws_restJson1PhoneNumberErrorList = (output, context) => {
  return (output || [])
    .filter((e) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null;
      }
      return deserializeAws_restJson1PhoneNumberError(entry, context);
    });
};
const deserializeAws_restJson1PhoneNumberList = (output, context) => {
  return (output || [])
    .filter((e) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null;
      }
      return deserializeAws_restJson1PhoneNumber(entry, context);
    });
};
const deserializeAws_restJson1PhoneNumberOrder = (output, context) => {
  return {
    CreatedTimestamp:
      output.CreatedTimestamp !== undefined && output.CreatedTimestamp !== null
        ? new Date(output.CreatedTimestamp)
        : undefined,
    OrderedPhoneNumbers:
      output.OrderedPhoneNumbers !== undefined && output.OrderedPhoneNumbers !== null
        ? deserializeAws_restJson1OrderedPhoneNumberList(output.OrderedPhoneNumbers, context)
        : undefined,
    PhoneNumberOrderId:
      output.PhoneNumberOrderId !== undefined && output.PhoneNumberOrderId !== null
        ? output.PhoneNumberOrderId
        : undefined,
    ProductType: output.ProductType !== undefined && output.ProductType !== null ? output.ProductType : undefined,
    Status: output.Status !== undefined && output.Status !== null ? output.Status : undefined,
    UpdatedTimestamp:
      output.UpdatedTimestamp !== undefined && output.UpdatedTimestamp !== null
        ? new Date(output.UpdatedTimestamp)
        : undefined,
  };
};
const deserializeAws_restJson1PhoneNumberOrderList = (output, context) => {
  return (output || [])
    .filter((e) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null;
      }
      return deserializeAws_restJson1PhoneNumberOrder(entry, context);
    });
};
const deserializeAws_restJson1PhoneNumberTypeList = (output, context) => {
  return (output || [])
    .filter((e) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null;
      }
      return entry;
    });
};
const deserializeAws_restJson1Proxy = (output, context) => {
  return {
    DefaultSessionExpiryMinutes:
      output.DefaultSessionExpiryMinutes !== undefined && output.DefaultSessionExpiryMinutes !== null
        ? output.DefaultSessionExpiryMinutes
        : undefined,
    Disabled: output.Disabled !== undefined && output.Disabled !== null ? output.Disabled : undefined,
    FallBackPhoneNumber:
      output.FallBackPhoneNumber !== undefined && output.FallBackPhoneNumber !== null
        ? output.FallBackPhoneNumber
        : undefined,
    PhoneNumberCountries:
      output.PhoneNumberCountries !== undefined && output.PhoneNumberCountries !== null
        ? deserializeAws_restJson1StringList(output.PhoneNumberCountries, context)
        : undefined,
  };
};
const deserializeAws_restJson1ProxySession = (output, context) => {
  return {
    Capabilities:
      output.Capabilities !== undefined && output.Capabilities !== null
        ? deserializeAws_restJson1CapabilityList(output.Capabilities, context)
        : undefined,
    CreatedTimestamp:
      output.CreatedTimestamp !== undefined && output.CreatedTimestamp !== null
        ? new Date(output.CreatedTimestamp)
        : undefined,
    EndedTimestamp:
      output.EndedTimestamp !== undefined && output.EndedTimestamp !== null
        ? new Date(output.EndedTimestamp)
        : undefined,
    ExpiryMinutes:
      output.ExpiryMinutes !== undefined && output.ExpiryMinutes !== null ? output.ExpiryMinutes : undefined,
    GeoMatchLevel:
      output.GeoMatchLevel !== undefined && output.GeoMatchLevel !== null ? output.GeoMatchLevel : undefined,
    GeoMatchParams:
      output.GeoMatchParams !== undefined && output.GeoMatchParams !== null
        ? deserializeAws_restJson1GeoMatchParams(output.GeoMatchParams, context)
        : undefined,
    Name: output.Name !== undefined && output.Name !== null ? output.Name : undefined,
    NumberSelectionBehavior:
      output.NumberSelectionBehavior !== undefined && output.NumberSelectionBehavior !== null
        ? output.NumberSelectionBehavior
        : undefined,
    Participants:
      output.Participants !== undefined && output.Participants !== null
        ? deserializeAws_restJson1Participants(output.Participants, context)
        : undefined,
    ProxySessionId:
      output.ProxySessionId !== undefined && output.ProxySessionId !== null ? output.ProxySessionId : undefined,
    Status: output.Status !== undefined && output.Status !== null ? output.Status : undefined,
    UpdatedTimestamp:
      output.UpdatedTimestamp !== undefined && output.UpdatedTimestamp !== null
        ? new Date(output.UpdatedTimestamp)
        : undefined,
    VoiceConnectorId:
      output.VoiceConnectorId !== undefined && output.VoiceConnectorId !== null ? output.VoiceConnectorId : undefined,
  };
};
const deserializeAws_restJson1ProxySessions = (output, context) => {
  return (output || [])
    .filter((e) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null;
      }
      return deserializeAws_restJson1ProxySession(entry, context);
    });
};
const deserializeAws_restJson1RetentionSettings = (output, context) => {
  return {
    ConversationRetentionSettings:
      output.ConversationRetentionSettings !== undefined && output.ConversationRetentionSettings !== null
        ? deserializeAws_restJson1ConversationRetentionSettings(output.ConversationRetentionSettings, context)
        : undefined,
    RoomRetentionSettings:
      output.RoomRetentionSettings !== undefined && output.RoomRetentionSettings !== null
        ? deserializeAws_restJson1RoomRetentionSettings(output.RoomRetentionSettings, context)
        : undefined,
  };
};
const deserializeAws_restJson1Room = (output, context) => {
  return {
    AccountId: output.AccountId !== undefined && output.AccountId !== null ? output.AccountId : undefined,
    CreatedBy: output.CreatedBy !== undefined && output.CreatedBy !== null ? output.CreatedBy : undefined,
    CreatedTimestamp:
      output.CreatedTimestamp !== undefined && output.CreatedTimestamp !== null
        ? new Date(output.CreatedTimestamp)
        : undefined,
    Name: output.Name !== undefined && output.Name !== null ? output.Name : undefined,
    RoomId: output.RoomId !== undefined && output.RoomId !== null ? output.RoomId : undefined,
    UpdatedTimestamp:
      output.UpdatedTimestamp !== undefined && output.UpdatedTimestamp !== null
        ? new Date(output.UpdatedTimestamp)
        : undefined,
  };
};
const deserializeAws_restJson1RoomList = (output, context) => {
  return (output || [])
    .filter((e) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null;
      }
      return deserializeAws_restJson1Room(entry, context);
    });
};
const deserializeAws_restJson1RoomMembership = (output, context) => {
  return {
    InvitedBy: output.InvitedBy !== undefined && output.InvitedBy !== null ? output.InvitedBy : undefined,
    Member:
      output.Member !== undefined && output.Member !== null
        ? deserializeAws_restJson1Member(output.Member, context)
        : undefined,
    Role: output.Role !== undefined && output.Role !== null ? output.Role : undefined,
    RoomId: output.RoomId !== undefined && output.RoomId !== null ? output.RoomId : undefined,
    UpdatedTimestamp:
      output.UpdatedTimestamp !== undefined && output.UpdatedTimestamp !== null
        ? new Date(output.UpdatedTimestamp)
        : undefined,
  };
};
const deserializeAws_restJson1RoomMembershipList = (output, context) => {
  return (output || [])
    .filter((e) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null;
      }
      return deserializeAws_restJson1RoomMembership(entry, context);
    });
};
const deserializeAws_restJson1RoomRetentionSettings = (output, context) => {
  return {
    RetentionDays:
      output.RetentionDays !== undefined && output.RetentionDays !== null ? output.RetentionDays : undefined,
  };
};
const deserializeAws_restJson1SensitiveStringList = (output, context) => {
  return (output || [])
    .filter((e) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null;
      }
      return entry;
    });
};
const deserializeAws_restJson1SigninDelegateGroup = (output, context) => {
  return {
    GroupName: output.GroupName !== undefined && output.GroupName !== null ? output.GroupName : undefined,
  };
};
const deserializeAws_restJson1SigninDelegateGroupList = (output, context) => {
  return (output || [])
    .filter((e) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null;
      }
      return deserializeAws_restJson1SigninDelegateGroup(entry, context);
    });
};
const deserializeAws_restJson1SipMediaApplication = (output, context) => {
  return {
    AwsRegion: output.AwsRegion !== undefined && output.AwsRegion !== null ? output.AwsRegion : undefined,
    CreatedTimestamp:
      output.CreatedTimestamp !== undefined && output.CreatedTimestamp !== null
        ? new Date(output.CreatedTimestamp)
        : undefined,
    Endpoints:
      output.Endpoints !== undefined && output.Endpoints !== null
        ? deserializeAws_restJson1SipMediaApplicationEndpointList(output.Endpoints, context)
        : undefined,
    Name: output.Name !== undefined && output.Name !== null ? output.Name : undefined,
    SipMediaApplicationId:
      output.SipMediaApplicationId !== undefined && output.SipMediaApplicationId !== null
        ? output.SipMediaApplicationId
        : undefined,
    UpdatedTimestamp:
      output.UpdatedTimestamp !== undefined && output.UpdatedTimestamp !== null
        ? new Date(output.UpdatedTimestamp)
        : undefined,
  };
};
const deserializeAws_restJson1SipMediaApplicationCall = (output, context) => {
  return {
    TransactionId:
      output.TransactionId !== undefined && output.TransactionId !== null ? output.TransactionId : undefined,
  };
};
const deserializeAws_restJson1SipMediaApplicationEndpoint = (output, context) => {
  return {
    LambdaArn: output.LambdaArn !== undefined && output.LambdaArn !== null ? output.LambdaArn : undefined,
  };
};
const deserializeAws_restJson1SipMediaApplicationEndpointList = (output, context) => {
  return (output || [])
    .filter((e) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null;
      }
      return deserializeAws_restJson1SipMediaApplicationEndpoint(entry, context);
    });
};
const deserializeAws_restJson1SipMediaApplicationList = (output, context) => {
  return (output || [])
    .filter((e) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null;
      }
      return deserializeAws_restJson1SipMediaApplication(entry, context);
    });
};
const deserializeAws_restJson1SipMediaApplicationLoggingConfiguration = (output, context) => {
  return {
    EnableSipMediaApplicationMessageLogs:
      output.EnableSipMediaApplicationMessageLogs !== undefined && output.EnableSipMediaApplicationMessageLogs !== null
        ? output.EnableSipMediaApplicationMessageLogs
        : undefined,
  };
};
const deserializeAws_restJson1SipRule = (output, context) => {
  return {
    CreatedTimestamp:
      output.CreatedTimestamp !== undefined && output.CreatedTimestamp !== null
        ? new Date(output.CreatedTimestamp)
        : undefined,
    Disabled: output.Disabled !== undefined && output.Disabled !== null ? output.Disabled : undefined,
    Name: output.Name !== undefined && output.Name !== null ? output.Name : undefined,
    SipRuleId: output.SipRuleId !== undefined && output.SipRuleId !== null ? output.SipRuleId : undefined,
    TargetApplications:
      output.TargetApplications !== undefined && output.TargetApplications !== null
        ? deserializeAws_restJson1SipRuleTargetApplicationList(output.TargetApplications, context)
        : undefined,
    TriggerType: output.TriggerType !== undefined && output.TriggerType !== null ? output.TriggerType : undefined,
    TriggerValue: output.TriggerValue !== undefined && output.TriggerValue !== null ? output.TriggerValue : undefined,
    UpdatedTimestamp:
      output.UpdatedTimestamp !== undefined && output.UpdatedTimestamp !== null
        ? new Date(output.UpdatedTimestamp)
        : undefined,
  };
};
const deserializeAws_restJson1SipRuleList = (output, context) => {
  return (output || [])
    .filter((e) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null;
      }
      return deserializeAws_restJson1SipRule(entry, context);
    });
};
const deserializeAws_restJson1SipRuleTargetApplication = (output, context) => {
  return {
    AwsRegion: output.AwsRegion !== undefined && output.AwsRegion !== null ? output.AwsRegion : undefined,
    Priority: output.Priority !== undefined && output.Priority !== null ? output.Priority : undefined,
    SipMediaApplicationId:
      output.SipMediaApplicationId !== undefined && output.SipMediaApplicationId !== null
        ? output.SipMediaApplicationId
        : undefined,
  };
};
const deserializeAws_restJson1SipRuleTargetApplicationList = (output, context) => {
  return (output || [])
    .filter((e) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null;
      }
      return deserializeAws_restJson1SipRuleTargetApplication(entry, context);
    });
};
const deserializeAws_restJson1StreamingConfiguration = (output, context) => {
  return {
    DataRetentionInHours:
      output.DataRetentionInHours !== undefined && output.DataRetentionInHours !== null
        ? output.DataRetentionInHours
        : undefined,
    Disabled: output.Disabled !== undefined && output.Disabled !== null ? output.Disabled : undefined,
    StreamingNotificationTargets:
      output.StreamingNotificationTargets !== undefined && output.StreamingNotificationTargets !== null
        ? deserializeAws_restJson1StreamingNotificationTargetList(output.StreamingNotificationTargets, context)
        : undefined,
  };
};
const deserializeAws_restJson1StreamingNotificationTarget = (output, context) => {
  return {
    NotificationTarget:
      output.NotificationTarget !== undefined && output.NotificationTarget !== null
        ? output.NotificationTarget
        : undefined,
  };
};
const deserializeAws_restJson1StreamingNotificationTargetList = (output, context) => {
  return (output || [])
    .filter((e) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null;
      }
      return deserializeAws_restJson1StreamingNotificationTarget(entry, context);
    });
};
const deserializeAws_restJson1StringList = (output, context) => {
  return (output || [])
    .filter((e) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null;
      }
      return entry;
    });
};
const deserializeAws_restJson1Tag = (output, context) => {
  return {
    Key: output.Key !== undefined && output.Key !== null ? output.Key : undefined,
    Value: output.Value !== undefined && output.Value !== null ? output.Value : undefined,
  };
};
const deserializeAws_restJson1TagList = (output, context) => {
  return (output || [])
    .filter((e) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null;
      }
      return deserializeAws_restJson1Tag(entry, context);
    });
};
const deserializeAws_restJson1TelephonySettings = (output, context) => {
  return {
    InboundCalling:
      output.InboundCalling !== undefined && output.InboundCalling !== null ? output.InboundCalling : undefined,
    OutboundCalling:
      output.OutboundCalling !== undefined && output.OutboundCalling !== null ? output.OutboundCalling : undefined,
    SMS: output.SMS !== undefined && output.SMS !== null ? output.SMS : undefined,
  };
};
const deserializeAws_restJson1Termination = (output, context) => {
  return {
    CallingRegions:
      output.CallingRegions !== undefined && output.CallingRegions !== null
        ? deserializeAws_restJson1CallingRegionList(output.CallingRegions, context)
        : undefined,
    CidrAllowedList:
      output.CidrAllowedList !== undefined && output.CidrAllowedList !== null
        ? deserializeAws_restJson1StringList(output.CidrAllowedList, context)
        : undefined,
    CpsLimit: output.CpsLimit !== undefined && output.CpsLimit !== null ? output.CpsLimit : undefined,
    DefaultPhoneNumber:
      output.DefaultPhoneNumber !== undefined && output.DefaultPhoneNumber !== null
        ? output.DefaultPhoneNumber
        : undefined,
    Disabled: output.Disabled !== undefined && output.Disabled !== null ? output.Disabled : undefined,
  };
};
const deserializeAws_restJson1TerminationHealth = (output, context) => {
  return {
    Source: output.Source !== undefined && output.Source !== null ? output.Source : undefined,
    Timestamp: output.Timestamp !== undefined && output.Timestamp !== null ? new Date(output.Timestamp) : undefined,
  };
};
const deserializeAws_restJson1User = (output, context) => {
  return {
    AccountId: output.AccountId !== undefined && output.AccountId !== null ? output.AccountId : undefined,
    AlexaForBusinessMetadata:
      output.AlexaForBusinessMetadata !== undefined && output.AlexaForBusinessMetadata !== null
        ? deserializeAws_restJson1AlexaForBusinessMetadata(output.AlexaForBusinessMetadata, context)
        : undefined,
    DisplayName: output.DisplayName !== undefined && output.DisplayName !== null ? output.DisplayName : undefined,
    InvitedOn: output.InvitedOn !== undefined && output.InvitedOn !== null ? new Date(output.InvitedOn) : undefined,
    LicenseType: output.LicenseType !== undefined && output.LicenseType !== null ? output.LicenseType : undefined,
    PersonalPIN: output.PersonalPIN !== undefined && output.PersonalPIN !== null ? output.PersonalPIN : undefined,
    PrimaryEmail: output.PrimaryEmail !== undefined && output.PrimaryEmail !== null ? output.PrimaryEmail : undefined,
    PrimaryProvisionedNumber:
      output.PrimaryProvisionedNumber !== undefined && output.PrimaryProvisionedNumber !== null
        ? output.PrimaryProvisionedNumber
        : undefined,
    RegisteredOn:
      output.RegisteredOn !== undefined && output.RegisteredOn !== null ? new Date(output.RegisteredOn) : undefined,
    UserId: output.UserId !== undefined && output.UserId !== null ? output.UserId : undefined,
    UserInvitationStatus:
      output.UserInvitationStatus !== undefined && output.UserInvitationStatus !== null
        ? output.UserInvitationStatus
        : undefined,
    UserRegistrationStatus:
      output.UserRegistrationStatus !== undefined && output.UserRegistrationStatus !== null
        ? output.UserRegistrationStatus
        : undefined,
    UserType: output.UserType !== undefined && output.UserType !== null ? output.UserType : undefined,
  };
};
const deserializeAws_restJson1UserError = (output, context) => {
  return {
    ErrorCode: output.ErrorCode !== undefined && output.ErrorCode !== null ? output.ErrorCode : undefined,
    ErrorMessage: output.ErrorMessage !== undefined && output.ErrorMessage !== null ? output.ErrorMessage : undefined,
    UserId: output.UserId !== undefined && output.UserId !== null ? output.UserId : undefined,
  };
};
const deserializeAws_restJson1UserErrorList = (output, context) => {
  return (output || [])
    .filter((e) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null;
      }
      return deserializeAws_restJson1UserError(entry, context);
    });
};
const deserializeAws_restJson1UserList = (output, context) => {
  return (output || [])
    .filter((e) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null;
      }
      return deserializeAws_restJson1User(entry, context);
    });
};
const deserializeAws_restJson1UserSettings = (output, context) => {
  return {
    Telephony:
      output.Telephony !== undefined && output.Telephony !== null
        ? deserializeAws_restJson1TelephonySettings(output.Telephony, context)
        : undefined,
  };
};
const deserializeAws_restJson1VoiceConnector = (output, context) => {
  return {
    AwsRegion: output.AwsRegion !== undefined && output.AwsRegion !== null ? output.AwsRegion : undefined,
    CreatedTimestamp:
      output.CreatedTimestamp !== undefined && output.CreatedTimestamp !== null
        ? new Date(output.CreatedTimestamp)
        : undefined,
    Name: output.Name !== undefined && output.Name !== null ? output.Name : undefined,
    OutboundHostName:
      output.OutboundHostName !== undefined && output.OutboundHostName !== null ? output.OutboundHostName : undefined,
    RequireEncryption:
      output.RequireEncryption !== undefined && output.RequireEncryption !== null
        ? output.RequireEncryption
        : undefined,
    UpdatedTimestamp:
      output.UpdatedTimestamp !== undefined && output.UpdatedTimestamp !== null
        ? new Date(output.UpdatedTimestamp)
        : undefined,
    VoiceConnectorId:
      output.VoiceConnectorId !== undefined && output.VoiceConnectorId !== null ? output.VoiceConnectorId : undefined,
  };
};
const deserializeAws_restJson1VoiceConnectorGroup = (output, context) => {
  return {
    CreatedTimestamp:
      output.CreatedTimestamp !== undefined && output.CreatedTimestamp !== null
        ? new Date(output.CreatedTimestamp)
        : undefined,
    Name: output.Name !== undefined && output.Name !== null ? output.Name : undefined,
    UpdatedTimestamp:
      output.UpdatedTimestamp !== undefined && output.UpdatedTimestamp !== null
        ? new Date(output.UpdatedTimestamp)
        : undefined,
    VoiceConnectorGroupId:
      output.VoiceConnectorGroupId !== undefined && output.VoiceConnectorGroupId !== null
        ? output.VoiceConnectorGroupId
        : undefined,
    VoiceConnectorItems:
      output.VoiceConnectorItems !== undefined && output.VoiceConnectorItems !== null
        ? deserializeAws_restJson1VoiceConnectorItemList(output.VoiceConnectorItems, context)
        : undefined,
  };
};
const deserializeAws_restJson1VoiceConnectorGroupList = (output, context) => {
  return (output || [])
    .filter((e) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null;
      }
      return deserializeAws_restJson1VoiceConnectorGroup(entry, context);
    });
};
const deserializeAws_restJson1VoiceConnectorItem = (output, context) => {
  return {
    Priority: output.Priority !== undefined && output.Priority !== null ? output.Priority : undefined,
    VoiceConnectorId:
      output.VoiceConnectorId !== undefined && output.VoiceConnectorId !== null ? output.VoiceConnectorId : undefined,
  };
};
const deserializeAws_restJson1VoiceConnectorItemList = (output, context) => {
  return (output || [])
    .filter((e) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null;
      }
      return deserializeAws_restJson1VoiceConnectorItem(entry, context);
    });
};
const deserializeAws_restJson1VoiceConnectorList = (output, context) => {
  return (output || [])
    .filter((e) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null;
      }
      return deserializeAws_restJson1VoiceConnector(entry, context);
    });
};
const deserializeAws_restJson1VoiceConnectorSettings = (output, context) => {
  return {
    CdrBucket: output.CdrBucket !== undefined && output.CdrBucket !== null ? output.CdrBucket : undefined,
  };
};
const deserializeMetadata = (output) => {
  var _a;
  return {
    httpStatusCode: output.statusCode,
    requestId:
      (_a = output.headers["x-amzn-requestid"]) !== null && _a !== void 0 ? _a : output.headers["x-amzn-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
  };
};
// Collect low-level response body stream to Uint8Array.
const collectBody = (streamBody = new Uint8Array(), context) => {
  if (streamBody instanceof Uint8Array) {
    return Promise.resolve(streamBody);
  }
  return context.streamCollector(streamBody) || Promise.resolve(new Uint8Array());
};
// Encode Uint8Array data into string with utf-8.
const collectBodyString = (streamBody, context) =>
  collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
const isSerializableHeaderValue = (value) =>
  value !== undefined &&
  value !== null &&
  value !== "" &&
  (!Object.getOwnPropertyNames(value).includes("length") || value.length != 0) &&
  (!Object.getOwnPropertyNames(value).includes("size") || value.size != 0);
const parseBody = (streamBody, context) =>
  collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
      return JSON.parse(encoded);
    }
    return {};
  });
/**
 * Load an error code for the aws.rest-json-1.1 protocol.
 */
const loadRestJsonErrorCode = (output, data) => {
  const findKey = (object, key) => Object.keys(object).find((k) => k.toLowerCase() === key.toLowerCase());
  const sanitizeErrorCode = (rawValue) => {
    let cleanValue = rawValue;
    if (cleanValue.indexOf(":") >= 0) {
      cleanValue = cleanValue.split(":")[0];
    }
    if (cleanValue.indexOf("#") >= 0) {
      cleanValue = cleanValue.split("#")[1];
    }
    return cleanValue;
  };
  const headerKey = findKey(output.headers, "x-amzn-errortype");
  if (headerKey !== undefined) {
    return sanitizeErrorCode(output.headers[headerKey]);
  }
  if (data.code !== undefined) {
    return sanitizeErrorCode(data.code);
  }
  if (data["__type"] !== undefined) {
    return sanitizeErrorCode(data["__type"]);
  }
  return "";
};
//# sourceMappingURL=Aws_restJson1.js.map
